

--- Start of file: acis.rst ---


.. module:: ezdxf.acis

.. ACIS_Tools

ACIS Tools
==========

The :mod:`ezdxf.acis` sub-package provides some :term:`ACIS` data management
tools. The main goals of this tools are:

    1. load and parse simple and known :term:`ACIS` data structures
    2. create and export simple and known :term:`ACIS` data structures

It is NOT a goal to load and edit arbitrary existing :term:`ACIS` structures.

    Don't even try it!

These tools cannot replace the official :term:`ACIS` SDK due to the complexity of
the data structures and the absence of an :term:`ACIS` kernel.  Without access to
the full documentation it is very cumbersome to reverse-engineer entities and
their properties, therefore the analysis of the :term:`ACIS` data structures is
limited to the use as embedded data in DXF and DWG files.

The `ezdxf` library does not provide an :term:`ACIS` kernel and there are no
plans for implementing one because this is far beyond my capabilities, but it
is possible to extract geometries made up only by flat polygonal faces (polyhedron)
from ACIS data.  Exporting polyhedrons as ACIS data and loading this DXF file by
Autodesk products or BricsCAD works for :term:`SAT` data for DXF R2000-R2010 and
for :term:`SAB` data for DXF R2013-R2018.

.. module:: ezdxf.acis.api

.. important::

    Always import from the public interface module :mod:`ezdxf.acis.api`,
    the internal package and module structure may change in the future and
    imports from other modules than :mod:`api` will break.


Functions
~~~~~~~~~

.. autofunction:: load_dxf

Example:

.. code-block:: Python

    import ezdxf
    from ezdxf.acis import api as acis

    doc = ezdxf.readfile("your.dxf")
    msp = doc.modelspace()

    for e in msp.query("3DSOLID"):
        bodies = acis.load_dxf(e)
        ...

.. autofunction:: export_dxf

Example:

.. code-block:: Python

    import ezdxf
    from ezdxf.render import forms
    from ezdxf.acis import api as acis

    doc = ezdxf.new("R2000")
    msp = doc.modelspace()

    # create an ACIS body from a simple cube-mesh
    body = acis.body_from_mesh(forms.cube())
    solid3d = msp.add_3dsolid()
    acis.export_dxf(solid3d, [body])
    doc.saveas("cube.dxf")


.. autofunction:: load

.. autofunction:: export_sat

.. autofunction:: export_sab

.. autofunction:: mesh_from_body

The following images show the limitations of the :func:`mesh_from_body`
function. The first image shows the source ``3DSOLID`` entities with
subtraction of entities with flat and curved faces:

.. figure:: gfx/solids-acis.png

Example script to extracts all flat polygonal faces as meshes:

.. code-block:: Python

    import ezdxf
    from ezdxf.acis import api as acis


    doc = ezdxf.readfile("3dsolids.dxf")
    msp = doc.modelspace()

    doc_out = ezdxf.new()
    msp_out = doc_out.modelspace()

    for e in msp.query("3DSOLID"):
        for body in acis.load_dxf(data):
            for mesh in acis.mesh_from_body(body):
                mesh.render_mesh(msp_out)
    doc_out.saveas("meshes.dxf")

The second image shows the flat faces extracted from the ``3DSOLID`` entities
and exported as :class:`~ezdxf.entities.Mesh` entities:

.. figure:: gfx/solids-mesh.png

As you can see all faces which do not have straight lines as boundaries are
lost.

.. autofunction:: body_from_mesh

.. autofunction:: vertices_from_body
    
Exceptions
~~~~~~~~~~

.. class:: AcisException

    Base exception of the :mod:`ezdxf.acis` package.

.. class:: ParsingError

    Exception raised when loading invalid or unknown :term:`ACIS` structures.

.. class:: ExportError

    Exception raised when exporting invalid or unknown :term:`ACIS` structures.

.. class:: InvalidLinkStructure

    Exception raised when the internal link structure is damaged.

.. module:: ezdxf.acis.entities

Entities
~~~~~~~~

A document (`sat.pdf`_) about the basic ACIS 7.0 file format is floating in the
internet.

This section contains the additional information about the entities,
I got from analyzing the SAT data extracted from DXF files exported
by BricsCAD.

This documentation ignores the differences to the ACIS format prior to version
7.0 and all this differences are handled internally.

Writing support for ACIS version < 7.0 is not required because all CAD
applications should be able to process version 7.0, even if embedded in a very
old DXF R2000 format (tested with Autodesk TrueView, BricsCAD and Nemetschek
Allplan).

The first goal is to document the entities which are required to represent
a geometry as flat polygonal faces (polyhedron), which can be converted into
a :class:`~ezdxf.render.MeshBuilder` object.

Topology Entities:

    - :class:`Body`
    - :class:`Lump`
    - :class:`Shell`
    - :class:`Face`
    - :class:`Loop`
    - :class:`Coedge`
    - :class:`Edge`
    - :class:`Vertex`

Geometry Entities:

    - :class:`Transform`
    - :class:`Surface`
    - :class:`Plane`
    - :class:`Curve`
    - :class:`StraightCurve`
    - :class:`Point`

.. attribute:: NONE_REF

    Special sentinel entity which supports the :attr:`type` attribute and the
    :attr:`is_none` property. Represents all unset entities.
    Use this idiom on any entity type to check if an entity is unset::

        if entity.is_none:
            ...


AcisEntity
----------

.. class:: AcisEntity

    Base class for all ACIS entities.

    .. attribute:: type

        Name of the type as str.

    .. attribute:: id

        Unique id as int or -1 if not set.

    .. attribute:: attributes

        Reference to the first :class:`Attribute` entity (not supported).

    .. attribute:: is_none

        ``True`` for unset entities represented by the :attr:`NONE_REF`
        instance.

Transform
---------

.. class:: Transform(AcisEntity)

    Represents an affine transformation operation which transform the
    :class:`body` to the final location, size and rotation.

    .. attribute:: matrix

        Transformation matrix of type :class:`ezdxf.math.Matrix44`.

Body
----

.. class:: Body(AcisEntity)

    Represents a solid geometry, which can consist of multiple :class:`Lump`
    entities.

    .. attribute:: pattern

        Reference to the :class:`Pattern` entity.

    .. attribute:: lump

        Reference to the first :class:`Lump` entity

    .. attribute:: wire

        Reference to the first :class:`Wire` entity

    .. attribute:: transform

        Reference to the :class:`Transform` entity (optional)

    .. automethod:: lumps

    .. automethod:: append_lump

Pattern
-------

.. class:: Pattern(AcisEntity)

    Not implemented.

Lump
----


.. class:: Lump(AcisEntity)

    The lump represents a connected entity and there can be multiple lumps in a
    :class:`Body`. Multiple lumps are linked together by the :attr:`next_lump`
    attribute which points to the next lump entity the last lump has a ``NONE_REF``
    as next lump. The :attr:`body` attribute references to the parent :class:`Body`
    entity.

    .. attribute:: next_lump

        Reference to the next :class:`Lump` entity, the last lump references
        :attr:`NONE_REF`.

    .. attribute:: shell

        Reference to the :class:`Shell` entity.

    .. attribute:: body

        Reference to the parent :class:`Body` entity.

    .. automethod:: shells

    .. automethod:: append_shell

Wire
----

.. class:: Wire(AcisEntity)

    Not implemented.

Shell
-----

.. class:: Shell(AcisEntity)

    A shell defines the boundary of a solid object or a void (subtraction object).
    A shell references a list of :class:`Face` and :class:`Wire` entities.
    All linked :class:`Shell` entities are disconnected.

    .. attribute:: next_shell

        Reference to the next :class:`Shell` entity, the last shell references
        :attr:`NONE_REF`.

    .. attribute:: subshell

        Reference to the first :class:`Subshell` entity.

    .. attribute:: face

        Reference to the first :class:`Face` entity.

    .. attribute:: wire

        Reference to the first :class:`Wire` entity.

    .. attribute:: lump

        Reference to the parent :class:`Lump` entity.

    .. automethod:: faces

    .. automethod:: append_face

Subshell
--------

.. class:: Subshell(AcisEntity)

    Not implemented.

Face
----

.. class:: Face(AcisEntity)

    A face is the building block for :class:`Shell` entities.
    The boundary of a face is represented by one or more :class:`Loop` entities.
    The spatial geometry of the face is defined by the :attr:`surface` object,
    which is a bounded or unbounded parametric 3d surface (plane, ellipsoid,
    spline-surface, ...).

    .. attribute:: next_face

        Reference to the next :class:`Face` entity, the last face references
        :attr:`NONE_REF`.

    .. attribute:: loop

        Reference to the first :class:`Loop` entity.

    .. attribute:: shell

        Reference to the parent :class:`Shell` entity.

    .. attribute:: subshell

        Reference to the parent :class:`Subshell` entity.

    .. attribute:: surface

        Reference to the parametric :class:`Surface` geometry.

    .. attribute:: sense

        Boolean value of direction of the face normal with respect to the
        :class:`Surface` entity:

            - ``True``: "reversed" direction of the face normal
            - ``False``: "forward" for same direction of the face normal

    .. attribute:: double_sided

        Boolean value which indicates the sides of the face:

            - ``True``: the face is part of a hollow object and has two sides.
            - ``False``: the face is part of a solid object and has only one
              side which points away from the "material".

    .. attribute:: containment

        Unknown meaning.

        If :attr:`double_sided` is ``True``:

            - ``True`` is "in"
            - ``False`` is "out"

    .. automethod:: loops

    .. automethod:: append_loop

Loop
-----

.. class:: Loop(AcisEntity)

    A loop represents connected coedges which are building the boundaries of
    a :class:`Face`, there can be multiple loops for a single face e.g. faces
    can contain holes.
    The :attr:`coedge` attribute references the first :class:`Coedge` of the
    loop, the additional coedges are linked to this first :class:`Coedge`.
    In closed loops the coedges are organized as a circular list, in open loops
    the last coedge references the :attr:`NONE_REF` entity as :attr:`next_coedge`
    and the first coedge references the :attr:`NONE_REF` as :attr:`prev_coedge`.

    .. attribute:: next_loop

        Reference to the next :class:`Loop` entity, the last loop references
        :attr:`NONE_REF`.

    .. attribute:: coedge

        Reference to the first :class:`Coedge` entity.

    .. attribute:: face

        Reference to the parent :class:`Face` entity.

    .. automethod:: coedges

    .. automethod:: set_coedges

Coedge
------

.. class:: Coedge(AcisEntity)

    The coedges are a double linked list where :attr:`next_coedge` points to the
    next :class:`Coedge` and :attr:`prev_coedge` to the previous :class:`Coedge`.

    The :attr:`partner_coedge` attribute references the first partner
    :class:`Coedge` of an adjacent :class:`Face`, the partner edges are
    organized as a circular list. In a manifold closed surface each
    :class:`Face` is connected to one partner face by an :class:`Coedge`.
    In a non-manifold surface a face can have more than one partner face.


    .. attribute:: next_coedge

        References the next :class:`Coedge`, reference the :attr:`NONE_REF` if
        it is the last coedge in an open :class:`Loop`.

    .. attribute:: prev_coedge

        References the previous :class:`Coedge`, reference the :attr:`NONE_REF`
        if it is the first coedge in an open :class:`Loop`.

    .. attribute:: partner_coedge

        References the partner :class:`Coedge` of an adjacent :class:`Face`
        entity. The partner coedges are organized in a circular list.


    .. attribute:: edge

        References the :class:`Edge` entity.

    .. attribute:: loop

        References the parent :class:`Loop` entity.

    .. attribute:: pcurve

        References the :class:`PCurve` entity.

Edge
----

.. class:: Edge(AcisEntity)

    The :class:`Edge` entity represents the physical edge of an object. Its
    geometry is defined by the bounded portion of a parametric space curve.
    This bounds are stored as object-space :class:`Vertex` entities.

    .. attribute:: start_vertex

        The start :class:`Vertex` of the space-curve in object coordinates, if
        :attr:`NONE_REF` the curve is unbounded in this direction.

    .. attribute:: start_param

        The parametric starting bound for the parametric curve. Evaluating the
        :attr:`curve` for this parameter should return the coordinates of the
        :attr:`start_vertex`.


    .. attribute:: end_vertex

        The end :class:`Vertex` of the space-curve in object coordinates, if
        :attr:`NONE_REF` the curve is unbounded in this direction.

    .. attribute:: end_param

        The parametric end bound for the parametric curve.

    .. attribute:: coedge

        Parent :class:`Coedge` of this edge.

    .. attribute:: curve

        The parametric space-curve which defines this edge. The curve can be the
        :attr:`NULL_REF` while both :class:`Vertex` entities are the same vertex.
        In this case the :class:`Edge` represents an single point like the
        apex of a cone.

    .. attribute:: sense

        Boolean value which indicates the direction of the edge:

            - ``True``: the edge has the "reversed" direction as the underlying curve
            - ``False``: the edge has the same direction as the underlying curve ("forward")

    .. attribute:: convexity

        Unknown meaning, always the string "unknown".

Vertex
------

.. class:: Vertex(AcisEntity)

    Represents a vertex of an :class:`Edge` entity and references a
    :class:`Point` entity.

    .. attribute:: point

        The spatial location in object-space as :class:`Point` entity.

    .. attribute:: edge

        Parent :class:`Edge` of this vertex. The vertex can be referenced by
        multiple edges, anyone of them can be the parent of the vertex.

Surface
--------

.. class:: Surface(AcisEntity)

    Abstract base class for all parametric surfaces.

    The parameterization of any :class:`Surface` maps a 2D rectangle
    (u, v parameters) into the spatial object-space (x, y, z).

    .. attribute:: u_bounds

        Tuple of (start bound, end bound) parameters as two floats which define
        the bounds of the parametric surface in the u-direction, one or both
        values can be :attr:`math.inf` which indicates an unbounded state of
        the surface in that direction.

    .. attribute:: v_bounds

        Tuple of (start bound, end bound) parameters as two floats which define
        the bounds of the parametric surface in the v-direction, one or both
        values can be :attr:`math.inf` which indicates an unbounded state of
        the surface in that direction.

    .. automethod:: evaluate

Plane
-----

.. class:: Plane(Surface)

    Defines a flat plan as parametric surface.

    .. attribute:: origin

        Location vector of the origin of the flat plane as
        :class:`~ezdxf.math.Vec3`.

    .. attribute:: normal

        Normal vector of the plane as :class:`~ezdxf.math.Vec3`.
        Has to be an unit-vector!

    .. attribute:: u_dir

        Direction vector of the plane in u-direction as :class:`~ezdxf.math.Vec3`.
        Has to be an unit-vector!

    .. attribute:: v_dir

        Direction vector of the plane in v-direction as :class:`~ezdxf.math.Vec3`.
        Has to be an unit-vector!

    .. attribute:: reverse_v

       Boolean value which indicates the orientation of the coordinate system:

            - ``True``: left-handed system, the v-direction is reversed and the
              normal vector is :attr:`v_dir` cross :attr:`u_dir`.
            - ``False``: right-handed system and the normal vector is
              :attr:`u_dir` cross :attr:`v_dir`.

Curve
-----

.. class:: Curve(AcisEntity)

    Abstract base class for all parametric curves.

    The parameterization of any :class:`Curve` maps a 1D line (the parameter)
    into the spatial object-space (x, y, z).

    .. attribute:: bounds

        Tuple of (start bound, end bound) parameters as two floats which define
        the bounds of the parametric curve, one or both values can be
        :attr:`math.inf` which indicates an unbounded state of the curve in that
        direction.

    .. automethod:: evaluate


StraightCurve
-------------

.. class:: StraightCurve(Curve)

    Defines a straight line as parametric curve.

    .. attribute:: origin

        Location vector of the origin of the straight line as
        :class:`~ezdxf.math.Vec3`.

    .. attribute:: direction

        Direction vector the straight line as :class:`~ezdxf.math.Vec3`.
        Has to be an unit-vector!

PCurve
------

.. class:: PCurve(AcisEntity)

    Not implemented.

Point
-----

.. class:: Point(AcisEntity)

    Represents a point in the 3D object-space.

    .. attribute:: location

        Cartesian coordinates as :class:`~ezdxf.math.Vec3`.


.. _sat.pdf: https://duckduckgo.com/?q=acis%2Bsat.pdf


--- End of file: acis.rst ---



--- Start of file: addons/acadctb.rst ---

.. _plot_style_files:

Plot Style Files (CTB/STB)
==========================

CTB and STB files store plot styles used by AutoCAD and BricsCAD for printing and plotting.

If the plot style table is attached to a :class:`~ezdxf.layouts.Paperspace` or the :class:`~ezdxf.layouts.Modelspace`,
a change of a plot style affects any object that uses that plot style. CTB files contain color dependent plot
style tables, STB files contain named plot style tables.

.. seealso::

    - `Using plot style tables in AutoCAD`_
    - `AutoCAD Plot Style Table Editor`_
    - `BricsCAD Plot Style Table Editor`_
    - AUTODESK KNOWLEDGE NETWORK: How to `install`_ CTB files in AutoCAD


.. module:: ezdxf.addons.acadctb

.. autofunction:: load

.. autofunction:: new_ctb

.. autofunction:: new_stb

ColorDependentPlotStyles
------------------------

Color dependent plot style table (CTB file), table entries are :class:`PlotStyle` objects.

.. class:: ColorDependentPlotStyles

    .. attribute:: description

        Custom description of plot style file.

    .. attribute:: scale_factor

        Specifies the factor by which to scale non-ISO linetypes and fill patterns.

    .. attribute:: apply_factor

        Specifies whether or not you want to apply the :attr:`scale_factor`.

    .. attribute:: custom_lineweight_display_units

        Set ``1`` for showing lineweight in inch in AutoCAD CTB editor window, but lineweights are always defined in
        millimeters.

    .. attribute:: lineweights

        Lineweights table as :class:`array.array`

    .. automethod:: __getitem__

    .. automethod:: __iter__

    .. automethod:: new_style

    .. automethod:: get_lineweight

    .. automethod:: get_lineweight_index

    .. automethod:: get_table_lineweight

    .. automethod:: set_table_lineweight

    .. method:: save

        Save CTB file as `filename` to the file system.

    .. method:: write(stream: BinaryIO) -> None

        Compress and write CTB file to binary `stream`.

NamedPlotStyles
---------------

Named plot style table (STB file), table entries are :class:`PlotStyle` objects.

.. class:: NamedPlotStyles

    .. attribute:: description

        Custom description of plot style file.

    .. attribute:: scale_factor

        Specifies the factor by which to scale non-ISO linetypes and fill patterns.

    .. attribute:: apply_factor

        Specifies whether or not you want to apply the :attr:`scale_factor`.

    .. attribute:: custom_lineweight_display_units

        Set ``1`` for showing lineweight in inch in AutoCAD CTB editor window, but lineweights are always defined in
        millimeters.

    .. attribute:: lineweights

        Lineweights table as :class:`array.array`

    .. automethod:: __getitem__

    .. automethod:: __delitem__

    .. automethod:: __iter__

    .. automethod:: new_style

    .. automethod:: get_lineweight

    .. automethod:: get_lineweight_index

    .. automethod:: get_table_lineweight

    .. automethod:: set_table_lineweight

    .. method:: save

        Save STB file as `filename` to the file system.

    .. method:: write

        Compress and write STB file to binary `stream`.

PlotStyle
---------

.. class:: PlotStyle

    .. attribute:: index

        Table index (0-based). (int)

    .. autoattribute:: aci

    .. attribute:: description

        Custom description of plot style. (str)

    .. attribute:: physical_pen_number

        Specifies physical plotter pen, valid range from ``1`` to ``32`` or :attr:`AUTOMATIC`. (int)

    .. attribute:: virtual_pen_number

        Only used by non-pen plotters and only if they are configured for virtual pens. valid range from ``1`` to
        ``255`` or :attr:`AUTOMATIC`. (int)

    .. attribute:: screen

        Specifies the color intensity of the plot on the paper, valid range is from ``0`` to ``100``. (int)

        If you select ``100`` the drawing will plotted with its full color intensity. In order for screening to work,
        the :attr:`dithering` option must be active.

    .. attribute:: linetype

        Overrides the entity linetype, default value is :attr:`OBJECT_LINETYPE`. (bool)

    .. attribute:: adaptive_linetype

        ``True`` if a complete linetype pattern is more important than a correct linetype scaling,
        default is ``True``. (bool)

    .. attribute:: linepattern_size

        Line pattern size, default = ``0.5``. (float)

    .. attribute:: lineweight

        Overrides the entity lineWEIGHT, default value is :attr:`OBJECT_LINEWEIGHT`. This is an index into the
        :attr:`UserStyles.lineweights` table. (int)

    .. attribute:: end_style

        Line end cap style, see table below, default is :attr:`END_STYLE_OBJECT` (int)

    .. attribute:: join_style

        Line join style, see table below, default is :attr:`JOIN_STYLE_OBJECT` (int)

    .. attribute:: fill_style

        Line fill style, see table below, default is :attr:`FILL_STYLE_OBJECT` (int)

    .. autoattribute:: dithering

    .. autoattribute:: grayscale

Default Line Weights
--------------------

=== ======
#   [mm]
=== ======
0   0.00
1   0.05
2   0.09
3   0.10
4   0.13
5   0.15
6   0.18
7   0.20
8   0.25
9   0.30
10  0.35
11  0.40
12  0.45
13  0.50
14  0.53
15  0.60
16  0.65
17  0.70
18  0.80
19  0.90
20  1.00
21  1.06
22  1.20
23  1.40
24  1.58
25  2.00
26  2.11
=== ======

Predefined Values
-----------------

.. attribute:: AUTOMATIC

.. attribute:: OBJECT_LINEWEIGHT

.. attribute:: OBJECT_LINETYPE

.. attribute:: OBJECT_COLOR

.. attribute:: OBJECT_COLOR2

Line End Style
--------------

.. image:: gfx/ctb_line_end_style.png
   :align: center

=========================== =================================
END_STYLE_BUTT               ``0``
END_STYLE_SQUARE             ``1``
END_STYLE_ROUND              ``2``
END_STYLE_DIAMOND            ``3``
END_STYLE_OBJECT             ``4``
=========================== =================================

Line Join Style
---------------

.. image:: gfx/ctb_line_join_style.png
   :align: center

=========================== =================================
JOIN_STYLE_MITER             ``0``
JOIN_STYLE_BEVEL             ``1``
JOIN_STYLE_ROUND             ``2``
JOIN_STYLE_DIAMOND           ``3``
JOIN_STYLE_OBJECT            ``5``
=========================== =================================

Fill Style
----------

.. image:: gfx/ctb_line_fill_style.png
   :align: center

=========================== =================================
FILL_STYLE_SOLID            ``64``
FILL_STYLE_CHECKERBOARD     ``65``
FILL_STYLE_CROSSHATCH       ``66``
FILL_STYLE_DIAMONDS         ``67``
FILL_STYLE_HORIZONTAL_BARS  ``68``
FILL_STYLE_SLANT_LEFT       ``69``
FILL_STYLE_SLANT_RIGHT      ``70``
FILL_STYLE_SQUARE_DOTS      ``71``
FILL_STYLE_VERICAL_BARS     ``72``
FILL_STYLE_OBJECT           ``73``
=========================== =================================

Linetypes
---------

.. image:: gfx/ctb_linetypes_1.png
   :align: center

.. image:: gfx/ctb_linetypes_2.png
   :align: center

=================================== ====================
Linetype name                       Value
=================================== ====================
Solid                               0
Dashed                              1
Dotted                              2
Dash Dot                            3
Short Dash                          4
Medium Dash                         5
Long Dash                           6
Short Dash x2                       7
Medium Dash x2                      8
Long Dash x2                        9
Medium Lang Dash                    10
Medium Dash Short Dash Short Dash   11
Long Dash Short Dash                12
Long Dash Dot Dot                   13
Long Dash Dot                       14
Medium Dash Dot Short Dash Dot      15
Sparse Dot                          16
ISO Dash                            17
ISO Dash Space                      18
ISO Long Dash Dot                   19
ISO Long Dash Double Dot            20
ISO Long Dash Triple Dot            21
ISO Dot                             22
ISO Long Dash Short Dash            23
ISO Long Dash Double Short Dash     24
ISO Dash Dot                        25
ISO Double Dash Dot                 26
ISO Dash Double Dot                 27
ISO Double Dash Double Dot          28
ISO Dash Triple Dot                 29
ISO Double Dash Triple Dot          30
Use entity linetype                 31
=================================== ====================



.. _install: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/sfdcarticles/sfdcarticles/How-to-insert-a-CTB-or-STB-file-from-another-end-user-in-your-DWG-file.html

.. _AutoCAD Plot Style Table Editor: https://knowledge.autodesk.com/support/autocad-lt/learn-explore/caas/CloudHelp/cloudhelp/2019/ENU/AutoCAD-LT/files/GUID-56184373-FC19-49A0-9E67-181C4F5C19B7-htm.html

.. _BricsCAD Plot Style Table Editor: https://help.bricsys.com/hc/en-us/articles/360006617933-The-Plot-Style-Table-editor

.. _Using plot style tables in AutoCAD: https://knowledge.autodesk.com/support/autocad-lt/learn-explore/caas/sfdcarticles/sfdcarticles/Use-plot-style-tables.html



--- End of file: addons/acadctb.rst ---



--- Start of file: addons/binpacking.rst ---

.. _bin_packing:

Bin-Packing Add-on
==================

.. module:: ezdxf.addons.binpacking

This add-on is based on the 3D bin packing module `py3dbp`_ hosted on `PyPI`_.
Both sources of this package are MIT licensed like `ezdxf` itself.

The Bin Packing Problem
-----------------------

Quote from the `Wikipedia`_ article:

    The bin packing problem is an optimization problem, in which items of different
    sizes must be packed into a finite number of bins or containers, each of a fixed
    given capacity, in a way that minimizes the number of bins used.

Example
-------

This code replicates the example used by the `py3dbp`_ package:

.. code-block:: python

    from typing import List
    import ezdxf
    from ezdxf import colors
    from ezdxf.addons import binpacking as bp

    SMALL_ENVELOPE = ("small-envelope", 11.5, 6.125, 0.25, 10)
    LARGE_ENVELOPE = ("large-envelope", 15.0, 12.0, 0.75, 15)
    SMALL_BOX = ("small-box", 8.625, 5.375, 1.625, 70.0)
    MEDIUM_BOX = ("medium-box", 11.0, 8.5, 5.5, 70.0)
    MEDIUM_BOX2 = ("medium-box-2", 13.625, 11.875, 3.375, 70.0)
    LARGE_BOX = ("large-box", 12.0, 12.0, 5.5, 70.0)
    LARGE_BOX2 = ("large-box-2", 23.6875, 11.75, 3.0, 70.0)

    ALL_BINS = [
        SMALL_ENVELOPE,
        LARGE_ENVELOPE,
        SMALL_BOX,
        MEDIUM_BOX,
        MEDIUM_BOX2,
        LARGE_BOX,
        LARGE_BOX2,
    ]


    def build_packer():
        packer = bp.Packer()
        packer.add_item("50g [powder 1]", 3.9370, 1.9685, 1.9685, 1)
        packer.add_item("50g [powder 2]", 3.9370, 1.9685, 1.9685, 2)
        packer.add_item("50g [powder 3]", 3.9370, 1.9685, 1.9685, 3)
        packer.add_item("250g [powder 4]", 7.8740, 3.9370, 1.9685, 4)
        packer.add_item("250g [powder 5]", 7.8740, 3.9370, 1.9685, 5)
        packer.add_item("250g [powder 6]", 7.8740, 3.9370, 1.9685, 6)
        packer.add_item("250g [powder 7]", 7.8740, 3.9370, 1.9685, 7)
        packer.add_item("250g [powder 8]", 7.8740, 3.9370, 1.9685, 8)
        packer.add_item("250g [powder 9]", 7.8740, 3.9370, 1.9685, 9)
        return packer


    def make_doc():
        doc = ezdxf.new()
        doc.layers.add("FRAME", color=colors.YELLOW)
        doc.layers.add("ITEMS")
        doc.layers.add("TEXT")
        return doc


    def main(filename):
        bins: List[bp.Bin] = []
        for box in ALL_BINS:
            packer = build_packer()
            packer.add_bin(*box)
            packer.pack(bp.PickStrategy.BIGGER_FIRST)
            bins.extend(packer.bins)
        doc = make_doc()
        bp.export_dxf(doc.modelspace(), bins, offset=(0, 20, 0))
        doc.saveas(filename)


    if __name__ == "__main__":
        main("py3dbp_example.dxf")



.. image:: gfx/binpacking-example.png

.. seealso::

    - `example1`_ script
    - `example2`_ script

Packer Classes
--------------

.. autoclass:: AbstractPacker

    .. attribute:: bins

        List of containers to fill.

    .. attribute:: items

        List of items to pack into the :attr:`bins`.

    .. autoproperty:: is_packed

    .. autoproperty:: unfitted_items

    .. automethod:: __str__

    .. automethod:: append_bin

    .. automethod:: append_item

    .. automethod:: get_fill_ratio

    .. automethod:: get_capacity

    .. automethod:: get_total_weight

    .. automethod:: get_total_volume

    .. automethod:: pack

Packer
~~~~~~

.. autoclass:: Packer

    .. automethod:: add_bin

    .. automethod:: add_item

FlatPacker
~~~~~~~~~~

.. autoclass:: FlatPacker

    .. automethod:: add_bin

    .. automethod:: add_item

Bin Classes
-----------

.. autoclass:: Bin

    .. attribute:: name

        Name of then container as string.

    .. attribute:: width

    .. attribute:: height

    .. attribute:: depth

    .. attribute:: max_weight

    .. autoproperty:: is_empty

    .. automethod:: __str__

    .. automethod:: copy

    .. automethod:: reset

    .. automethod:: put_item

    .. automethod:: get_capacity

    .. automethod:: get_total_weight

    .. automethod:: get_total_volume

    .. automethod:: get_fill_ratio

Box Class
~~~~~~~~~

.. autoclass:: Box

Envelope Class
~~~~~~~~~~~~~~

.. autoclass:: Envelope


Item Class
~~~~~~~~~~

.. autoclass:: Item

    .. attribute:: payload

        Arbitrary Python object.

    .. attribute:: width

    .. attribute:: height

    .. attribute:: depth

    .. attribute:: weight

    .. autoproperty:: bbox

    .. autoproperty:: rotation_type

    .. autoproperty:: position

    .. automethod:: copy

    .. automethod:: __str__

    .. automethod:: get_volume

    .. automethod:: get_dimension

    .. automethod:: get_transformation

FlatItem Class
~~~~~~~~~~~~~~

.. autoclass:: FlatItem

Functions
---------

.. autofunction:: shuffle_pack

Enums
-----

RotationType
~~~~~~~~~~~~

.. autoclass:: RotationType

    .. attribute:: WHD

    .. attribute:: HWD

    .. attribute:: HDW

    .. attribute:: DHW

    .. attribute:: DWH

    .. attribute:: WDH

PickStrategy
~~~~~~~~~~~~

.. autoclass:: PickStrategy

    .. attribute:: BIGGER_FIRST

    .. attribute:: SMALLER_FIRST

    .. attribute:: SHUFFLE


Credits
-------

    - `py3dbp`_ package by Enzo Ruiz Pelaez
    - `bp3d`_ by `gedex` - github repository on which `py3dbp`_ is based, written in Go
    - Optimizing three-dimensional bin packing through simulation (`PDF`_)

.. _py3dbp: https://github.com/enzoruiz/3dbinpacking
.. _bp3d: https://github.com/gedex/bp3d
.. _PyPI: https://pypi.org/project/py3dbp/
.. _Wikipedia: https://en.wikipedia.org/wiki/Bin_packing_problem
.. _example1: https://github.com/mozman/ezdxf/blob/master/examples/addons/binpacking.py
.. _example2: https://github.com/mozman/ezdxf/blob/master/examples/addons/binpacking2.py
.. _PDF: https://github.com/enzoruiz/3dbinpacking/blob/master/erick_dube_507-034.pdf

--- End of file: addons/binpacking.rst ---



--- Start of file: addons/drawing.rst ---

.. module:: ezdxf.addons.drawing

Drawing / Export Add-on
=======================

This add-on provides the functionality to render a DXF document to produce a
rasterized or vector-graphic image which can be saved to a file or viewed
interactively depending on the backend being used.

The module provides two example scripts in the folder ``examples/addons/drawing``
which can be run to save rendered images to files or view an interactive
visualisation.

.. code-block::

    $ ./draw_cad.py --supported_formats
    # will list the file formats supported by the matplotlib backend.
    # Many formats are supported including vector graphics formats
    # such as pdf and svg

    $ ./draw_cad.py <my_file.dxf> --out image.png

    # draw a layout other than the model space
    $ ./draw_cad.py <my_file.dxf> --layout Layout1 --out image.png

    # opens a GUI application to view CAD files
    $ ./cad_viewer.py

.. seealso::

    How-to section for the FAQ about the :ref:`how_to_drawing_addon`.

Design
------

The implementation of the :mod:`drawing` add-on is divided into a frontend and
multiple backends. The frontend handles the translation of DXF features and
properties into simplified structures, which are then processed by the backends.

Common Limitations to all Backends
----------------------------------

- rich text formatting of the MTEXT entity is close to AutoCAD but not pixel perfect
- relative size of POINT entities cannot be replicated exactly
- rendering of ACIS entities is not supported
- no 3D rendering engine, therefore:

    - 3D entities are projected into the xy-plane and 3D text is not supported
    - only top view rendering of the modelspace
    - VIEWPORTS are always rendered as top view
    - no VISUALSTYLE support

- only basic support for:

  - infinite lines (rendered as lines with a finite length)
  - OLE2FRAME entities (rendered as rectangles)
  - vertical text (will render as horizontal text)
  - rendering of additional MTEXT columns may be incorrect

MatplotlibBackend
-----------------

.. autoclass:: ezdxf.addons.drawing.matplotlib.MatplotlibBackend(ax, *, adjust_figure=True, font=FontProperties(), use_text_cache=True)

The :class:`MatplotlibBackend` is used by the :ref:`draw_command` command of the
`ezdxf` launcher.

Example for the usage of the :mod:`Matplotlib` backend:

.. code-block:: Python

    import sys
    import matplotlib.pyplot as plt
    from ezdxf import recover
    from ezdxf.addons.drawing import RenderContext, Frontend
    from ezdxf.addons.drawing.matplotlib import MatplotlibBackend

    # Safe loading procedure (requires ezdxf v0.14):
    try:
        doc, auditor = recover.readfile('your.dxf')
    except IOError:
        print(f'Not a DXF file or a generic I/O error.')
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f'Invalid or corrupted DXF file.')
        sys.exit(2)

    # The auditor.errors attribute stores severe errors,
    # which may raise exceptions when rendering.
    if not auditor.has_errors:
        fig = plt.figure()
        ax = fig.add_axes([0, 0, 1, 1])
        ctx = RenderContext(doc)
        out = MatplotlibBackend(ax)
        Frontend(ctx, out).draw_layout(doc.modelspace(), finalize=True)
        fig.savefig('your.png', dpi=300)

Simplified render workflow but with less control:

.. code-block:: Python

    from ezdxf import recover
    from ezdxf.addons.drawing import matplotlib

    # Exception handling left out for compactness:
    doc, auditor = recover.readfile('your.dxf')
    if not auditor.has_errors:
        matplotlib.qsave(doc.modelspace(), 'your.png')

.. autofunction:: ezdxf.addons.drawing.matplotlib.qsave


PyQtBackend
-----------

.. autoclass:: ezdxf.addons.drawing.pyqt.PyQtBackend(scene=None)

The :class:`PyQtBackend` is used by the :ref:`view_command` command of the
`ezdxf` launcher.

.. seealso::

    The `qtviewer.py`_ module implements the core of a simple DXF viewer and the
    `cad_viewer.py`_ example is a skeleton to show how to launch the
    :class:`CADViewer` class.

Recorder
--------

.. versionadded:: 1.1

This is a special backend which records the output of the :class:`~ezdxf.addons.drawing.frontend.Frontend`
class in compact numpy arrays and these recordings and can be played by a :class:`Player`
instance on one or more backends.
The recorded numpy arrays support measurement of bounding boxes and transformations
which is for some backends a requirement to place the DXF content on size limited pages.

.. autoclass:: ezdxf.addons.drawing.recorder.Recorder

    The class implements the :class:`BackendInterface` but does not record :meth:`enter_entity`,
    :meth:`exit_entity` and :meth:`clear` events.

    .. automethod:: player


.. autoclass:: ezdxf.addons.drawing.recorder.Player

    .. automethod:: bbox

    .. automethod:: copy

    .. automethod:: crop_rect

    .. automethod:: recordings

    .. automethod:: replay

    .. automethod:: transform

.. autoclass:: ezdxf.addons.drawing.recorder.Override


Layout
------

.. versionadded:: 1.1

The :class:`Layout` class builds the page layout and the matrix to transform the DXF
content to page coordinates according to the layout :class:`Settings`.
The DXF coordinate transformation is required for PDF and HPGL/2 which expects the
output coordinates in the first quadrant and SVG which has an inverted y-axis.

The :class:`Layout` class uses following classes and enums for configuration:

- :class:`~ezdxf.addons.drawing.layout.Page` - page definition
- :class:`~ezdxf.addons.drawing.layout.Margins` - page margins definition
- :class:`~ezdxf.addons.drawing.layout.Settings`  - configuration settings
- :class:`~ezdxf.addons.drawing.layout.Units`  - enum for page units

.. autoclass:: ezdxf.addons.drawing.layout.Page

    .. autoproperty:: is_landscape

    .. autoproperty:: is_portrait

    .. automethod:: from_dxf_layout

    .. automethod:: get_margin_rect

    .. automethod:: to_landscape

    .. automethod:: to_portrait

.. autoclass:: ezdxf.addons.drawing.layout.Margins

    .. automethod:: all

    .. automethod:: all2

    .. automethod:: scale


.. autoclass:: ezdxf.addons.drawing.layout.PageAlignment

.. autoclass:: ezdxf.addons.drawing.layout.Settings

.. autoclass:: ezdxf.addons.drawing.layout.Units

SVGBackend
----------

.. versionadded:: 1.1

.. autoclass:: ezdxf.addons.drawing.svg.SVGBackend

    .. automethod:: get_xml_root_element

    .. automethod:: get_string

Usage:

.. code-block:: Python

    from ezdxf.addons.drawing import Frontend, RenderContext
    from ezdxf.addons.drawing import layout, svg

    doc = ezdxf.readfile("your.dxf")
    msp = doc.modelspace()
    backend = svg.SVGBackend()
    Frontend(RenderContext(doc), backend).draw_layout(msp)

    with open("your.svg", "wt") as fp:
        fp.write(backend.get_string(layout.Page(0, 0))

PyMuPdfBackend
--------------

.. versionadded:: 1.1

.. autoclass:: ezdxf.addons.drawing.pymupdf.PyMuPdfBackend

    .. automethod:: get_pdf_bytes

    .. automethod:: get_pixmap_bytes

Usage:

.. code-block:: Python

    import ezdxf
    from ezdxf.addons.drawing import Frontend, RenderContext
    from ezdxf.addons.drawing import layout, pymupdf

    doc = ezdxf.readfile("your.dxf")
    msp = doc.modelspace()
    backend = pymupdf.PyMuPdfBackend()
    Frontend(RenderContext(doc), backend).draw_layout(msp)

    with open("your.pdf", "wb") as fp:
        fp.write(backend.get_pdf_bytes(layout.Page(0, 0))


Load the output of the :class:`PyMuPdfBackend` into the :class:`Image` class of the `Pillow`_
package for further processing or to output additional image formats:

.. code-block:: Python

    import io
    from PIL import Image

    ...  # see above

    # the ppm format is faster to process than png
    fp = io.BytesIO(backend.get_pixmap_bytes(layout.Page(0, 0), fmt="ppm", dpi=300))
    image = Image.open(fp, formats=["ppm"])

PlotterBackend
--------------

.. versionadded:: 1.1

.. autoclass:: ezdxf.addons.drawing.hpgl2.PlotterBackend

    .. automethod:: get_bytes

    .. automethod:: compatible

    .. automethod:: low_quality

    .. automethod:: normal_quality

    .. automethod:: high_quality

Usage:

.. code-block:: Python

    import ezdxf
    from ezdxf.addons.drawing import Frontend, RenderContext
    from ezdxf.addons.drawing import layout, hpgl2

    doc = ezdxf.readfile("your.dxf")
    psp = doc.paperspace("Layout1")
    backend = hpgl2.PlotterBackend()
    Frontend(RenderContext(doc), backend).draw_layout(psp)
    page = layout.Page.from_dxf_layout(psp)

    with open("your.plt", "wb") as fp:
        fp.write(backend.normal_quality(page)

You can check the output by the HPGL/2 viewer::

    ezdxf hpgl your.plt

DXFBackend
----------

.. versionadded:: 1.1

.. autoclass:: ezdxf.addons.drawing.dxf.DXFBackend

.. autoclass:: ezdxf.addons.drawing.dxf.ColorMode

Render a paperspace layout into modelspace:

.. code-block:: Python

    import ezdxf
    from ezdxf.addons.drawing import Frontend, RenderContext
    from ezdxf.addons.drawing import layout, dxf

    doc = ezdxf.readfile("your.dxf")
    layout1 = doc.paperspace("Layout1")
    output_doc = ezdxf.new()
    output_msp = output_doc.modelspace()

    backend = dxf.DXFBackend(output_msp)
    Frontend(RenderContext(doc), backend).draw_layout(layout1)

    output_doc.saveas("layout1_in_modelspace.dxf")

GeoJSONBackend
--------------

.. versionadded:: 1.3.0

.. autoclass:: ezdxf.addons.drawing.json.GeoJSONBackend

CustomJSONBackend
-----------------

.. versionadded:: 1.3.0

.. autoclass:: ezdxf.addons.drawing.json.CustomJSONBackend


Configuration
-------------

Additional options for the drawing add-on can be passed by the `config`
argument of the :class:`Frontend` constructor :meth:`__init__()`. Not every
option will be supported by all backends.

Usage::

    my_config = Configuration(lineweight_scaling=2)

.. autoclass:: ezdxf.addons.drawing.config.Configuration

    .. automethod:: with_changes()

BackgroundPolicy
----------------

.. autoclass:: ezdxf.addons.drawing.config.BackgroundPolicy

ColorPolicy
-----------

.. autoclass:: ezdxf.addons.drawing.config.ColorPolicy

HatchPolicy
-----------

.. autoclass:: ezdxf.addons.drawing.config.HatchPolicy

ImagePolicy
-----------

.. autoclass:: ezdxf.addons.drawing.config.ImagePolicy

LinePolicy
----------

.. autoclass:: ezdxf.addons.drawing.config.LinePolicy

LineweightPolicy
----------------

.. autoclass:: ezdxf.addons.drawing.config.LineweightPolicy

ProxyGraphicPolicy
------------------

.. autoclass:: ezdxf.addons.drawing.config.ProxyGraphicPolicy

TextPolicy
----------

.. autoclass:: ezdxf.addons.drawing.config.TextPolicy

Properties
----------

.. autoclass:: ezdxf.addons.drawing.properties.Properties

    .. attribute:: color

        The actual color value of the DXF entity as "#RRGGBB" or "#RRGGBBAA"
        string. An alpha value of "00" is opaque and "ff" is fully transparent.

    .. attribute:: rgb

        RGB values extract from the :attr:`color` value as tuple of integers.

    .. attribute:: luminance

        Perceived luminance calculated from the :attr:`color` value as float in
        the range [0.0, 1.0].

    .. attribute:: linetype_name

        The actual linetype name as string like "CONTINUOUS"

    .. attribute:: linetype_pattern

        The simplified DXF linetype pattern as tuple of floats, all line
        elements and gaps are values greater than 0.0 and 0.0 represents a
        point. Line or point elements do always alternate with gap elements:
        line-gap-line-gap-point-gap and the pattern always ends with a gap.
        The continuous line is an empty tuple.

    .. attribute:: linetype_scale

        The scaling factor as float to apply to the :attr:`linetype_pattern`.

    .. attribute:: lineweight

        The absolute lineweight to render in mm as float.

    .. attribute:: is_visible

        Visibility flag as bool.

    .. attribute:: layer

        The actual layer name the entity resides on as UPPERCASE string.

    .. attribute:: font

        The :class:`FontFace` used for text rendering or ``None``.

    .. attribute:: filling

        The actual :class:`Filling` properties of the entity or ``None``.

    .. attribute:: units

        The actual drawing units as :class:`~ezdxf.enums.InsertUnits` enum.


LayerProperties
---------------

.. class:: ezdxf.addons.drawing.properties.LayerProperties

    Actual layer properties, inherits from class :class:`Properties`.

    .. attribute:: is_visible

        Modified meaning: whether entities belonging to this layer should be drawn

    .. attribute:: layer

        Modified meaning: stores real layer name (mixed case)

LayoutProperties
----------------

.. class:: ezdxf.addons.drawing.properties.LayoutProperties

    Actual layout properties.

    .. attribute:: name

        Layout name as string

    .. attribute:: units

        Layout units as :class:`~ezdxf.enums.InsertUnits` enum.

    .. autoproperty:: background_color

    .. autoproperty:: default_color

    .. autoproperty:: has_dark_background

    .. automethod:: set_colors

RenderContext
-------------

.. autoclass:: ezdxf.addons.drawing.properties.RenderContext

    .. automethod:: resolve_aci_color

    .. automethod:: resolve_all

    .. automethod:: resolve_color

    .. automethod:: resolve_filling

    .. automethod:: resolve_font

    .. automethod:: resolve_layer

    .. automethod:: resolve_layer_properties

    .. automethod:: resolve_linetype

    .. automethod:: resolve_lineweight

    .. automethod:: resolve_units

    .. automethod:: resolve_visible

    .. automethod:: set_current_layout

    .. automethod:: set_layer_properties_override

The :class:`RenderContext` class can be used isolated from the :mod:`drawing`
add-on to resolve DXF properties.

Frontend
--------

.. autoclass:: ezdxf.addons.drawing.frontend.Frontend(ctx: RenderContext, out: BackendInterface, config: Configuration = Configuration.defaults(), bbox_cache: ezdxf.bbox.Cache = None)

    .. automethod:: log_message

    .. automethod:: skip_entity

    .. automethod:: override_properties

    .. automethod:: push_property_override_function

    .. automethod:: pop_property_override_function

    .. automethod:: draw_layout


BackendInterface
----------------

.. class:: ezdxf.addons.drawing.backend.BackendInterface

    Public interface definition for 2D rendering backends.

    For more information read the source code: `backend.py`_


Backend
--------

.. class:: ezdxf.addons.drawing.backend.Backend

    Abstract base class for concrete backend implementations and
    implements some default features.

    For more information read the source code: `backend.py`_


Details
-------

The rendering is performed in two stages. The frontend traverses the DXF document
structure, converting each encountered entity into primitive drawing commands.
These commands are fed to a backend which implements the interface:
:class:`~ezdxf.addons.drawing.backend.Backend`.

Although the resulting images will not be pixel-perfect with AutoCAD (which was
taken as the ground truth when developing this add-on) great care has been taken
to achieve similar behavior in some areas:

- The algorithm for determining color should match AutoCAD. However, the color
  palette is not stored in the DXF file, so the chosen colors may be different
  to what is expected. The :class:`~ezdxf.addons.drawing.properties.RenderContext`
  class supports passing a plot style table (:term:`CTB`-file) as custom color
  palette but uses the same palette as AutoCAD by default.
- Text rendering is quite accurate, text positioning, alignment and word wrapping
  are very faithful. Differences may occur if a different font from what was
  used by the CAD application but even in that case, for supported backends,
  measurements are taken of the font being used to match text as closely as possible.
- Visibility determination (based on which layers are visible) should match AutoCAD

.. seealso::

    - `draw_cad.py`_ for a simple use of this module
    - `cad_viewer.py`_ for an advanced use of this module
    - :ref:`notes_on_rendering_dxf_content` for additional behaviours documented
      during the development of this add-on.


.. _Triangulation: https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
.. _MatplotlibHatch: https://matplotlib.org/3.2.1/gallery/shapes_and_collections/hatch_demo.html
.. _QtBrushHatch: https://doc.qt.io/qt-5/qbrush.html
.. _cad_viewer.py: https://github.com/mozman/ezdxf/blob/master/examples/addons/drawing/cad_viewer.py
.. _draw_cad.py: https://github.com/mozman/ezdxf/blob/master/examples/addons/drawing/draw_cad.py
.. _qtviewer.py: https://github.com/mozman/ezdxf/blob/master/src/ezdxf/addons/drawing/qtviewer.py
.. _backend.py: https://github.com/mozman/ezdxf/blob/master/src/ezdxf/addons/drawing/backend.py
.. _Pillow: https://pypi.org/project/Pillow/


--- End of file: addons/drawing.rst ---



--- Start of file: addons/dxf2code.rst ---

.. module:: ezdxf.addons.dxf2code

.. _dxf2code:

dxf2code
========

Translate DXF entities and structures into Python source code.

Short example:

.. code-block:: Python

    import ezdxf
    from ezdxf.addons.dxf2code import entities_to_code, block_to_code

    doc = ezdxf.readfile('original.dxf')
    msp = doc.modelspace()
    source = entities_to_code(msp)

    # create source code for a block definition
    block_source = block_to_code(doc.blocks['MyBlock'])

    # merge source code objects
    source.merge(block_source)

    with open('source.py', mode='wt') as f:
        f.write(source.import_str())
        f.write('\n\n')
        f.write(source.code_str())
        f.write('\n')


.. autofunction:: entities_to_code

.. autofunction:: block_to_code

.. autofunction:: table_entries_to_code

.. autofunction:: black

.. class:: Code

    Source code container.

    .. attribute:: code

        Source code line storage, store lines without line ending ``\\n``

    .. attribute:: imports

        source code line storage for global imports, store lines without line ending ``\\n``

    .. attribute:: layers

        Layers used by the generated source code, AutoCAD accepts layer names without a LAYER table entry.

    .. attribute:: linetypes

        Linetypes used by the generated source code, these linetypes require a TABLE entry or AutoCAD will crash.

    .. attribute:: styles

        Text styles used by the generated source code, these text styles require a TABLE entry or AutoCAD will crash.

    .. attribute:: dimstyles

        Dimension styles  used by the generated source code, these dimension styles require a TABLE entry or AutoCAD will crash.

    .. attribute:: blocks

        Blocks used by the generated source code, these blocks require a BLOCK definition in the BLOCKS section or AutoCAD will crash.

    .. automethod:: code_str

    .. automethod:: black_code_str

    .. automethod:: import_str

    .. automethod:: merge

    .. automethod:: add_import

    .. automethod:: add_line

    .. automethod:: add_lines




--- End of file: addons/dxf2code.rst ---



--- Start of file: addons/forms.rst ---

.. module:: ezdxf.addons
    :noindex:

Showcase Forms
==============

MengerSponge
------------

Build a 3D `Menger sponge <https://en.wikipedia.org/wiki/Menger_sponge>`_.

.. autoclass:: MengerSponge

    .. automethod:: MengerSponge.render

    .. automethod:: MengerSponge.cubes

    .. automethod:: MengerSponge.mesh


Menger Sponge ``kind=0``:

.. image:: gfx/menger_sponge_0.png

Menger Sponge ``kind=1``:

.. image:: gfx/menger_sponge_1.png

Menger Sponge ``kind=2``:

.. image:: gfx/menger_sponge_2.png

Jerusalem Cube ``kind=3``:

.. image:: gfx/jerusalem_cube.png


SierpinskyPyramid
-----------------

Build a 3D `Sierpinsky Pyramid <https://en.wikipedia.org/wiki/Sierpinski_triangle>`_.

.. autoclass:: SierpinskyPyramid


    .. automethod:: SierpinskyPyramid.render

    .. automethod:: SierpinskyPyramid.pyramids

    .. automethod:: SierpinskyPyramid.mesh

Sierpinsky Pyramid with triangle base:

.. image:: gfx/sierpinski_pyramid_3.png

Sierpinsky Pyramid with square base:

.. image:: gfx/sierpinski_pyramid_4.png


--- End of file: addons/forms.rst ---



--- Start of file: addons/geo.rst ---

.. _geo_addon:

.. module:: ezdxf.addons.geo

Geo Interface
=============

.. _geo_intended_usage:

Intended Usage
--------------

The intended usage of the :mod:`ezdxf.addons.geo` module is as tool to work with
geospatial data in conjunction with dedicated geospatial applications and
libraries and the module can not and should not replicate their functionality.

The only reimplemented feature is the most common WSG84 EPSG:3395 World
Mercator projection, for everything else use the dedicated packages like:

- `pyproj`_ - Cartographic projections and coordinate transformations library.
- `Shapely`_ - Manipulation and analysis of geometric objects in the Cartesian plane.
- `PyShp`_ - The Python Shapefile Library (PyShp) reads and writes ESRI Shapefiles in pure Python.
- `GeoJSON`_ - GeoJSON interface for Python.
- `GDAL`_ - Tools for programming and manipulating the GDAL Geospatial Data Abstraction Library.
- `Fiona`_ - Fiona is GDALs neat and nimble vector API for Python programmers.
- `QGIS`_ - A free and open source geographic information system.
- and many more ...

This module provides support for the  :code:`__geo_interface__`:
https://gist.github.com/sgillies/2217756

Which is also supported by `Shapely`_, for supported types see the `GeoJSON`_
Standard and examples in `Appendix-A`_.

.. seealso::

    :ref:`tut_geo_addon` for loading GPX data into DXF files with an existing
    geo location reference and exporting DXF entities as GeoJSON data.

Proxy From Mapping
------------------

The :class:`GeoProxy` represents a ``__geo_interface__`` mapping, create a new
proxy by :meth:`GeoProxy.parse` from an external ``__geo_interface__`` mapping.
:meth:`GeoProxy.to_dxf_entities` returns new DXF entities from this mapping.
Returns "Point" as :class:`~ezdxf.entities.Point` entity,  "LineString" as
:class:`~ezdxf.entities.LWPolyline` entity and "Polygon" as
:class:`~ezdxf.entities.Hatch` entity or as separated
:class:`~ezdxf.entities.LWPolyline` entities (or both) and new in v0.16.6 as
:class:`~ezdxf.entities.MPolygon`.
Supports "MultiPoint", "MultiLineString", "MultiPolygon",
"GeometryCollection", "Feature"  and "FeatureCollection".
Add new DXF entities to a layout by the :meth:`Layout.add_entity` method.

Proxy From DXF Entity
---------------------

The :func:`proxy` function or the constructor :meth:`GeoProxy.from_dxf_entities`
creates a new :class:`GeoProxy` object from a single DXF entity or from an
iterable of DXF entities, entities without a corresponding representation will be
approximated.

Supported DXF entities are:

- POINT as "Point"
- LINE as "LineString"
- LWPOLYLINE as "LineString" if open and "Polygon" if closed
- POLYLINE as "LineString" if open and "Polygon" if closed, supports only 2D and
  3D polylines, POLYMESH and POLYFACE are not supported
- SOLID, TRACE, 3DFACE as "Polygon"
- CIRCLE, ARC, ELLIPSE and SPLINE by approximation as "LineString" if open and
  "Polygon" if closed
- HATCH and MPOLYGON as "Polygon", holes are supported

.. warning::

    This module does no extensive validity checks for "Polygon" objects and
    because DXF has different requirements for HATCH boundary paths than the
    `GeoJSON`_ Standard, it is possible to create invalid "Polygon" objects.
    It is recommended to check critical objects by a sophisticated geometry
    library like `Shapely`_.

Module Functions
----------------

.. autofunction:: proxy

.. autofunction:: dxf_entities

.. autofunction:: gfilter

GeoProxy Class
--------------

.. autoclass:: GeoProxy

    .. autoattribute:: __geo_interface__

    .. autoattribute:: geotype

    .. automethod:: parse

    .. automethod:: from_dxf_entities

    .. automethod:: to_dxf_entities

    .. automethod:: copy

    .. automethod:: __iter__

    .. automethod:: wcs_to_crs

    .. automethod:: crs_to_wcs

    .. automethod:: globe_to_map

    .. automethod:: map_to_globe

    .. automethod:: apply

    .. automethod:: filter


Helper Functions
----------------

.. autofunction:: wgs84_4326_to_3395

.. autofunction:: wgs84_3395_to_4326

.. autofunction:: dms2dd

.. autofunction:: dd2dms

.. autofunction:: assign_layers

.. code-block:: Python

    def assign_layers(entity: DXFGraphic, mapping: GeoMapping) -> None:
        properties = mapping.get("properties)
        if properties is None:
            return
        layer = properties.get("layer")
        if layer:
            entity.dxf.layer = layer

Types
-----

.. autoclass:: PolygonConversion

.. autoclass:: GeoMapping

.. autoclass:: PostProcessFunc


.. _Appendix-A: https://tools.ietf.org/html/rfc7946#appendix-A
.. _pyproj: https://pypi.org/project/pyproj/
.. _Shapely: https://pypi.org/project/Shapely/
.. _PyShp: https://pypi.org/project/pyshp/
.. _GeoJSON: https://pypi.org/project/geojson/
.. _GDAL: https://pypi.org/project/gdal/
.. _Fiona: https://pypi.org/project/fiona/
.. _QGIS: https://www.qgis.org/en/site/


--- End of file: addons/geo.rst ---



--- Start of file: addons/gerber_D6673.rst ---

.. _gerber_D6673:

ASTM-D6673-10 Exporter
======================

.. module:: ezdxf.addons.gerber_D6673

This add-on creates special DXF files for use by Gerber Technology applications which
have a low quality DXF parser and cannot parse/ignore BLOCKS which do not contain
data according the ASTM-D6673-10 standard.  The function :func:`export_file` exports
DXF R12 and only DXF R12 files which do not contain the default "$MODEL_SPACE" and
"$PAPER_SPACE" layout block definitions, have an empty HEADER section and no TABLES
section.  These special requirements of the Gerber Technology parser are annoying, but
correspond to the DXF R12 standard.

Autodesk applications maybe complain about invalid BLOCK names such as "Shape 0_M", which
in my opinion are valid, maybe spaces were not allowed in the original R12 version, but
this is just a minor issue and is more a problem of the picky Autodesk DXF parser, which
is otherwise very forgiving for DXF R12 files.

.. code-block:: Python

    import ezdxf
    from ezdxf.addons import gerber_D6673

    doc = ezdxf.new("R12")  # the export function rejects other DXF versions
    msp = doc.modelspace()

    # Create your content according the ASTM-D6673-10 standard
    # Do not use any linetypes or text styles, the TABLES section will not be exported.
    # The ASTM-D6673-10 standard supports only 7-bit ASCII characters.

    gerber_D6673.export_file(doc, "gerber_file.dxf")

.. autofunction:: export_file

.. autofunction:: export_stream



--- End of file: addons/gerber_D6673.rst ---



--- Start of file: addons/hpgl2.rst ---

.. module:: ezdxf.addons.hpgl2.api

HPGL/2 Converter Add-on
=======================

.. versionadded:: 1.1

The :mod:`hpgl2` add-on provides tools to process and convert HPGL/2 plot files.

What are HPGL/2 Plot Files?
---------------------------

The Hewlett-Packard Graphics Language (HPGL) is a vector graphics language originally
developed by Hewlett-Packard in the 1970s. HPGL is widely used for controlling pen
plotters and other output devices, and it has become a de facto standard for
communicating between computers and output devices in the field of computer-aided design
(CAD) and drafting.

HPGL is a command-driven language that consists of a series of commands that control the
movement of the plotter pen, the selection of pens and other output parameters, and the
drawing of geometric shapes such as lines, arcs, circles, and text. The language is
interpreted by the plotter or other output device and translated into physical pen
movements on the drawing surface.

HPGL has evolved over the years, and various extensions have been added to support more
complex graphics operations and to improve compatibility with other graphics languages.
Despite the development of newer graphics languages and file formats, HPGL remains a
widely used format for vector-based graphics, particularly in the engineering and
architectural fields.

The Goal of This Add-on
-----------------------

An HPGL/2 plot file contains all of the data generated by a CAD application that has been
sent to a plotter to print an engineering drawing. In the past, the only way to access
this data was to view it on a plotter or an specialized application, which could be
expensive and impractical for many people. However, this module provides functions and
classes to convert HPGL/2 plot files into modern vector graphic formats such as `PDF`_
and `SVG`_ and of course DXF, allowing the data to be viewed and processed using a wide
range of software tools.

.. Important::

    The Python module PyMuPDF is required for the PDF export: https://pypi.org/project/PyMuPDF/

The :class:`Plotter` class in the :mod:`hpgl2` add-on supports only the most commonly
used commands of HPGL/2. This is because many CAD applications use only a small subset
of HPGL/2 to create their output, typically consisting of polylines and filled polygons.
For more information on the supported commands, please refer to the documentation for
the :class:`Plotter` class.

To use the HPGL2 add-on, the entry point is the :mod:`ezdxf.addons.hpgl2.api` module.
This module contains the public interface of the add-on and should be imported in the
following way:


.. code-block:: Python

    from ezdxf.addons.hpgl2 import api as hpgl2

    with open("hpgl2.plt", "rb") as fp:
        data = fp.read()
    doc = hpgl2.to_dxf(data, color_mode=hpgl2.ColorMode.ACI)
    doc.saveas("hpgl2_as.dxf")


High Level Functions
--------------------

.. autosummary::
    :nosignatures:

    to_dxf
    to_svg
    to_pdf
    to_pixmap

.. autofunction:: to_dxf

.. autofunction:: to_svg

.. autofunction:: to_pdf

.. autofunction:: to_pixmap

.. class:: ColorMode

    The color mode controls how color values are assigned to DXF entities

    .. attribute:: ACI

        Use the pen number as :ref:`ACI` for DXF entities, ignores the RGB color values

    .. attribute:: RGB

        Use the pen number as :ref:`ACI` but also set the RGB color for DXF entities,
        RGB color values have always higher priority than the ACI when displaying DXF
        content.

.. class:: MergeControl

    Merge control enumeration.

    .. attribute:: NONE

        export filled polygons in print order

    .. attribute:: LUMINANCE

        sort filled polygons by luminance

    .. attribute:: AUTO

        guess best order of filled polygons

The Low Level Functions and Classes
-----------------------------------

.. autofunction:: hpgl2_commands

The HPGL/2 commands are often mixed with the Printer Command Language (`PCL`_) and/or the
Raster Transfer Language (`RTL`_) commands in a single plot file.

Some plot files that contain pure HPGL/2 code do not contain the escape sequence
"Enter HPGL/2 mode", without this sequence the HPGL/2 parser cannot recognize the
beginning of the HPGL/2 code. Add the :attr:`ENTER_HPGL2_MODE` sequence in front of the
bytes stream to switch on the HPGL/2 manually, regardless of whether the file is an
HPGL/2 plot file or not, so be careful:

.. code-block:: Python

    commands = hpgl2_commands(hpgl2.ENTER_HPGL2_MODE + data)


.. autoclass:: Interpreter

    .. attribute:: errors

        List of error messages occurred during the interpretation of the HPGL/2 commands.

    .. attribute:: not_implemented_commands

        List of all unsupported/ignored commands from the input stream.

    .. automethod:: run

    .. automethod:: disable_commands

.. autoclass:: Plotter

Recorder
--------

.. autoclass:: Recorder

    .. automethod:: player

    .. automethod:: draw_polyline

    .. automethod:: draw_paths

Player
------

.. autoclass:: Player

    .. automethod:: copy

    .. automethod:: recordings

    .. automethod:: replay

    .. automethod:: bbox

    .. automethod:: transform

    .. automethod:: sort_filled_paths

Properties
----------

.. autoclass:: ezdxf.addons.hpgl2.properties.Properties

    .. attribute:: pen_index

        pen index as int

    .. attribute:: pen_color

        pen color as :class:`RGB` tuple

    .. attribute:: pen_width

        pen width in millimeters (float)

    .. attribute:: fill_type

        :class:`FillType` of filled polygons

    .. attribute:: fill_method

        :class:`FillMethod` of filled polygons

    .. attribute:: fill_hatch_line_angle

        fill hatch line angle in degrees

    .. attribute:: fill_hatch_line_spacing

        fill hatch line distance in plotter units

    .. attribute:: fill_shading_density

        fill shading density in percent from 0 to 100.

    .. automethod:: resolve_pen_color

    .. automethod:: resolve_fill_color

.. autoclass:: ezdxf.addons.hpgl2.properties.FillType

    .. attribute:: NONE

    .. attribute:: SOLID

    .. attribute:: HATCHING

    .. attribute:: CROSS_HATCHING

    .. attribute:: SHADING

.. autoclass:: ezdxf.addons.hpgl2.properties.FillMethod

    .. attribute:: EVEN_ODD

    .. attribute:: NONE_ZERO_WINDING

Exceptions
-----------

.. autoclass:: Hpgl2Error

.. autoclass:: Hpgl2DataNotFound

.. autoclass:: EmptyDrawing


.. _PyMuPDF: https://pypi.org/project/PyMuPDF/
.. _HPGL/2: https://en.wikipedia.org/wiki/HP-GL
.. _PCL: https://en.wikipedia.org/wiki/Printer_Command_Language
.. _RTL: https://en.wikipedia.org/wiki/Hewlett-Packard_Raster_Transfer_Language
.. _SVG: https://en.wikipedia.org/wiki/SVG
.. _PDF: https://en.wikipedia.org/wiki/PDF


--- End of file: addons/hpgl2.rst ---



--- Start of file: addons/importer.rst ---

.. module:: ezdxf.addons.importer

.. _importer:

Importer
========

.. note::

    This module exists for compatibility reasons only and is superseded by the newer and
    more robust core module :mod:`ezdxf.xref`. For information on how to use it, see the
    :ref:`xref_importing_data` section.

    **This add-on is no longer maintained and will not receive updates or bug fixes.**

This add-on is meant to import graphical entities from another DXF drawing and their required table entries like LAYER,
LTYPE or STYLE.

Because of complex extensibility of the DXF format and the lack of sufficient documentation, I decided to remove most
of the possible source drawing dependencies from imported entities, therefore imported entities may not look
the same as the original entities in the source drawing, but at least the geometry should be the same and the DXF file
does not break.

Removed data which could contain source drawing dependencies: Extension Dictionaries, AppData and XDATA.

.. warning::

    DON'T EXPECT PERFECT RESULTS!

The :class:`Importer` supports following data import:

  - entities which are really safe to import: LINE, POINT, CIRCLE, ARC, TEXT, SOLID, TRACE, 3DFACE, SHAPE, POLYLINE,
    ATTRIB, ATTDEF, INSERT, ELLIPSE, MTEXT, LWPOLYLINE, SPLINE, HATCH, MESH, XLINE, RAY, DIMENSION, LEADER, VIEWPORT
  - table and table entry import is restricted to LAYER, LTYPE, STYLE, DIMSTYLE
  - import of BLOCK definitions is supported
  - import of paper space layouts is supported


Import of DXF objects from the OBJECTS section is not supported.

DIMSTYLE override for entities DIMENSION and LEADER is not supported.

Example:

.. code-block:: Python

    import ezdxf
    from ezdxf.addons import Importer

    sdoc = ezdxf.readfile('original.dxf')
    tdoc = ezdxf.new()

    importer = Importer(sdoc, tdoc)

    # import all entities from source modelspace into modelspace of the target drawing
    importer.import_modelspace()

    # import all paperspace layouts from source drawing
    importer.import_paperspace_layouts()

    # import all CIRCLE and LINE entities from source modelspace into an arbitrary target layout.
    # create target layout
    tblock = tdoc.blocks.new('SOURCE_ENTS')
    # query source entities
    ents = sdoc.modelspace().query('CIRCLE LINE')
    # import source entities into target block
    importer.import_entities(ents, tblock)

    # This is ALWAYS the last & required step, without finalizing the target drawing is maybe invalid!
    # This step imports all additional required table entries and block definitions.
    importer.finalize()

    tdoc.saveas('imported.dxf')



.. autoclass:: Importer
    :members:




--- End of file: addons/importer.rst ---



--- Start of file: addons/index.rst ---

.. _add-ons:

.. module:: ezdxf.addons

Add-ons
=======

.. toctree::
    :maxdepth: 1


    drawing
    geo
    importer
    dxf2code
    iterdxf
    odafc
    r12export
    r12writer
    text2path
    mtxpl
    hpgl2
    pycsg
    acadctb
    forms
    binpacking
    meshex
    openscad
    tablepainter
    mtextsurrogate
    gerber_D6673


--- End of file: addons/index.rst ---



--- Start of file: addons/iterdxf.rst ---

.. _iterdxf:

.. module:: ezdxf.addons.iterdxf

iterdxf
=======

This add-on allows iterating over entities of the modelspace of really big (> 5GB) DXF files which do not fit into
memory by only loading one entity at the time. Only ASCII DXF files are supported.

The entities are regular :class:`~ezdxf.entities.DXFGraphic` objects with access to all supported DXF attributes,
this entities can be written to new DXF files created by the :meth:`IterDXF.export` method.
The new :meth:`~ezdxf.layouts.BaseLayout.add_foreign_entity` method allows also to add this entities to
new regular `ezdxf` drawings (except for the INSERT entity), but resources like linetype and style are removed,
only layer will be preserved but only with default attributes like color ``7`` and linetype ``CONTINUOUS``.

The following example shows how to split a big DXF files into several separated DXF files which contains
only LINE, TEXT or POLYLINE entities.

.. code-block:: Python

    from ezdxf.addons import iterdxf

    doc = iterdxf.opendxf('big.dxf')
    line_exporter = doc.export('line.dxf')
    text_exporter = doc.export('text.dxf')
    polyline_exporter = doc.export('polyline.dxf')
    try:
        for entity in doc.modelspace():
            if entity.dxftype() == 'LINE':
                line_exporter.write(entity)
            elif entity.dxftype() == 'TEXT':
                text_exporter.write(entity)
            elif entity.dxftype() == 'POLYLINE':
                polyline_exporter.write(entity)
    finally:
        line_exporter.close()
        text_exporter.close()
        polyline_exporter.close()
        doc.close()

Supported DXF types:


3DFACE, ARC, ATTDEF, ATTRIB, CIRCLE, DIMENSION, ELLIPSE, HATCH, HELIX, IMAGE, INSERT,
LEADER, LINE, LWPOLYLINE, MESH, MLEADER, MLINE, MTEXT, POINT, POLYLINE, RAY, SHAPE,
SOLID, SPLINE, TEXT, TRACE, VERTEX, WIPEOUT, XLINE

Transfer simple entities to another DXF document, this works for some supported entities, except for entities with
strong dependencies to the original document like INSERT look at :meth:`~ezdxf.layouts.BaseLayout.add_foreign_entity`
for all supported types:

.. code-block:: Python

    newdoc = ezdxf.new()
    msp = newdoc.modelspace()
    # line is an entity from a big source file
    msp.add_foreign_entity(line)
    # and so on ...
    msp.add_foreign_entity(lwpolyline)
    msp.add_foreign_entity(mesh)
    msp.add_foreign_entity(polyface)

Transfer MESH and POLYFACE (dxftype for POLYFACE and POLYMESH is POLYLINE!) entities into a new DXF document by
the :class:`MeshTransformer` class:

.. code-block:: Python

    from ezdxf.render import MeshTransformer

    # mesh is MESH from a big source file
    t = MeshTransformer.from_mesh(mesh)
    # create a new MESH entity from MeshTransformer
    t.render(msp)

    # polyface is POLYFACE from a big source file
    t = MeshTransformer.from_polyface(polyface)
    # create a new POLYMESH entity from MeshTransformer
    t.render_polyface(msp)


Another way to import entities from a big source file into new DXF documents is to split the big file into
smaller parts and use the :class:`~ezdxf.addons.importer.Importer` add-on for a more safe entity import.

.. autofunction:: opendxf

.. autofunction:: modelspace

.. autofunction:: single_pass_modelspace

.. class:: IterDXF

    .. automethod:: export

    .. automethod:: modelspace

    .. automethod:: close


.. class:: IterDXFWriter

    .. automethod:: write

    .. automethod:: close



--- End of file: addons/iterdxf.rst ---



--- Start of file: addons/meshex.rst ---

.. module:: ezdxf.addons.meshex

.. _meshex:

MeshExchange
============

The :mod:`ezdxf.addons.meshex` module provides functions to exchange meshes
with other tools in the following file formats:

    - `STL`_: import/export, supports only triangles as faces
    - `OFF`_: import/export, supports ngons as faces and is more compact than STL
    - `OBJ`_: import/export, supports ngons as faces and can contain multiple
      meshes in one file
    - `PLY`_: export only, supports ngons as faces
    - `OpenSCAD`_: export as `polyhedron`_, supports ngons as faces
    - `IFC4`_: export only, supports ngons as faces

The source or target object is always a :class:`~ezdxf.render.MeshBuilder`
instance and therefore the supported features are also limited by this class.
Only vertices and faces are exchanged, colors, textures and explicit face- and
vertex normals are lost.

.. note::

    This add-on is not a replacement for a proper file format
    interface for this data formats! It's just a simple way to
    exchange meshes with other tools like `OpenSCAD`_ or `MeshLab`_.

.. warning::

    The meshes created by the :mod:`ezdxf.addons.pycsg` add-on are usually not
    suitable for export because they often violate the vertex-to-vertex rule:
    A vertex of a face cannot lie on the edge of another face.
    This was one of the reasons to create this addon to get an interface to
    `OpenSCAD`_.

Example for a simple STL to DXF converter:

.. code-block:: Python

    import sys
    import ezdxf
    from ezdxf.addons import meshex

    try:
        mesh = meshex.stl_readfile("your.stl")
    except (meshex.ParsingError, IOError) as e:
        print(str(e))
        sys.exit(1)

    doc = ezdxf.new()
    mesh.render_mesh(doc.modelspace())
    doc.saveas("your.dxf")

.. seealso::

    Example script `meshex_export.py`_ at github.

Import
------

.. autofunction:: stl_readfile

.. autofunction:: stl_loads

.. autofunction:: stl_loadb

.. autofunction:: off_readfile

.. autofunction:: off_loads

.. autofunction:: obj_readfile

.. autofunction:: obj_loads

Export
------

.. autofunction:: stl_dumps

.. autofunction:: stl_dumpb

.. autofunction:: off_dumps

.. autofunction:: obj_dumps

.. autofunction:: ply_dumpb

.. autofunction:: scad_dumps

.. autofunction:: ifc4_dumps

.. autofunction:: export_ifcZIP

.. autoclass:: IfcEntityType

    .. attribute::  POLYGON_FACE_SET

        "SurfaceModel" representation usable for open or closed surfaces.

    .. attribute::  CLOSED_SHELL

        "Brep" representation usable for closed surfaces.

    .. attribute::  OPEN_SHELL

        "SurfaceModel" representation usable for open surfaces.

.. _OpenSCAD: https://openscad.org/index.html
.. _MeshLab: https://www.meshlab.net
.. _STL: https://en.wikipedia.org/wiki/STL_(file_format)
.. _OFF: https://en.wikipedia.org/wiki/OFF_(file_format)
.. _OBJ: https://en.wikipedia.org/wiki/OBJ_(file_format)
.. _PLY: https://en.wikipedia.org/wiki/PLY_(file_format)
.. _polyhedron: https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Primitive_Solids#polyhedron
.. _IFC4: https://en.wikipedia.org/wiki/Industry_Foundation_Classes
.. _meshex_export.py: https://github.com/mozman/ezdxf/blob/master/examples/addons/meshex_export.py

--- End of file: addons/meshex.rst ---



--- Start of file: addons/mtextsurrogate.rst ---

.. _mtext_surrogate:

MTextSurrogate for DXF R12
==========================

.. autoclass:: ezdxf.addons.MTextSurrogate

    .. automethod:: render


--- End of file: addons/mtextsurrogate.rst ---



--- Start of file: addons/mtxpl.rst ---

.. _mtxpl_addon:

MTextExplode
============

This tool is meant to explode MTEXT entities into single line TEXT entities by
replicating the MTEXT layout as close as possible. This tool requires the
optional Matplotlib package to create usable results, nonetheless it also
works without Matplotlib, but then uses a mono-spaced replacement font for
text size measuring which leads to very inaccurate results.

The supported MTEXT features are:

-  changing text color
-  text strokes: underline, overline and strike through
-  changing text size, width and oblique
-  changing font faces
-  stacked text (fractions)
-  multi-column support
-  background color
-  text frame

The tool requires an initialized DXF document io implement all these features
by creating additional text styles. When exploding multiple MTEXT entities,
they can share this new text styles. Call the :meth:`MTextExplode.finalize`
method just once after all MTEXT entities are processed to create the
required text styles, or use :class:`MTextExplode` as context manager by
using the ``with`` statement, see examples below.

There are also many limitations:

-  A 100% accurate result cannot be achieved.
-  Character tracking is not supported.
-  Tabulator stops have only limited support for LEFT and JUSTIFIED aligned
   paragraphs to support numbered and bullet lists. An excessive use of tabs
   will lead to incorrect results.
-  The DISTRIBUTED alignment will be replaced by the JUSTIFIED alignment.
-  Text flow is always "left to right".
-  The line spacing mostly corresponds to the "EXACT" style, except for
   stacked text (fractions), which corresponds more to the "AT LEAST" style,
   but not precisely. This behavior maybe will improve in the future.
-  FIELDS are not evaluated by *ezdxf*.

.. autoclass:: ezdxf.addons.MTextExplode(layout, doc=None, spacing_factor = 1.0)

    .. automethod:: explode

    .. automethod:: finalize

Example to explode all MTEXT entities in the DXF file "mtext.dxf":

.. code-block:: python

    import ezdxf
    from ezdxf.addons import MTextExplode

    doc = ezdxf.readfile("mtext.dxf")
    msp = doc.modelspace()
    with MTextExplode(msp) as xpl:
        for mtext in msp.query("MTEXT"):
            xpl.explode(mtext)
    doc.saveas("xpl_mtext.dxf")

Explode all MTEXT entities into the block "EXPLODE":

.. code-block:: python

    import ezdxf
    from ezdxf.addons import MTextExplode

    doc = ezdxf.readfile("mtext.dxf")
    msp = doc.modelspace()
    blk = doc.blocks.new("EXPLODE")
    with MTextExplode(blk) as xpl:
        for mtext in msp.query("MTEXT"):
            xpl.explode(mtext)
    msp.add_block_ref("EXPLODE", (0, 0))
    doc.saveas("xpl_into_block.dxf")


--- End of file: addons/mtxpl.rst ---



--- Start of file: addons/odafc.rst ---

.. _odafc_addon:

.. module:: ezdxf.addons.odafc

ODA File Converter Support
==========================

Use an installed `ODA File Converter`_ for converting between different versions
of `.dwg`, `.dxb` and `.dxf`.

.. warning::

    Execution of an external application is a big security issue! Especially
    when the path to the executable can be altered.

    To avoid this problem delete the ``ezdxf.addons.odafc.py`` module.

Install ODA File Converter
--------------------------

The `ODA File Converter`_ has to be installed by the user, the application is
available for Windows XP, Windows 7 or later, Mac OS X, and Linux in 32/64-bit
RPM and DEB format.

AppImage Support
----------------

The option "unix_exec_path" defines an executable for Linux
and macOS, this executable overrides the default command ``ODAFileConverter``.
Assign an **absolute** path to the executable to that key and if the
executable is not found the add-on falls back to the ``ODAFileConverter``
command.

The option "unix_exec_path" also adds support for AppImages provided by the
Open Design Alliance. Download the AppImage file and store it in a folder of
your choice (e.g. ``~/Apps``) and make the file executable::

    chmod a+x ~/Apps/ODAFileConverter_QT5_lnxX64_8.3dll_23.9.AppImage

Add the **absolute** path as config option "unix_exec_path" to the
"odafc-addon" section:

.. code-block:: INI

    [odafc-addon]
    win_exec_path = "C:\Program Files\ODA\ODAFileConverter\ODAFileConverter.exe"
    unix_exec_path = "/home/<your user name>/Apps/ODAFileConverter_QT5_lnxX64_8.3dll_23.9.AppImage"

This overrides the default command ``ODAFileConverter`` and if the executable is
not found the add-on falls back to the ``ODAFileConverter`` command.

.. seealso::

    For more information about config files see section: :ref:`global_options`

Suppressed GUI
--------------

On Windows the GUI of the ODA File Converter is suppressed, on Linux you may
have to install the ``xvfb`` package to prevent this, for macOS is no solution
known.

Supported DXF and DWG Versions
------------------------------

ODA File Converter version strings, you can use any of this strings to specify
a version, ``'R..'`` and ``'AC....'`` strings will be automatically mapped to
``'ACAD....'`` strings:

=========== =============== ===========
ODAFC       ezdxf           Version
=========== =============== ===========
ACAD9       not supported   AC1004
ACAD10      not supported   AC1006
ACAD12      R12             AC1009
ACAD13      R13             AC1012
ACAD14      R14             AC1014
ACAD2000    R2000           AC1015
ACAD2004    R2004           AC1018
ACAD2007    R2007           AC1021
ACAD2010    R2010           AC1024
ACAD2013    R2013           AC1027
ACAD2018    R2018           AC1032
=========== =============== ===========

Config
------

On Windows the path to the ``ODAFileConverter.exe`` executable is
stored in the config file (see :mod:`ezdxf.options`) in the "odafc-addon"
section as key "win_exec_path", the default entry is:

.. code-block:: INI

    [odafc-addon]
    win_exec_path = "C:\Program Files\ODA\ODAFileConverter\ODAFileConverter.exe"
    unix_exec_path =

On Linux and macOS the ``ODAFileConverter`` command is located by the
:func:`shutil.which` function but can be overridden since version 1.0 by the key
"linux_exec_path".


Usage
-----

.. code-block:: Python

    from ezdxf.addons import odafc

    # Load a DWG file
    doc = odafc.readfile('my.dwg')

    # Use loaded document like any other ezdxf document
    print(f'Document loaded as DXF version: {doc.dxfversion}.')
    msp = doc.modelspace()
    ...

    # Export document as DWG file for AutoCAD R2018
    odafc.export_dwg(doc, 'my_R2018.dwg', version='R2018')


.. attribute:: win_exec_path

    Path to installed `ODA File Converter` executable on Windows systems,
    default is ``"C:\Program Files\ODA\ODAFileConverter\ODAFileConverter.exe"``.

.. attribute:: unix_exec_path

    Absolute path to a Linux or macOS executable if set, otherwise an empty
    string and the default command ``ODAFileConverter`` is used.

.. autofunction:: is_installed

.. autofunction:: readfile

.. autofunction:: export_dwg

.. autofunction:: convert

.. _ODA File Converter: https://www.opendesign.com/guestfiles/oda_file_converter

--- End of file: addons/odafc.rst ---



--- Start of file: addons/openscad.rst ---

.. module:: ezdxf.addons.openscad

OpenSCAD
========

Interface to the `OpenSCAD`_ application to apply boolean operations to
:class:`~ezdxf.render.MeshBuilder` objects. For more information about boolean
operations read the documentation of `OpenSCAD`_. The `OpenSCAD`_ application is
not bundled with `ezdxf`, you need to install the application yourself.

On Windows the path to the ``openscad.exe`` executable is
stored in the config file (see :mod:`ezdxf.options`) in the "openscad-addon"
section as key "win_exec_path", the default entry is:

.. code-block:: INI

    [openscad-addon]
    win_exec_path = "C:\Program Files\OpenSCAD\openscad.exe"

On Linux and macOS the ``openscad`` command is located by the
:func:`shutil.which` function.

Example:

.. code-block:: Python

    import ezdxf
    from ezdxf.render import forms
    from ezdxf.addons import MengerSponge, openscad

    doc = ezdxf.new()
    msp = doc.modelspace()

    # 1. create the meshes:
    sponge = MengerSponge(level=3).mesh()
    sponge.flip_normals()  # important for OpenSCAD
    sphere = forms.sphere(
        count=32, stacks=16, radius=0.5, quads=True
    ).translate(0.25, 0.25, 1)
    sphere.flip_normals()  # important for OpenSCAD

    # 2. create the script:
    script = openscad.boolean_operation(openscad.DIFFERENCE, sponge, sphere)

    # 3. execute the script by OpenSCAD:
    result = openscad.run(script)

    # 4. render the MESH entity:
    result.render_mesh(msp)

    doc.set_modelspace_vport(6, center=(5, 0))
    doc.saveas("OpenSCAD.dxf")

.. image:: gfx/openscad_menger_minus_sphere.png
    :align: center

Functions
---------

.. autofunction:: run

.. autofunction:: boolean_operation

.. autofunction:: is_installed

Script Class
------------

.. class:: Script

    Helper class to build OpenSCAD scripts. This is a very simple string
    building class and does no checks at all! If you need more advanced
    features to build OpenSCAD scripts look at the packages `solidpython2`_ and
    `openpyscad`_.

    .. automethod:: add

    .. automethod:: add_mirror

    .. automethod:: add_multmatrix

    .. automethod:: add_polyhedron

    .. automethod:: add_polygon

    .. automethod:: add_resize

    .. automethod:: add_rotate

    .. automethod:: add_rotate_about_axis

    .. automethod:: add_scale

    .. automethod:: add_translate

    .. automethod:: get_string

Boolean Operation Constants
---------------------------

.. attribute:: UNION

.. attribute:: DIFFERENCE

.. attribute:: INTERSECTION

openpyscad
----------

This add-on is not a complete wrapper around `OpenSCAD`_, if you need such a
tool look at the `openpyscad`_ or `solidpython2`_ packages at PyPI.

Not sure if the `openpyscad`_ package is still maintained, the last commit at
`github <https://github.com/taxpon/openpyscad>`_ is more than a year old and
did not pass the CI process! (state June 2022)

This code snippet shows how to get the :class:`~ezdxf.render.MeshTransformer`
object from the basic `openpyscad`_ example:

.. code-block:: Python

    from ezdxf.addons import openscad
    import openpyscad as ops

    c1 = ops.Cube([10, 20, 10])
    c2 = ops.Cube([20, 10, 10])

    # dump OpenSCAD script as string:
    script = (c1 + c2).dumps()

    # execute script and load the result as MeshTransformer instance:
    mesh = openscad.run(script)

Create an `openpyscad`_ :class:`Polyhedron` object from an `ezdxf`
:class:`~ezdxf.render.MeshBuilder` object:

.. code-block:: Python

    from ezdxf.render import forms
    import openpyscad as ops

    # create an ezdxf MeshBuilder() object
    sphere = forms.sphere()
    sphere.flip_normals()  # required for OpenSCAD

    # create an openpyscad Polyhedron() object
    polyhedron = ops.Polyhedron(
        points=[list(p) for p in sphere.vertices],  # convert Vec3 objects to lists!
        faces=[list(f) for f in sphere.faces],  # convert face tuples to face lists!
    )

    # create the OpenSCAD script:
    script = polyhedron.dumps()


The type conversion is needed to get valid `OpenSCAD`_ code from `openpyscad`_!

solidpython2
------------

The `solidpython2`_ package seems to be better maintained than the `openpyscad`_ package,
but this is just an opinion based on newer commits at github
(`link <https://github.com/jeff-dh/SolidPython>`_) for the `solidpython2`_ package.

Same example for `solidpython2`_:

.. code-block:: Python

    from ezdxf.addons import openscad
    from solid2 import cube, scad_render

    c1 = cube([10, 20, 10])
    c2 = cube([20, 10, 10])

    # dump OpenSCAD script as string:
    script = scad_render(c1 + c2)

    # execute script and load the result as MeshTransformer instance:
    mesh = openscad.run(script)

Create a `solidpython2`_ :class:`polyhedron` object from an `ezdxf`
:class:`~ezdxf.render.MeshBuilder` object:

.. code-block:: Python

    from ezdxf.render import forms
    from solid2 import polyhedron, scad_render

    # create an ezdxf MeshBuilder() object
    sphere = forms.sphere()
    sphere.flip_normals()  # required for OpenSCAD

    # create a solidpython2 polyhedron() object
    ph = polyhedron(
        points=[v.xyz for v in sphere.vertices],  # convert Vec3 objects to tuples!
        faces=sphere.faces,  # types are compatible
    )

    # create the OpenSCAD script:
    script = scad_render(ph)


.. _OpenSCAD: https://openscad.org
.. _openpyscad: https://pypi.org/project/openpyscad/
.. _solidpython2:  https://pypi.org/project/solidpython2/


--- End of file: addons/openscad.rst ---



--- Start of file: addons/pycsg.rst ---

.. automodule:: ezdxf.addons.pycsg

.. _pycsg2:

PyCSG
=====

Constructive Solid Geometry (CSG) is a modeling technique that uses Boolean
operations like union and intersection to combine 3D solids. This library
implements CSG operations on meshes elegantly and concisely using BSP trees,
and is meant to serve as an easily understandable implementation of the
algorithm. All edge cases involving overlapping coplanar polygons in both
solids are correctly handled.

Example for usage:

.. code-block:: Python

    import ezdxf
    from ezdxf.render.forms import cube, cylinder_2p
    from ezdxf.addons.pycsg import CSG

    # create new DXF document
    doc = ezdxf.new()
    msp = doc.modelspace()

    # create same geometric primitives as MeshTransformer() objects
    cube1 = cube()
    cylinder1 = cylinder_2p(count=32, base_center=(0, -1, 0), top_center=(0, 1, 0), radius=.25)

    # build solid union
    union = CSG(cube1) + CSG(cylinder1)
    # convert to mesh and render mesh to modelspace
    union.mesh().render_mesh(msp, dxfattribs={'color': 1})

    # build solid difference
    difference = CSG(cube1) - CSG(cylinder1)
    # convert to mesh, translate mesh and render mesh to modelspace
    difference.mesh().translate(1.5).render_mesh(msp, dxfattribs={'color': 3})

    # build solid intersection
    intersection = CSG(cube1) * CSG(cylinder1)
    # convert to mesh, translate mesh and render mesh to modelspace
    intersection.mesh().translate(2.75).render_mesh(msp, dxfattribs={'color': 5})

    doc.saveas('csg.dxf')

.. image:: gfx/pycsg01.png
    :alt: Cube vs Cylinder

This CSG kernel supports only meshes as :class:`~ezdxf.render.MeshBuilder` objects, which can be created from and
converted to DXF :class:`~ezdxf.entities.Mesh` entities.

This CSG kernel is **not** compatible with ACIS objects like :class:`~ezdxf.entities.Solid3d`,
:class:`~ezdxf.entities.Body`, :class:`~ezdxf.entities.Surface` or :class:`~ezdxf.entities.Region`.

.. note::

    This is a pure Python implementation, don't expect great performance and the implementation is based on an
    unbalanced `BSP tree`_, so in the case of :class:`RecursionError`, increase the recursion limit:

    .. code-block:: Python

         import sys

         actual_limit = sys.getrecursionlimit()
         # default is 1000, increasing too much may cause a seg fault
         sys.setrecursionlimit(10000)

         ...  # do the CSG stuff

         sys.setrecursionlimit(actual_limit)

CSG works also with spheres, but with really bad runtime behavior and most likely :class:`RecursionError`
exceptions, and use `quadrilaterals`_ as body faces to reduce face count by setting
argument `quads` to ``True``.

.. code-block:: Python

    import ezdxf

    from ezdxf.render.forms import sphere, cube
    from ezdxf.addons.pycsg import CSG

    doc = ezdxf.new()
    doc.set_modelspace_vport(6, center=(5, 0))
    msp = doc.modelspace()

    cube1 = cube().translate(-.5, -.5, -.5)
    sphere1 = sphere(count=32, stacks=16, radius=.5, quads=True)

    union = (CSG(cube1) + CSG(sphere1)).mesh()
    union.render_mesh(msp, dxfattribs={'color': 1})

    subtract = (CSG(cube1) - CSG(sphere1)).mesh().translate(2.5)
    subtract.render_mesh(msp, dxfattribs={'color': 3})

    intersection = (CSG(cube1) * CSG(sphere1)).mesh().translate(4)
    intersection.render_mesh(msp, dxfattribs={'color': 5})

.. image:: gfx/pycsg02.png
    :alt: Cube vs Sphere

Hard Core CSG - Menger Sponge Level 3 vs Sphere

Required runtime on an old Xeon E5-1620 Workstation @ 3.60GHz (2020), with default 
recursion limit of 1000 on Windows 10:

    - CPython 3.8.1 64bit: ~60 seconds,
    - PyPy [PyPy 7.2.0] 32bit: ~6 seconds, and using ``__slots__`` reduced runtime 
      below 5 seconds, yes - PyPy is worth a look for long running scripts!

Updated runtime in 2024 on an i7-12700K @ 3.60GHz (peak ~5GHz), Windows 11:

    - CPython 3.11.6 64bit: ~3.4 seconds
    - PyPy 3.9.18 [PyPy 7.3.13] 64bit: ~1.5 seconds

.. code-block:: Python

    from ezdxf.render.forms import sphere
    from ezdxf.addons import MengerSponge
    from ezdxf.addons.pycsg import CSG

    doc = ezdxf.new()
    doc.layers.new('sponge', dxfattribs={'color': 5})
    doc.layers.new('sphere', dxfattribs={'color': 6})

    doc.set_modelspace_vport(6, center=(5, 0))
    msp = doc.modelspace()

    sponge1 = MengerSponge(level=3).mesh()
    sphere1 = sphere(count=32, stacks=16, radius=.5, quads=True).translate(.25, .25, 1)

    subtract = (CSG(sponge1, meshid=1) - CSG(sphere1, meshid=2))
    # get mesh result by id
    subtract.mesh(1).render_mesh(msp, dxfattribs={'layer': 'sponge'})
    subtract.mesh(2).render_mesh(msp, dxfattribs={'layer': 'sphere'})

.. image:: gfx/menger_sponge_vs_sphere_level_3.png
    :alt: Menger Sponge vs Sphere

CSG Class
---------

.. autoclass:: CSG(mesh: MeshBuilder, meshid: int = 0)

    .. automethod:: mesh

    .. automethod:: union

    .. method:: __add__

       .. code-block:: Python

            union = A + B

    .. automethod:: subtract

    .. method:: __sub__

       .. code-block:: Python

            difference = A - B

    .. automethod:: intersect

    .. method:: __mul__

       .. code-block:: Python

            intersection = A * B

    .. automethod:: inverse

License
-------

- Original implementation `csg.js`_, Copyright (c) 2011 Evan Wallace (http://madebyevan.com/), under the MIT license.
- Python port `pycsg`_, Copyright (c) 2012 Tim Knip (http://www.floorplanner.com), under the MIT license.
- Additions by Alex Pletzer (Pennsylvania State University)
- Integration as `ezdxf` add-on, Copyright (c) 2020, Manfred Moitzi, MIT License.

.. _csg.js: https://github.com/evanw/csg.js
.. _pycsg: https://github.com/timknip/pycsg
.. _BSP tree: https://en.wikipedia.org/wiki/Binary_space_partitioning
.. _quadrilaterals: https://en.wikipedia.org/wiki/Quadrilateral


--- End of file: addons/pycsg.rst ---



--- Start of file: addons/r12export.rst ---

.. _r12export_addon:

.. module:: ezdxf.addons.r12export

R12 Export
==========

.. versionadded:: 1.1

This module exports any DXF file as a simple DXF R12 file. Many complex entities will be
converted into DXF primitives.  This exporter is intended for creating a simple file
format as an input format for other software such as laser cutters. In order to get a
file that can be edited well in a CAD application, the results of the ODA file converter
are much better.

Usage
-----

.. code-block:: Python

    import ezdxf
    from ezdxf.addons import r12export

    doc = ezdxf.readfile("any.dxf")
    r12export.saveas(doc, "r12.dxf")

Converted Entity Types
----------------------

=============== ===
LWPOLYLINE      translated to POLYLINE
MESH            translated to POLYLINE (PolyfaceMesh)
SPLINE          flattened to POLYLINE
ELLIPSE         flattened to POLYLINE
MTEXT           exploded into DXF primitives
LEADER          exploded into DXF primitives
MLEADER         exploded into DXF primitives
MULTILEADER     exploded into DXF primitives
MLINE           exploded into DXF primitives
HATCH           exploded into DXF primitives
MPOLYGON        exploded into DXF primitives
ACAD_TABLE      export of pre-rendered BLOCK content
=============== ===

For proxy- or unknown entities the available proxy graphic will be exported as DXF
primitives.

Limitations
-----------

- Explosion of MTEXT into DXF primitives is not perfect
- Pattern rendering for complex HATCH entities has issues
- Solid fill rendering for complex HATCH entities has issues

ODA File Converter
------------------

The advantage of the :mod:`~ezdxf.addons.r12export` module is that the ODA file converter
isn't needed, but the ODA file converter will produce a much better result:

.. code-block:: Python

    from ezdxf.addons import odafc

    odafc.convert("any.dxf", "r12.dxf", version="R12")


Functions
---------

.. autosummary::
    :nosignatures:

    write
    saveas
    convert

.. autofunction:: write

.. autofunction:: saveas

.. autofunction:: convert


--- End of file: addons/r12export.rst ---



--- Start of file: addons/r12writer.rst ---

.. _r12writer:

r12writer
=========

.. module:: ezdxf.addons.r12writer

The fast file/stream writer creates simple DXF R12 drawings with just an ENTITIES section. The HEADER, TABLES and BLOCKS
sections are not present except FIXED-TABLES are written. Only LINE, CIRCLE, ARC, TEXT, POINT, SOLID, 3DFACE and POLYLINE
entities are supported. FIXED-TABLES is a predefined TABLES section, which will be written, if the init argument
`fixed_tables` of :class:`R12FastStreamWriter` is ``True``.


The :class:`R12FastStreamWriter` writes the DXF entities as strings direct to the stream without creating an
in-memory drawing and therefore the processing is very fast.

Because of the lack of a BLOCKS section, BLOCK/INSERT can not be used. Layers can be used, but this layers have a
default setting color = ``7`` (black/white) and linetype = ``'Continuous'``. If writing the FIXED-TABLES,
some predefined text styles and line types are available, else text style is always ``'STANDARD'`` and line type
is always ``'ByLayer'``.

If using FIXED-TABLES, following predefined line types are available:

- CONTINUOUS
- CENTER ``____ _ ____ _ ____ _ ____ _ ____ _ ____``
- CENTERX2 ``________  __  ________  __  ________``
- CENTER2 ``____ _ ____ _ ____ _ ____ _ ____``
- DASHED ``__ __ __ __ __ __ __ __ __ __ __ __ __ _``
- DASHEDX2 ``____  ____  ____  ____  ____  ____``
- DASHED2 ``_ _ _ _ _ _ _ _ _ _ _ _ _ _``
- PHANTOM ``______  __  __  ______  __  __  ______``
- PHANTOMX2 ``____________    ____    ____    ____________``
- PHANTOM2 ``___ _ _ ___ _ _ ___ _ _ ___ _ _ ___``
- DASHDOT ``__ . __ . __ . __ . __ . __ . __ . __``
- DASHDOTX2 ``____  .  ____  .  ____  .  ____``
- DASHDOT2 ``_ . _ . _ . _ . _ . _ . _ . _``
- DOT ``.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .``
- DOTX2 ``.    .    .    .    .    .    .    .``
- DOT2 ``. . . . . . . . . . . . . . . . . . .``
- DIVIDE ``__ . . __ . . __ . . __ . . __ . . __``
- DIVIDEX2 ``____  . .  ____  . .  ____  . .  ____``
- DIVIDE2 ``_ . _ . _ . _ . _ . _ . _ . _``

If using FIXED-TABLES, following predefined text styles are available:

- OpenSans
- OpenSansCondensed-Light

Tutorial
--------

A simple example with different DXF entities::

    from random import random
    from ezdxf.addons import r12writer

    with r12writer("quick_and_dirty_dxf_r12.dxf") as dxf:
        dxf.add_line((0, 0), (17, 23))
        dxf.add_circle((0, 0), radius=2)
        dxf.add_arc((0, 0), radius=3, start=0, end=175)
        dxf.add_solid([(0, 0), (1, 0), (0, 1), (1, 1)])
        dxf.add_point((1.5, 1.5))

        # 2d polyline, new in v0.12
        dxf.add_polyline_2d([(5, 5), (7, 3), (7, 6)])

        # 2d polyline with bulge value, new in v0.12
        dxf.add_polyline_2d([(5, 5), (7, 3, 0.5), (7, 6)], format='xyb')

        # 3d polyline only, changed in v0.12
        dxf.add_polyline([(4, 3, 2), (8, 5, 0), (2, 4, 9)])

        dxf.add_text("test the text entity", align="MIDDLE_CENTER")

A simple example of writing really many entities in a short time::

    from random import random
    from ezdxf.addons import r12writer

    MAX_X_COORD = 1000.0
    MAX_Y_COORD = 1000.0
    CIRCLE_COUNT = 1000000

    with r12writer("many_circles.dxf") as dxf:
        for i in range(CIRCLE_COUNT):
            dxf.add_circle((MAX_X_COORD*random(), MAX_Y_COORD*random()), radius=2)


Show all available line types::

    import ezdxf

    LINETYPES = [
        'CONTINUOUS', 'CENTER', 'CENTERX2', 'CENTER2',
        'DASHED', 'DASHEDX2', 'DASHED2', 'PHANTOM', 'PHANTOMX2',
        'PHANTOM2', 'DASHDOT', 'DASHDOTX2', 'DASHDOT2', 'DOT',
        'DOTX2', 'DOT2', 'DIVIDE', 'DIVIDEX2', 'DIVIDE2',
    ]

    with r12writer('r12_linetypes.dxf', fixed_tables=True) as dxf:
        for n, ltype in enumerate(LINETYPES):
            dxf.add_line((0, n), (10, n), linetype=ltype)
            dxf.add_text(ltype, (0, n+0.1), height=0.25, style='OpenSansCondensed-Light')

Reference
---------

.. autofunction:: r12writer(stream: Union[TextIO, BinaryIO, str], fixed_tables = False, fmt = 'asc') -> R12FastStreamWriter

.. autoclass:: R12FastStreamWriter

    .. automethod:: close

    .. automethod:: add_line

    .. automethod:: add_circle

    .. automethod:: add_arc

    .. automethod:: add_point

    .. automethod:: add_3dface

    .. automethod:: add_solid

    .. automethod:: add_polyline_2d

    .. automethod:: add_polyline

    .. automethod:: add_polyface

    .. automethod:: add_polymesh

    .. automethod:: add_text



--- End of file: addons/r12writer.rst ---



--- Start of file: addons/tablepainter.rst ---

.. _table_painter:

.. module:: ezdxf.addons.tablepainter

TablePainter
============

This is an add-on for drawing tables build from DXF primitives.

This add-on was created for porting :mod:`dxfwrite` projects to :mod:`ezdxf` and
was not officially documented for :mod:`ezdxf` versions prior the 1.0 release.
For the 1.0 version of :mod:`ezdxf`, this class was added as an officially
documented add-on because full support for the ACAD_TABLE entity
is very unlikely due to the enormous complexity for both the entity itself,
and for the required infrastructure and also the lack of a usable
documentation to implement all that features.

.. important::

    This add-on is not related to the ACAD_TABLE entity at all and and does not
    create ACAD_TABLE entities!


The table cells can contain multi-line text or BLOCK references. You can
create your own cell types by extending the :class:`CustomCell` class.
The cells are addressed by zero-based row and column indices. A table cell can
span over multiple columns and/or rows.

A :class:`TextCell` can contain multi-line text with an arbitrary rotation angle
or letters stacked from top to bottom. The :class:`~ezdxf.addons.MTextSurrogate`
add-on is used to create multi-line text compatible to DXF version R12.

A :class:`BlockCell` contains block references (INSERT entities), if the block
definition contains attribute definitions as ATTDEF entities, these attributes
can be added automatically to the block reference as ATTRIB entities.

.. note::

    The DXF format does not support clipping boxes ot paths, therefore the
    render method of any cell can render beyond the borders of the cell!

Tutorial
--------

Set up a new DXF document:

.. code-block:: Python

    import ezdxf
    from ezdxf.enums import MTextEntityAlignment
    from ezdxf.addons import TablePainter

    doc = ezdxf.new("R2000")  # required for lineweight support
    doc.header["$LWDISPLAY"] = 1  # show lineweights
    doc.styles.add("HEAD", font="OpenSans-ExtraBold.ttf")
    doc.styles.add("CELL", font="OpenSans-Regular.ttf")

Create a new :class:`TablePainter` object with four rows and four columns, the
insert location is the default render location but can be overriden in the
:meth:`render` method:

.. code-block:: Python

    table = TablePainter(
        insert=(0, 0), nrows=4, ncols=4, cell_width=6.0, cell_height=2.0
    )

Create a new :class:`CellStyle` object for the table-header called "head":

.. code-block:: Python

    table.new_cell_style(
        "head",
        text_style="HEAD",
        text_color=ezdxf.colors.BLUE,
        char_height=0.7,
        bg_color=ezdxf.colors.LIGHT_GRAY,
        align=MTextEntityAlignment.MIDDLE_CENTER,
    )

Redefine the default :class:`CellStyle` for the content cells:

.. code-block:: Python

    # reset default cell style
    default_style = table.get_cell_style("default")
    default_style.text_style = "CELL"
    default_style.char_height = 0.5
    default_style.align = MTextEntityAlignment.BOTTOM_LEFT

Set the table-header content:

.. code-block:: Python

    for col in range(4):
        table.text_cell(0, col, f"Head[{col}]", style="head")

Set the cell content:

.. code-block:: Python

    for row in range(1, 4):
        for col in range(4):
            # cell style is "default"
            table.text_cell(row, col, f"Cell[{row}, {col}]")

Add a red frame around the table-header:

.. code-block:: Python

    # new cell style is required
    red_frame = table.new_cell_style("red-frame")
    red_borderline = table.new_border_style(color=ezdxf.colors.RED, lineweight=35)
    # set the red borderline style for all cell borders
    red_frame.set_border_style(red_borderline)
    # create the frame object
    table.frame(0, 0, 4, style="red-frame")

Render the table into the modelspace and export the DXF file:

.. code-block:: Python

    # render the table, shifting the left-bottom of the table to the origin:
    table.render(doc.modelspace(), insert=(0, table.table_height))

    th = table.table_height
    tw = table.table_width
    doc.set_modelspace_vport(height=th * 1.5, center=(tw/2, th/2))
    doc.saveas("table_tutorial.dxf")

.. image:: gfx/table_painter_addon.png
    :align: center

.. seealso::

    - Example script: `table_painter_addon.py`_

TablePainter
------------

.. autoclass:: TablePainter

    .. attribute:: bg_layer_name: str

        background layer name, layer for the background SOLID entities,
        default is "TABLEBACKGROUND"

    .. attribute:: fg_layer_name: str

        foreground layer name, layer for the cell content, default is
        "TABLECONTENT"

    .. attribute:: grid_layer_name: str

        table grid layer name, layer for the cell border lines, default is
        "TABLEGRID"

    .. autoproperty:: table_width

    .. autoproperty:: table_height

    .. automethod:: set_col_width

    .. automethod:: set_row_height

    .. automethod:: text_cell

    .. automethod:: block_cell

    .. automethod:: set_cell

    .. automethod:: get_cell

    .. automethod:: new_cell_style

    .. automethod:: get_cell_style

    .. automethod:: new_border_style

    .. automethod:: frame

    .. automethod:: render

Cell
----

.. class:: Cell

    Abstract base class for table cells.


TextCell
--------

.. class:: TextCell

    Implements a cell type containing a multi-line text. Uses the
    :class:`~ezdxf.addons.MTextSurrogate` add-on to render the multi-line
    text, therefore the content of these cells is compatible to DXF R12.

    .. important::

        Use the factory method :meth:`TablePainter.text_cell` to
        instantiate text cells.

BlockCell
---------

.. autoclass:: BlockCell

    Implements a cell type containing a block reference.

    .. important::

        Use the factory method :meth:`TablePainter.block_cell` to
        instantiate block cells.

CustomCell
----------

.. class:: CustomCell

    Base class to implement custom cells. Overwrite the :meth:`render` method
    to render the cell. The custom cell type has to be instantiated by the
    user and added to the table by the :meth:`TablePainter.set_cell` method.

    .. automethod:: render

        The render space is defined by the argument `coords` which is a tuple of
        4 float values in the order: left, right, top, bottom. These values are
        layout coordinates in drawing units.
        The DXF format does not support clipping boxes, therefore the render method
        can render beyond these borders!

CellStyle
---------

.. autoclass:: CellStyle

    .. attribute:: text_style: str

        :class:`~ezdxf.entities.Textstyle` name as string, ignored by :class:`BlockCell`

    .. attribute:: char_height: float

        text height in drawing units, ignored by :class:`BlockCell`

    .. attribute:: line_spacing: float

        line spacing in percent, distance of line base points = :attr:`char_height`
        * :attr:`line_spacing`, ignored by :class:`BlockCell`

    .. attribute:: scale_x: float

        text stretching factor (width factor) or block reference x-scaling factor

    .. attribute:: scale_y: float

        block reference y-scaling factor, ignored by :class:`TextCell`

    .. attribute:: text_color: int

        :ref:`ACI` for text, ignored by :class:`BlockCell`

    .. attribute:: rotation: float

        text or block rotation in degrees

    .. attribute:: stacked: bool

        Stacks letters of :class:`TextCell` instances from top to bottom without
        rotating the characters if ``True``, ignored by :class:`BlockCell`

    .. attribute:: align: MTextEntityAlignment

        text and block alignment, see :class:`ezdxf.enums.MTextEntityAlignment`

    .. attribute:: margin_x: float

        left and right cell margin in drawing units

    .. attribute:: margin_y: float

        top and bottom cell margin in drawing units

    .. attribute:: bg_color: int

         cell background color as :ref:`ACI`, ignored by :class:`BlockCell`

    .. attribute:: left: BorderStyle

        left cell border style

    .. attribute:: top: BorderStyle

        top cell border style

    .. attribute:: right: BorderStyle

        right cell border style

    .. attribute:: bottom: BorderStyle

        bottom cell border style

    .. automethod:: set_border_status

    .. automethod:: set_border_style

    .. automethod:: get_default_border_style

BorderStyle
-----------

.. autoclass:: BorderStyle

    .. attribute:: status: bool

        border status, ``True``  for visible, ``False`` for hidden

    .. attribute:: color: int

        :ref:`ACI`

    .. attribute:: linetype: str

        linetype name as string, default is "BYLAYER"

    .. attribute:: lineweight: int

        lineweight as int, default is by layer

    .. attribute:: priority: int

        drawing priority, higher values cover lower values

.. _table_painter_addon.py: https://github.com/mozman/ezdxf/blob/master/examples/addons/table_painter_addon.py

--- End of file: addons/tablepainter.rst ---



--- Start of file: addons/text2path.rst ---

.. module:: ezdxf.addons.text2path

text2path
=========

Tools to convert text strings and text based DXF entities into outer- and inner
linear paths as :class:`~ezdxf.path.Path` objects. At the moment only the TEXT and the
ATTRIB entity can be converted into paths and hatches.

.. versionadded:: 1.1

    Text rendering is done by the `fontTools`_ package, which is a hard dependency of
    `ezdxf`. Support for stroke fonts, these are the basic vector fonts included in CAD
    applications, like .shx, .shp or .lff fonts was added but these fonts cannot be
    rendered as HATCH entities.

    The required font files are not included with `ezdxf` as they are copyrighted or,
    in the case of the LibreCAD font format, licensed under the "GPL v2 and later".
    Set the paths to such stroke fonts in the config file, see option
    :attr:`ezdxf.options.support_dirs`:

    .. code-block:: ini

        [core]
        support_dirs =
            "C:\Program Files\Bricsys\BricsCAD V23 en_US\Fonts",
            ~/shx_fonts,
            ~/shp_fonts,
            ~/lff_fonts,




Don't expect a 100% match compared to CAD applications but the results with `fontTools`
are better than the previous `Matplotlib` renderings.

Text Alignments
---------------

The text alignments are enums of type :class:`ezdxf.enums.TextEntityAlignment`

============   =============== ================= =====
Vertical       Left            Center            Right
============   =============== ================= =====
Top            TOP_LEFT        TOP_CENTER        TOP_RIGHT
Middle         MIDDLE_LEFT     MIDDLE_CENTER     MIDDLE_RIGHT
Bottom         BOTTOM_LEFT     BOTTOM_CENTER     BOTTOM_RIGHT
Baseline       LEFT            CENTER            RIGHT
============   =============== ================= =====

The vertical middle alignments (MIDDLE_XXX), center the text
vertically in the middle of the uppercase letter "X" (cap height).

Special alignments, where the horizontal alignment is always in the center of
the text:

- ALIGNED: text is scaled to match the given `length`, scales x- and
  y-direction by the same factor.
- FIT: text is scaled to match the given `length`, but scales only in
  x-direction.
- MIDDLE: insertion point is the center of the total height (cap height +
  descender height) without scaling, the `length` argument is ignored.

Font Face Definition
--------------------

A font face is defined by the Matplotlib compatible
:class:`~ezdxf.tools.fonts.FontFace` object by ``font-family``, ``font-style``,
``font-stretch`` and ``font-weight``.

.. seealso::

    - :ref:`font_anatomy`
    - :ref:`font_properties`


String Functions
----------------

.. autofunction:: make_path_from_str

.. autofunction:: make_paths_from_str

.. autofunction:: make_hatches_from_str

Entity Functions
----------------

.. autoclass:: Kind

.. autofunction:: virtual_entities

.. autofunction:: explode

.. autofunction:: make_path_from_entity

.. autofunction:: make_paths_from_entity

.. _fontTools: https://pypi.org/project/fonttools/

--- End of file: addons/text2path.rst ---



--- Start of file: appdata.rst ---


.. _application_defined_data:

Application-Defined Data (AppData)
==================================

The application-defined data feature is not very well documented in the DXF
reference, so usage as custom data store is not recommended. AutoCAD
uses these feature to store the handle to the extension dictionary
(:class:`~ezdxf.entities.xdict.ExtensionDict`) of a DXF entity and the handles
to the persistent reactors (:class:`~ezdxf.entities.appdata.Reactors`) of a
DXF entity.

Use the high level methods of :class:`~ezdxf.entities.DXFEntity` to manage
application-defined data tags.

- :meth:`~ezdxf.entities.DXFEntity.has_app_data`
- :meth:`~ezdxf.entities.DXFEntity.get_app_data`
- :meth:`~ezdxf.entities.DXFEntity.set_app_data`
- :meth:`~ezdxf.entities.DXFEntity.discard_app_data`

.. hint::

    Ezdxf uses special classes to manage the extension dictionary and the
    reactor handles. These features cannot be accessed by the methods above.

Set application-defined data::

    entity.set_app_data("YOURAPPID", [(1, "DataString")]))

Setting the content tags can contain the opening structure tag
(102, "{YOURAPPID") and the closing tag (102, "}"), but doesn't have to.
The returned :class:`~ezdxf.lldxf.tags.Tags` objects does not contain these
structure tags. Which tags are valid for application-defined data is not
documented.

The AppID has to have an entry in the AppID table.

Get application-defined data::

    if entity.has_app_data("YOURAPPID"):
        tags = entity.get_app_data("YOURAPPID")

    # tags content is [DXFTag(1, 'DataString')]

.. seealso::

    - Internals about :ref:`app_data_internals`
    - Internal AppData management class: :class:`~ezdxf.entities.appdata.AppData`




--- End of file: appdata.rst ---



--- Start of file: bbox.rst ---

Bounding Box
============

.. module:: ezdxf.bbox

The :mod:`ezdxf.bbox` module provide tools to calculate bounding boxes for
many DXF entities, but not for all. The bounding box calculation is based on the
:mod:`ezdxf.disassemble` module and therefore has the same limitation.

.. warning::

    If accurate boundary boxes for text entities are important for you,
    read this first: :ref:`Text Boundary Calculation`.
    TL;DR: Boundary boxes for text entities are **not accurate!**

Unsupported DXF entities:

    - All ACIS based types like BODY, 3DSOLID or REGION
    - External references (XREF) and UNDERLAY object
    - RAY and XRAY, extend into infinite
    - ACAD_TABLE, no basic support - only preserved by `ezdxf`


Unsupported entities are silently ignored, filtering of these DXF types is not
necessary.

The base type for bounding boxes is the :class:`~ezdxf.math.BoundingBox` class
from the module :mod:`ezdxf.math`.

The `entities` iterable as input can be the whole modelspace, an entity
query or any iterable container of DXF entities.

The Calculation of bounding boxes of curves is done by flattening the curve by
a default flattening distance of 0.01. Set argument `flatten` to 0 to speedup
the bounding box calculation by accepting less precision for curved objects by
using only the control vertices.

The **optional** caching object :class:`Cache` has to be instantiated by the
user, this is only useful if the same entities will be processed multiple times.

Example usage with caching:

.. code-block:: Python

    from ezdxf import bbox

    msp = doc.modelspace()
    cache = bbox.Cache()
    # get overall bounding box
    first_bbox = bbox.extents(msp, cache=cache)
    # bounding box of all LINE entities
    second_bbox = bbox.extend(msp.query("LINE"), cache=cache)

Functions
---------

.. autofunction:: extents

.. autofunction:: multi_flat

.. autofunction:: multi_recursive

Caching Strategies
------------------

Because `ezdxf` is not a CAD application, `ezdxf` does not manage data
structures which are optimized for a usage by a CAD kernel. This means
that the content of complex entities like block references or leaders has
to be created on demand by DXF primitives on the fly. These temporarily
created entities are called virtual entities and have no handle and are not
stored in the entity database.

All this is required to calculate the bounding box of complex entities,
and it is therefore a very time consuming task. By using a :class:`Cache` object
it is possible to speedup this calculations, but this is not a magically feature,
it requires an understanding of what is happening under the hood to achieve
any performance gains.

For a single bounding box calculation, without any reuse of entities it makes
no sense of using a :class:`Cache` object, e.g. calculation of the modelspace
extents:

.. code-block:: python

    from pathlib import Path
    import ezdxf
    from ezdxf import bbox

    CADKitSamples = Path(ezdxf.EZDXF_TEST_FILES) / 'CADKitSamples'

    doc = ezdxf.readfile(CADKitSamples / 'A_000217.dxf')
    cache = bbox.Cache()
    ext = bbox.extents(doc.modelspace(), cache)

    print(cache)

1226 cached objects and not a single cache hit::

    Cache(n=1226, hits=0, misses=3273)

The result for using UUIDs to cache virtual entities is not better::

    Cache(n=2206, hits=0, misses=3273)

Same count of hits and misses, but now the cache also references
~1000 virtual entities, which block your memory until the cache is deleted,
luckily this is a small DXF file (~838 kB).

Bounding box calculations for multiple entity queries, which have overlapping
entity results, using a :class:`Cache` object may speedup the calculation:

.. code-block:: python

    doc = ezdxf.readfile(CADKitSamples / 'A_000217.dxf.dxf')
    msp = doc.modelspace()
    cache = bbox.Cache(uuid=False)

    ext = bbox.extents(msp, cache)
    print(cache)

    # process modelspace again
    ext = bbox.extents(msp, cache)
    print(cache)

Processing the same data again leads some hits::

    1st run: Cache(n=1226, hits=0, misses=3273)
    2nd run: Cache(n=1226, hits=1224, misses=3309)

Using :code:`uuid=True` leads not to more hits, but more cache entries::

    1st run: Cache(n=2206, hits=0, misses=3273)
    2nd run: Cache(n=2206, hits=1224, misses=3309)

Creating stable virtual entities by disassembling the entities at
first leads to more hits:

.. code-block:: Python

    from ezdxf import disassemble

    entities = list(disassemble.recursive_decompose(msp))
    cache = bbox.Cache(uuid=False)

    bbox.extents(entities, cache)
    print(cache)

    bbox.extents(entities, cache)
    print(cache)

First without UUID for stable virtual entities::

    1st run: Cache(n=1037, hits=0, misses=4074)
    2nd run: Cache(n=1037, hits=1037, misses=6078)

Using UUID for stable virtual entities leads to more hits::

    1st run: Cache(n=2019, hits=0, misses=4074)
    2nd run: Cache(n=2019, hits=2018, misses=4116)

But caching virtual entities needs also more memory.

In conclusion: Using a cache is only useful, if you often process
**nearly the same data**; only then can an increase in performance be expected.

Cache Class
-----------

.. autoclass:: Cache

    .. py:attribute:: has_data

        ``True`` if the cache contains any bounding boxes

    .. py:attribute:: hits

    .. py:attribute:: misses

    .. automethod:: invalidate


--- End of file: bbox.rst ---



--- Start of file: blkrefs.rst ---


.. module:: ezdxf.blkrefs

Block Reference Management
==========================

The package `ezdxf` is not designed as a CAD library and does not automatically
monitor all internal changes. This enables faster entity processing at the cost
of an unknown state of the DXF document.

In order to carry out precise BLOCK reference management, i.e. to handle
dependencies or to delete unused BLOCK definition, the block reference status
(counter) must be acquired explicitly by the package user.
All block reference management structures must be explicitly recreated each time
the document content is changed. This is not very efficient, but it is safe.

.. warning::

    The DXF reference does not document all uses of blocks. The INSERT entity is
    just one explicit use case, but there are also many indirect block references
    and the customizability of DXF allows you to store block names and handles in
    many places.

    There are some rules for storing names and handles and this module checks all of
    these known rules, but there is no guarantee that everyone follows these rules.

    Therefore, it is still possible to destroy a DXF document by deleting an
    absolutely necessary block definition.

Always remember that `ezdxf` is not intended or suitable as a basis for a CAD
application!


.. autoclass:: BlockDefinitionIndex

    .. autoproperty:: block_records

    .. automethod:: rebuild

    .. automethod:: has_handle

    .. automethod:: by_handle

    .. automethod:: has_name

    .. automethod:: by_name

.. autoclass:: BlockReferenceCounter

    .. automethod:: by_handle

    .. automethod:: by_name

.. autofunction:: find_unreferenced_blocks


--- End of file: blkrefs.rst ---



--- Start of file: blocks/attdef.rst ---

AttDef
======

.. module:: ezdxf.entities
    :noindex:

The ATTDEF (`DXF Reference`_) entity is a template in a :class:`~ezdxf.layouts.BlockLayout`, which will be used to
create an attached :class:`Attrib` entity for an :class:`Insert` entity.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Text`
DXF type                 ``'ATTDEF'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_attdef`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. seealso::

    :ref:`tut_blocks`

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. class:: AttDef

    ATTDEF supports all DXF attributes and methods of parent class :class:`Text`.

    .. attribute:: dxf.tag

        Tag to identify the attribute (str)

    .. attribute:: dxf.text

        Attribute content as text (str)

    .. attribute:: dxf.prompt

        Attribute prompt string. (CAD application feature)

    .. attribute:: dxf.field_length

         Just relevant to CAD programs for validating user input

    .. autoproperty:: is_invisible

    .. autoproperty:: is_const

    .. autoproperty:: is_verify

    .. autoproperty:: is_preset

    .. autoproperty:: has_embedded_mtext_entity

    .. automethod:: virtual_mtext_entity

    .. automethod:: plain_mtext

    .. automethod:: set_mtext

    .. automethod:: embed_mtext

    .. automethod:: discard_mtext

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-F0EA099B-6F88-4BCC-BEC7-247BA64838A4

--- End of file: blocks/attdef.rst ---



--- Start of file: blocks/attrib.rst ---

Attrib
======

.. module:: ezdxf.entities
    :noindex:

The ATTRIB (`DXF Reference`_) entity represents a text value associated with a tag.
In most cases an ATTRIB is appended to an :class:`Insert` entity, but it can also
be used as a standalone entity.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Text`
DXF type                 ``'ATTRIB'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_attrib` (stand alone entity)
Factory function         :meth:`Insert.add_attrib` (attached to :class:`Insert`)
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. seealso::

    :ref:`tut_blocks`

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. class:: Attrib

    ATTRIB supports all DXF attributes and methods of parent class :class:`Text`.

    .. attribute:: dxf.tag

        Tag to identify the attribute (str)

    .. attribute:: dxf.text

        Attribute content as text (str)

    .. autoproperty:: is_invisible

    .. autoproperty:: is_const

    .. autoproperty:: is_verify

    .. autoproperty:: is_preset

    .. autoproperty:: has_embedded_mtext_entity

    .. automethod:: virtual_mtext_entity

    .. automethod:: plain_mtext

    .. automethod:: set_mtext

    .. automethod:: embed_mtext

    .. automethod:: discard_mtext

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-7DD8B495-C3F8-48CD-A766-14F9D7D0DD9B

--- End of file: blocks/attrib.rst ---



--- Start of file: blocks/block.rst ---

Block
=====

.. module:: ezdxf.entities
    :noindex:

BLOCK (`DXF Reference`_) entity is embedded into the :class:`~ezdxf.layouts.BlockLayout` object.
The BLOCK entity is accessible by the :attr:`BlockLayout.block` attribute.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFEntity`
DXF type                 ``'BLOCK'``
Factory function         :meth:`Drawing.blocks.new` (returns a :class:`~ezdxf.layouts.BlockLayout`)
======================== ==========================================

.. seealso::

    :ref:`tut_blocks` and DXF Internals: :ref:`Block Management Structures`


.. class:: Block

    .. attribute:: dxf.handle

        BLOCK handle as plain hex string. (feature for experts)

    .. attribute:: dxf.owner

        Handle to owner as plain hex string. (feature for experts)

    .. attribute:: dxf.layer

        Layer name as string; default value is ``'0'``

    .. attribute:: dxf.name

        BLOCK name as string. (case insensitive)

    .. attribute:: dxf.base_point

        BLOCK base point as ``(x, y, z)`` tuple, default value is ``(0, 0, 0)``

        Insertion location referenced by the :class:`~ezdxf.entities.Insert` entity to place the block reference
        and also the center of rotation and scaling.

    .. attribute:: dxf.flags

        BLOCK flags (bit-coded)

        ==== ===========
        1    Anonymous block generated by hatching, associative dimensioning, other internal operations, or an application
        2    Block has non-constant attribute definitions (this bit is not set if the block has any attribute
             definitions that are constant, or has no attribute definitions at all)
        4    Block is an external reference (xref)
        8    Block is an xref overlay
        16   Block is externally dependent
        32   This is a resolved external reference, or dependent of an external reference (ignored on input)
        64   This definition is a referenced external reference (ignored on input)
        ==== ===========

    .. attribute:: dxf.xref_path

        File system path as string, if this block defines an external reference (XREF).

    .. autoattribute:: is_layout_block

    .. autoattribute:: is_anonymous

    .. autoattribute:: is_xref

    .. autoattribute:: is_xref_overlay


EndBlk
======

ENDBLK entity is embedded into the :class:`~ezdxf.layouts.BlockLayout` object.
The ENDBLK entity is accessible by the :attr:`BlockLayout.endblk` attribute.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFEntity`
DXF type                 ``'ENDBLK'``
======================== ==========================================

.. class:: EndBlk

    .. attribute:: dxf.handle

        BLOCK handle as plain hex string. (feature for experts)

    .. attribute:: dxf.owner

        Handle to owner as plain hex string. (feature for experts)

    .. attribute:: dxf.layer

        Layer name as string; should always be the same as :attr:`Block.dxf.layer`

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-66D32572-005A-4E23-8B8B-8726E8C14302

--- End of file: blocks/block.rst ---



--- Start of file: blocks/index.rst ---

.. _blocks:

Blocks
======

A block definition (:class:`~ezdxf.layouts.BlockLayout`) is a collection of DXF entities,
which can be placed multiply times at different layouts or other blocks as references to
the block definition. Block layouts are located in the BLOCKS sections and are
accessible by the :attr:`~ezdxf.document.Drawing.blocks` attribute of the
:class:`~ezdxf.document.Drawing` class.

.. seealso::

    :ref:`tut_blocks` and DXF Internals: :ref:`Block Management Structures`

.. toctree::
    :maxdepth: 1

    block
    insert
    attrib
    attdef



--- End of file: blocks/index.rst ---



--- Start of file: blocks/insert.rst ---

Insert
======

.. module:: ezdxf.entities
    :noindex:

The INSERT entity (`DXF Reference`_) represents a block reference with optional
attached attributes as (:class:`Attrib`) entities.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'INSERT'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_blockref`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. seealso::

    :ref:`tut_blocks`

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!


.. class:: Insert

    .. attribute:: dxf.name

        BLOCK name (str)

    .. attribute:: dxf.insert

        Insertion location of the BLOCK base point as (2D/3D Point in :ref:`OCS`)

    .. attribute:: dxf.xscale

        Scale factor for x direction (float)

    .. attribute:: dxf.yscale

        Scale factor for y direction (float)

        Not all CAD applications support non-uniform scaling (e.g. LibreCAD).

    .. attribute:: dxf.zscale

        Scale factor for z direction (float)

        Not all CAD applications support non-uniform scaling (e.g. LibreCAD).

    .. attribute:: dxf.rotation

        Rotation angle in degrees (float)

    .. attribute:: dxf.row_count

        Count of repeated insertions in row direction, MINSERT entity if > 1 (int)

    .. attribute:: dxf.row_spacing

        Distance between two insert points (MINSERT) in row direction (float)

    .. attribute:: dxf.column_count

        Count of repeated insertions in column direction, MINSERT entity if > 1 (int)

    .. attribute:: dxf.column_spacing

        Distance between two insert points (MINSERT) in column direction (float)

    .. attribute:: attribs

        A list of all attached :class:`Attrib` entities.

    .. autoattribute:: has_scaling

    .. autoattribute:: has_uniform_scaling

    .. autoattribute:: mcount

    .. automethod:: set_scale

    .. automethod:: block

    .. automethod:: place

    .. automethod:: grid

    .. automethod:: has_attrib

    .. automethod:: get_attrib

    .. automethod:: get_attrib_text

    .. automethod:: add_attrib

    .. automethod:: add_auto_attribs

    .. automethod:: delete_attrib

    .. automethod:: delete_all_attribs

    .. automethod:: transform

    .. automethod:: translate

    .. automethod:: virtual_entities

    .. automethod:: multi_insert

    .. automethod:: explode

    .. automethod:: ucs

    .. automethod:: matrix44

    .. automethod:: reset_transformation



.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-28FA4CFB-9D5E-4880-9F11-36C97578252F

--- End of file: blocks/insert.rst ---



--- Start of file: colors.rst ---

Colors Module
=============

.. module:: ezdxf.colors

This module provides functions and constants to manage all kinds of colors in
DXF documents.

Converter Functions
===================

.. autofunction:: rgb2int

.. autofunction:: int2rgb

.. autofunction:: aci2rgb

.. autofunction:: luminance

.. autofunction:: decode_raw_color

.. autofunction:: decode_raw_color_int

.. autofunction:: encode_raw_color

.. autofunction:: transparency2float

.. autofunction:: float2transparency

RGB Class
=========

.. autoclass:: RGB

    .. autoproperty:: luminance

    .. automethod:: to_hex

    .. automethod:: from_hex

    .. automethod:: to_floats

    .. automethod:: from_floats

RGBA Class
==========

.. autoclass:: RGBA

    .. autoproperty:: luminance

    .. automethod:: to_hex

    .. automethod:: from_hex

    .. automethod:: to_floats

    .. automethod:: from_floats

ACI Color Values
================

Common :ref:`ACI` values, also accessible as IntEnum :class:`ezdxf.enums.ACI`

=========================== ===
BYBLOCK                     0
BYLAYER                     256
BYOBJECT                    257
RED                         1
YELLOW                      2
GREEN                       3
CYAN                        4
BLUE                        5
MAGENTA                     6
BLACK (on light background) 7
WHITE (on dark background)  7
GRAY                        8
LIGHT_GRAY                  9
=========================== ===

Default Palettes
================

Default color mappings from :ref:`ACI` to :term:`true-color` values.

=========== =============================
model space DXF_DEFAULT_COLORS
paper space DXF_DEFAULT_PAPERSPACE_COLORS
=========== =============================

Raw Color Types
===============

======================= ====
COLOR_TYPE_BY_LAYER     0xC0
COLOR_TYPE_BY_BLOCK     0xC1
COLOR_TYPE_RGB          0xC2
COLOR_TYPE_ACI          0xC3
COLOR_TYPE_WINDOW_BG    0xC8
======================= ====

Raw Color Vales
===============

=================== ============
BY_LAYER_RAW_VALUE  -1073741824
BY_BLOCK_RAW_VALUE  -1056964608
WINDOW_BG_RAW_VALUE -939524096
=================== ============

Transparency Values
===================

======================= =========
OPAQUE                  0x20000FF
TRANSPARENCY_10         0x20000E5
TRANSPARENCY_20         0x20000CC
TRANSPARENCY_30         0x20000B2
TRANSPARENCY_40         0x2000099
TRANSPARENCY_50         0x200007F
TRANSPARENCY_60         0x2000066
TRANSPARENCY_70         0x200004C
TRANSPARENCY_80         0x2000032
TRANSPARENCY_90         0x2000019
TRANSPARENCY_BYBLOCK    0x1000000
======================= =========

--- End of file: colors.rst ---



--- Start of file: concepts/aci.rst ---

.. _aci:

AutoCAD Color Index (ACI)
=========================

The :attr:`~ezdxf.entities.DXFGraphic.dxf.color` attribute represents an `ACI`
(AutoCAD Color Index).
AutoCAD and many other :term:`CAD` application provides a default color table,
but pen table would be the more correct term.
Each ACI entry defines the color value, the line weight and some other
attributes to use for the pen. This pen table can be edited by the user or
loaded from an :term:`CTB` or :term:`STB` file.
`Ezdxf` provides functions to create (:func:`~ezdxf.acadctb.new`) or modify
(:func:`ezdxf.acadctb.load`) plot styles files.

DXF R12 and prior do not preserve the layout of a drawing very well, because
of the lack of a standard color table and missing DXF structures to define
these color tables in the DXF file.
If a CAD user redefines an ACI color entry in a CAD application and does not
provide this :term:`CTB` or :term:`STB` file, you can not know what color
or lineweight was used intentionally.
This got better in later DXF versions by supporting additional DXF
attributes like :attr:`~ezdxf.entities.DXFGraphic.dxf.lineweight` and
:attr:`~ezdxf.entities.DXFGraphic.dxf.true_color` which can define these
attributes by distinct values.

.. image:: ../gfx/ACI-Color-Wheel.png


.. seealso::

    - :ref:`plot_style_files`
    - :mod:`ezdxf.colors`
    - :ref:`tut_common_graphical_attributes`
    - Autodesk Knowledge Network: `About Setting the Color of Objects`_
    - BricsCAD Help Center: `Entity Color`_

.. _About Setting the Color of Objects: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2019/ENU/AutoCAD-Core/files/GUID-14BC039D-238D-4D9E-921B-F4015F96CB54-htm.html
.. _Entity Color: https://help.bricsys.com/document/_guides--BCAD_2D_drafting--GD_entitycolor/V22/EN_US?id=165079136935

--- End of file: concepts/aci.rst ---



--- Start of file: concepts/blocks.rst ---

.. _block_concept:

Blocks
======

Blocks are collections of DXF entities which can be placed multiple times as
block references in different layouts and other block definitions.
The block reference (:class:`~ezdxf.entities.Insert`) can be rotated, scaled,
placed in 3D space by :ref:`OCS` and arranged in a grid like manner, each
:class:`~ezdxf.entities.Insert` entity can have individual attributes
(:class:`~ezdxf.entities.Attrib`) attached.

Block Attributes
----------------

A block attribute (:class:`~ezdxf.entities.Attrib`) is a text annotation attached
to a block reference with an associated tag. Attributes are often used to add
information to block references which can be evaluated and exported by CAD
applications.

Extended Block Features
-----------------------

Autodesk added many new features to BLOCKS (dynamic blocks, constraints) as
undocumented DXF entities, many of these features are not fully supported by
other CAD application and `ezdxf` also has no support or these features beyond
the preservation of these undocumented DXF entities.

.. seealso::

    - :ref:`Blocks` Section
    - :ref:`tut_blocks`


--- End of file: concepts/blocks.rst ---



--- Start of file: concepts/coordinates.rst ---

.. _Coordinate Systems:

Coordinate Systems
==================

`AutoLISP Reference to Coordinate Systems <http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-0F0B833D-78ED-4491-9918-9481793ED10B>`_
provided by Autodesk.

To brush up you knowledge about vectors, watch the YouTube tutorials of
`3Blue1Brown`_ about `Linear Algebra`_.

.. _WCS:

WCS
---

World coordinate system - the reference coordinate system. All other coordinate
systems are defined relative to the WCS, which never changes. Values measured
relative to the WCS are stable across changes to other coordinate systems.

.. _UCS:

UCS
---

User coordinate system - the working coordinate system defined by the user to
make drawing tasks easier. All points passed to AutoCAD commands, including those
returned from AutoLISP routines and external functions, are points in the
current UCS. As far as I know, all coordinates stored in DXF files are always
WCS or OCS never UCS.

User defined coordinate systems are not just helpful for interactive CAD,
therefore `ezdxf` provides a converter class :class:`~ezdxf.math.UCS` to translate
coordinates from UCS into WCS and vice versa, but always remember: store only
WCS or OCS coordinates in DXF files, because there is no method to determine
which UCS was active or used to create UCS coordinates.

.. seealso::

    - Table entry :class:`UCS`
    - :class:`ezdxf.math.UCS` - converter between WCS and UCS

.. _OCS:

OCS
---

Object coordinate system  are coordinates relative to the object itself.
The main goal of OCS is to place 2D elements in 3D space and the OCS is defined
by the extrusion vector of the entity.
As long the extrusion vector is (0, 0, 1) (the WCS z-axis) the OCS is coincident
to the WCS, which means the OCS coordinates are equal to the WCS coordinates,
most of the time this is true for 2D entities.

OCS entities: ARC, CIRCLE, TEXT, LWPOLYLINE, HATCH, SOLID, TRACE, INSERT, IMAGE

Because `ezdxf` is just an interface to DXF, it does not automatically convert
OCS into WCS, this is the domain of the user/application. These lines convert
the center of a 3D circle from OCS to WCS::

    ocs = circle.ocs()
    wcs_center = ocs.to_wcs(circle.dxf.center)


.. seealso::

    - :ref:`Object Coordinate System` - deeper insights into OCS
    - :class:`ezdxf.math.OCS` - converter between WCS and OCS

.. _DCS:

DCS
---

Display coordinate system - the coordinate system into which objects are
transformed before they are displayed. The origin of the DCS is the point
stored in the AutoCAD system variable TARGET, and its z-axis is the viewing
direction. In other words, a viewport is always a plan view of its DCS. These
coordinates can be used to determine where something will be displayed to the
AutoCAD user. `Ezdxf` does not use or support DCS in any way.


.. _Linear Algebra: https://www.youtube.com/watch?v=kjBOesZCoqc&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab
.. _3Blue1Brown: https://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw


--- End of file: concepts/coordinates.rst ---



--- Start of file: concepts/dxf.rst ---

.. _what is dxf:

What is DXF?
============

The common assumption is also the cite of `Wikipedia`_:

    AutoCAD DXF (Drawing eXchange Format) is a CAD data file format developed by
    Autodesk for enabling data interoperability between AutoCAD and **other**
    applications.

    DXF was originally introduced in December 1982 as part of AutoCAD 1.0, and was
    intended to provide an exact representation of the data in the AutoCAD native
    file format, DWG (Drawing). For many years Autodesk did not publish
    specifications making correct imports of DXF files difficult. Autodesk now
    publishes the DXF specifications online.

The more precise cite from the `DXF reference`_ itself:

    The DXF format is a tagged data representation of all the information contained
    in an AutoCAD drawing file. Tagged data means that each data element in the
    file is preceded by an integer number that is called a group code. A group
    code's value indicates what type of data element follows. This value also
    indicates the meaning of a data element for a given object (or record) type.
    Virtually all user-specified information in a drawing file can be represented
    in DXF format.

No mention of interoperability between AutoCAD and **other** applications.

In reality the DXF format was designed to ensure AutoCAD cross-platform
compatibility in the early days when different hardware platforms with different
binary data formats were used. The name DXF (Drawing eXchange Format) may
suggest an universal exchange format, but it is not. It is based on the
infrastructure installed by Autodesk products (fonts) and the implementation
details of AutoCAD (MTEXT) or on licensed third party technologies
(embedded ACIS entities).

For more information about the AutoCAD history see the document:
`The Autodesk File`_ - Bits of History, Words of Experience by *John Walker*,
founder of *Autodesk, Inc.* and co-author of *AutoCAD*.

DXF Reference Quality
---------------------

The `DXF reference`_ is by far no specification nor a standard like the
W3C standard for `SVG`_ or the ISO standard for `PDF`_.

The reference describes many but not all DXF entities and some basic concepts
like the tag structure or the arbitrary axis algorithm.
But the existing documentation (reference) is incomplete and partly misleading
or wrong. Also missing from the reference are some important parts like the complex
relationship between the entities to create higher order structures like block
definitions, layouts (model space & paper space) or dynamic blocks to name a few.

Reliable CAD Applications
-------------------------

Because of the suboptimal quality of the DXF reference not all DXF viewers,
creators or processors are of equal quality. I consider a CAD application
as a :term:`reliable CAD application` when the application creates valid DXF
documents in the meaning and interpretation of `Autodesk`_ and a reliable DXF
viewer when the result matches in most parts the result of the free `Trueview`_
viewer provided by `Autodesk`_.

These are some applications which do fit the criteria of a reliable CAD application:

- `AutoCAD`_ and `Trueview`_
- CAD applications based on the `OpenDesignAlliance`_ (ODA) SDK, see also
  `ODA on wikipedia`_, even `Autodesk`_ is a corporate member, see their blog post
  from `22 Sep 2020 <https://adsknews.autodesk.com/news/open-design-alliance-membership>`_
  at `adsknews`_ but only to use the ODA IFC tools and not to improve the DWG/DXF
  compatibility
- `BricsCAD`_ (ODA based)
- `GstarCAD`_ (ODA based)
- `ZWCAD`_ (ODA based)


Unfortunately, I cannot recommend any open source applications because everyone
I know has serious shortcomings, at least as a DXF viewer, and I don't trust
them as a DXF creator either. To be clear, not even `ezdxf` (which is not a CAD
application) is a `reliable` library in this sense - it just keeps getting better,
but is far from `reliable`.

.. hint::

    Please do not submit bug reports based on the use of `LibreCAD`_ or `QCAD`_, these
    applications are in no way reliable regarding the DXF format and I will not waste my
    time on them.

.. _Wikipedia: https://en.wikipedia.org/wiki/AutoCAD_DXF

.. _DXF reference: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-235B22E0-A567-4CF6-92D3-38A2306D73F3

.. _The Autodesk file: https://www.fourmilab.ch/autofile/

.. _SVG: https://www.w3.org/Graphics/SVG/

.. _PDF: https://en.wikipedia.org/wiki/PDF

.. _Autodesk: https://www.autodesk.com/

.. _Trueview: https://www.autodesk.com/viewers

.. _AutoCAD: https://www.autodesk.com/products/autocad/overview

.. _BricsCAD: https://www.bricsys.com/en-intl/

.. _GstarCAD: https://www.gstarcad.net/

.. _ZWCAD: https://www.zwsoft.com/product/zwcad

.. _OpenDesignAlliance: https://www.opendesign.com/

.. _ODA on Wikipedia: https://en.wikipedia.org/wiki/Open_Design_Alliance

.. _LibreCAD: https://librecad.org/

.. _QCAD: https://qcad.org/en/

.. _adsknews: https://adsknews.autodesk.com/

--- End of file: concepts/dxf.rst ---



--- Start of file: concepts/entities.rst ---

.. _dxf_entities_concept:

DXF Entities and Objects
========================

DXF entities are objects that make up the design data stored in a DXF file.

Graphical Entities
------------------

Graphical entities are visible objects stored in blocks, modelspace- or paperspace
layouts. They represent the various shapes, lines, and other elements that make up a
2D or 3D design.

Some common types of DXF entities include:

- LINE and POLYLINE: These are the basic building blocks of a DXF file. They
  represent straight and curved lines.
- CIRCLE and ARC: These entities represent circles and portions of circles, respectively.
- TEXT and MTEXT: DXF files can also contain text entities, which can be used to
  label parts of the design or provide other information.
- HATCH: DXF files can also include hatch patterns, which are used to fill in areas with
  a specific pattern or texture.
- DIMENSION: DXF files can also contain dimension entities, which provide precise
  measurements of the various elements in a design.
- INSERT: A block is a group of entities that can be inserted into a design multiple
  times by the INSERT entity, making it a useful way to reuse elements of a design.

These entities are defined using specific codes and values in the DXF file format, and
they can be created and manipulated by `ezdxf`.

Objects
-------

DXF objects are non-graphical entities and have no visual representation, they store
administrative data, paperspace layout definitions, style definitions for multiple
entity types, custom data and objects. The OBJECTS section in DXF files serves as a
container for these non-graphical objects.

Some common DXF types of DXF objects include:

- DICTIONARY: A dictionary object consists of a series of name-value pairs, where the
  name is a string that identifies a specific object within the dictionary, and the
  value is a reference to that object. The objects themselves can be any type of DXF
  entity or custom object defined in the DXF file.
- XRECORD entities are used to store custom application data in a DXF file.
- the LAYOUT entity is a DXF entity that represents a single paper space layout in a DXF
  file. Paper space is the area in a CAD drawing that represents the sheet of paper or
  other physical media on which the design will be plotted or printed.
- MATERIAL, MLINESTYLE, MLEADERSTYLE definitions stored in certain DICTIONARY objects.
- A GROUP entity contains a list of handles that refer to other DXF entities in the
  drawing. The entities in the group can be of any type, including entities from the
  model space or paper space layouts.

TagStorage
----------

The `ezdxf` package supports many but not all entity types, all these unsupported
types are stored as :class:`TagStorage` instances to preserve their data when
exporting the edited DXF content by `ezdxf`.

Access Entity Attributes
------------------------

All DXF attributes are stored in the entity namespace attribute :attr:`dxf`.

.. code-block:: Python

    print(entity.dxf.layer)

Some attributes are mandatory others are optional in most cases a reasonable values will
be returned as default value if the attribute is missing.

.. seealso::

    :ref:`tut_getting_data`

Where to Look for Entities
--------------------------

The DXF document has an entity database where all entities which have a handle are
stored in a (key, value) storage. The :meth:`query` method is often the easiest way to
request data:

.. code-block:: Python

    for text in doc.entitydb.query("TEXT"):
        print(text.dxf.text)

.. seealso::

    - :mod:`ezdxf.query` module
    - :mod:`ezdxf.entitydb` module

Graphical entities are stored in blocks, the modelspace or paperspace layouts.

- The :func:`doc.modelspace` function returns the :class:`~ezdxf.layouts.Modelspace` instance
- The :func:`doc.paperspace` returns a :class:`~ezdxf.layouts.Paperspace` instance
- The :attr:`doc.blocks` attribute provides access to the :class:`~ezdxf.sections.blocks.BlocksSection`

The :meth:`~ezdxf.document.Drawing.query` method of the :class:`~ezdxf.document.Drawing`
class which represents the DXF document, runs the query on all layouts and block
definitions.

Non-graphical entities are stored in the OBJECTS section:

- The :attr:`doc.objects` attribute provides access to the
  :class:`~ezdxf.sections.objects.ObjectsSection`.

Resource definitions like :class:`~ezdxf.entities.Layer`, :class:`~ezdxf.entities.Linetype`
or :class:`~ezdxf.entities.Textstyle` are stored in resource tables:

- :attr:`doc.layers`: the :class:`~ezdxf.sections.table.LayerTable`
- :attr:`doc.linetypes`: the :class:`~ezdxf.sections.table.LinetypeTable`
- :attr:`doc.styles`: the :class:`~ezdxf.sections.table.TextstyleTable`
- :attr:`doc.dimstyles`: the :class:`~ezdxf.sections.table.DimStyleTable`

.. important::

    A layer assignment is just an attribute of a DXF entity, it's not an entity
    container!

.. seealso::

    - Basic concept of the :ref:`modelspace_concept`
    - Basic concept of :ref:`paperspace_concept` layouts
    - Basic concept of :ref:`block_concept`
    - :ref:`tut_getting_data`

How to Create Entities
----------------------

The recommended way to create new DXF entities is to use the factory methods of
layouts and blocks to create entities and add them to the entity space automatically.

.. seealso::

    - :ref:`thematic_factory_method_index`
    - Reference of the :class:`~ezdxf.layouts.BaseLayout` class
    - :ref:`tut_dxf_primitives`


--- End of file: concepts/entities.rst ---



--- Start of file: concepts/extents_limits.rst ---

.. _Layout extents and limits:

Layout Extents and Limits
=========================

The `extents` and `limits` of an layout represents borders which can be
referenced by the ZOOM command or read from some header variables from the
:class:`~ezdxf.sections.header.HeaderSection`, if the creator application
maintains these values -- `ezdxf` does this not automatically.

Extents
-------

The `extents` of an layout are determined by the maximum extents of all DXF
entities that are in this layout. The command::

    ZOOM extents

sets the current viewport to the extents of the currently selected layout.

A paperspace layout in an arbitrary zoom state:

.. image:: ../gfx/zoom_overview_800px.png

The same layout after the :code:`ZOOM extents` command:

.. image:: ../gfx/zoom_extents_800px.png

Limits
------

Sets an invisible rectangular boundary in the drawing area that can limit the
grid display and limit clicking or entering point locations. The default limits
for paperspace layouts is defined by the paper size.

The layout from above after the :code:`ZOOM all` command:

.. image:: ../gfx/zoom_all_800px.png

.. seealso::

    The AutoCAD online reference for the `ZOOM`_ and the `LIMITS`_ command.

Read Stored Values
------------------

The extents of the modelspace (the tab called "Model") are stored in
the header variable ``$EXTMIN`` and ``$EXTMAX``. The default values
of ``$EXTMIN`` is (+1e20, +1e20, +1e20) and ``$EXTMAX`` is
(-1e20, -1e20, -1e20), which do not describe real borders. These values are
copies of the extents attributes of the :class:`~ezdxf.layouts.Layout`
object as :attr:`Layout.dxf.extmin` and :attr:`Layout.dxf.extmax`.

The limits of the modelspace are stored in the header variables ``$LIMMIN`` and
``$LIMMAX`` and have default values of (0, 0) and (420, 297), the default paper
size of `ezdxf` in drawing units. These are copies of the :class:`~ezdxf.layouts.Layout`
attributes :attr:`Layout.dxf.extmin` and :attr:`Layout.dxf.extmax`.

The extents and the limits of the `actual` paperspace layout, which is the last
activated paperspace layout tab, are stored in the header variable ``$PEXTMIN``,
``$PEXTMAX``, ``$PLIMMIN`` and ``$PLIMMAX``.

Each paperspace layout has its own values stored in the :class:`~ezdxf.layouts.Layout`
attributes :attr:`Layout.dxf.extmin`, :attr:`Layout.dxf.extmax`, :attr:`Layout.dxf.limmin`
and :attr:`Layout.dxf.limmax`.

Setting Extents and Limits
--------------------------

Since v0.16 `ezdxf` it is sufficient to define the attributes for `extents` and
`limits` (:attr:`Layout.dxf.extmax`, :attr:`Layout.dxf.limmin` and
:attr:`Layout.dxf.limmax`) of :class:`~ezdxf.layouts.Layout` object.
The header variables are synchronized when the document is saved.

The extents of a layout are not calculated automatically by `ezdxf`, as this
can take a long time for large documents and correct values are not required
to create a valid DXF document.

.. seealso::

    How to: :ref:`calc msp extents`

.. _zoom: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2020/ENU/AutoCAD-Core/files/GUID-66E7DB72-B2A7-4166-9970-9E19CC06F739-htm.html

.. _limits: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2021/ENU/AutoCAD-Core/files/GUID-6CF82FC7-E1BC-4A8C-A23D-4396E3D99632-htm.html?us_oa=akn-us&us_si=e9cbb4f4-03c5-4af9-aa76-b58263233f35&us_st=LIMITS%20(Command)

--- End of file: concepts/extents_limits.rst ---



--- Start of file: concepts/fonts.rst ---

.. _font resources:

Font Resources
--------------

DXF relies on the infrastructure installed by AutoCAD like the included SHX
files or True Type fonts. There is no simple way to store additional information
about a used fonts beside the plain file system name like ``"arial.ttf"``.
The CAD application or viewer which opens the DXF file has to have access to
the specified fonts used in your DXF document or it has to use an appropriate
replacement font, which is not that easy in the age of unicode. Later DXF
versions can store font family names in the XDATA of the STYLE entity but not
all CAD application use this information.


--- End of file: concepts/fonts.rst ---



--- Start of file: concepts/index.rst ---

.. _basic concepts:

Basic Concepts
--------------

The Basic Concepts section teach the intended meaning of DXF attributes and
structures without teaching the application of this information or the specific
implementation by `ezdxf`, if you are looking for more information about the
`ezdxf` internals look at the :ref:`Reference` section or if you want to learn
how to use `ezdxf` go to the :ref:`Tutorials` section and for the solution of
specific problems go to the :ref:`Howto` section.

.. toctree::
    :maxdepth: 1

    dxf
    entities
    aci
    true_color
    transparency
    layers
    linetypes
    lineweights
    coordinates
    ocs
    units
    modelspace
    paperspace
    blocks
    extents_limits
    fonts



--- End of file: concepts/index.rst ---



--- Start of file: concepts/layers.rst ---

.. _layer_concept:

Layers
======

Every object has a layer as one of its properties. You may be familiar with
layers - independent drawing spaces that stack on top of each other to create
an overall image - from using drawing programs. Most CAD programs use layers as
the primary organizing principle for all the objects that you draw.
You use layers to organize objects into logical groups of things that belong
together; for example, walls, furniture, and text notes usually belong on three
separate layers, for a couple of reasons:

- Layers give you a way to turn groups of objects on and off - both on the screen
  and on the plot.
- Layers provide the most efficient way of controlling object color and linetype

Create a layer table entry :class:`~ezdxf.entities.Layer` by :meth:`Drawing.layers.add`,
assign the layer properties such as color and linetype. Then assign those layers
to other DXF entities by setting the DXF attribute :attr:`~ezdxf.entities.DXFGraphic.dxf.layer`
to the layer name as string.

The DXF format do not require a layer table entry for a layer. A layer
without a layer table entry has the default linetype ``'Continuous'``, a default
color of ``7`` and a lineweight of ``-3`` which represents the default
lineweight of 0.25mm in most circumstances.

Layer Properties
----------------

The advantage of assigning properties to a layer is that entities
can inherit this properties from the layer by using the string ``'BYLAYER'`` as
linetype string, ``256`` as color or ``-1`` as lineweight, all these values
are the default values for new entities. DXF version R2004 and later also
support inheriting `true_color` and `transparency` attributes from a layer.

Layer Status
------------

The layer status is important for the visibility and the ability to
select and edit DXF entities on that layer in CAD applications.
`Ezdxf` does not care about the visual representation and works at the level
of entity spaces and the entity database and therefore all the layer states
documented below are ignored by `ezdxf`.
This means if you iterate an entity space like the modelspace or the entity
database you will get all entities from that entity space regardless the layer
status.

- ON: the layer is visible, entities on that layer are visible, selectable and editable
- OFF: the layer is not visible, entities on that layer are not visible, not
  selectable and not editable
- FROZEN: the layer is not visible, entities on that layer are not visible,
  not selectable and not editable, very similar to the OFF status but layers
  can be frozen individually in VIEWPORTS and freezing layers may speed up some
  commands in CAD applications like ZOOM, PAN or REGEN.
- LOCKED: the layer is visible, entities on that layer are visible but not
  selectable and not editable

Deleting Layers
---------------

Deleting a layer is not as simple as it might seem, especially if you are used
to use a CAD application like AutoCAD. There is no directory of locations where
layers can be used and references to layers can occur even in third-party data.
Deleting the layer table entry removes only the default attributes of that layer
and does not delete any layer references automatically. And because a layer can
exist without a layer table entry, the layer exist as long as at least one layer
reference to the layer exist.

Renaming Layers
---------------

Renaming a layer is also problematic because the DXF format stores the layer
references in most cases as text strings, so renaming the layer table entry
just creates a new layer and all entities which still have a reference to the
old layer now inherit their attributes from an undefined layer table entry with
default settings.

Viewport Overrides
------------------

Most of the layer properties can be overriden for each
:class:`~ezdxf.entities.Viewport` entity individually and this overrides are
stored in layer table entry referenced by the handle of the VIEWPORT entity.
In contrast the frozen status of layers is store in the VIEWPORT entity.

.. seealso::

    - :ref:`tut_layers`
    - :ref:`tut_psp_viewports`
    - Autodesk Knowledge Network: `About Layers`_
    - BricsCAD Help Center: `Working with Layers`_

.. _About Layers: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2019/ENU/AutoCAD-Core/files/GUID-6B3E3B5D-3AE2-4162-A5FE-CFE42AB0743B-htm.html
.. _Working with Layers: https://help.bricsys.com/document/_guides--BCAD_2D_drafting--GD_workingwithlayers/V22/EN_US?id=165079137441

--- End of file: concepts/layers.rst ---



--- Start of file: concepts/linetypes.rst ---

.. _linetypes:

Linetypes
=========

The :attr:`~ezdxf.entities.DXFGraphic.dxf.linetype` defines the rendering pattern
of linear graphical entities like LINE, ARC, CIRCLE and so on.
The linetype of an entity can be specified by the DXF attribute :attr:`linetype`,
this can be an explicit named linetype or the entity can inherit its linetype
from the assigned layer by setting :attr:`linetype` to ``'BYLAYER'``,
which is also the default value. ``CONTINUOUS`` is the default linetype for
layers with an unspecified linetype.

`Ezdxf` creates several standard linetypes, if the argument `setup` is ``True``
when calling :func:`~ezdxf.new`, this simple linetypes are supported by all
DXF versions:

.. code-block:: Python

    doc = ezdxf.new('R2007', setup=True)

.. image:: all_std_line_types.png

In DXF R13 Autodesk introduced complex linetypes which can contain text or
shapes.

.. seealso::

    - :ref:`tut_common_graphical_attributes`
    - :ref:`tut_linetypes`
    - Autodesk Knowledge Network: `About Linetypes`_
    - BricsCAD Help Center: `Entity Linetype`_

Linetype Scaling
-----------------

Global linetype scaling can be changed by setting the header variable
:code:`doc.header['$LTSCALE'] = 2`, which stretches the line pattern by factor 2.

The linetype scaling for a single entity can be set by the DXF attribute
:attr:`~ezdxf.entities.DXFGraphic.dxf.ltscale`, which is supported since
DXF R2000.

.. _About Linetypes: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2019/ENU/AutoCAD-Core/files/GUID-20B4D4B3-1220-426A-847B-5BBE36EC6FDF-htm.html#GUID-20B4D4B3-1220-426A-847B-5BBE36EC6FDF__SECTION_C298CAFE7CDF42A1AF937862BDA04F1C
.. _Entity Linetype: https://help.bricsys.com/document/_guides--BCAD_2D_drafting--GD_entitylinetype/V22/EN_US?id=165079137037

--- End of file: concepts/linetypes.rst ---



--- Start of file: concepts/lineweights.rst ---

.. _lineweights:

Lineweights
===========

The :attr:`~ezdxf.entities.DXFGraphic.dxf.lineweight` attribute represents the
lineweight as integer value in millimeters * 100, e.g. 0.25mm = 25,
independently from the unit system used in the DXF document.
The :attr:`lineweight` attribute is supported by DXF R2000 and newer.

Only certain values are valid, they are stored in
:attr:`ezdxf.lldxf.const.VALID_DXF_LINEWEIGHTS`: 0, 5, 9, 13, 15, 18, 20, 25,
30, 35, 40, 50, 53, 60, 70, 80, 90, 100, 106, 120, 140, 158, 200, 211.

Values < 0 have a special meaning and can be imported as constants from
:mod:`ezdxf.lldxf.const`

=== ==================
-1  LINEWEIGHT_BYLAYER
-2  LINEWEIGHT_BYBLOCK
-3  LINEWEIGHT_DEFAULT
=== ==================

The validator function: :func:`ezdxf.lldxf.validator.is_valid_lineweight`
returns ``True`` for valid lineweight values otherwise ``False``.

Sample script which shows all valid lineweights: `valid_lineweights.dxf`_

You have to enable the option to show lineweights in your CAD application or
viewer to see the effect on screen, which is disabled by default, the same
has to be done in the page setup options for plotting lineweights.

Setting the HEADER variable ``$LWDISPLAY`` to 1, activates support for
displaying lineweights on screen::

    # activate on screen lineweight display
    doc.header["$LWDISPLAY"] = 1

.. image:: ../gfx/valid_lineweights.png


The lineweight value can be overridden by :term:`CTB` or :term:`STB` files.

.. seealso::

    - Autodesk Knowledge Network: `About Lineweights`_
    - BricsCAD Help Center: `Entity Lineweight`_

.. _valid_lineweights.dxf: https://raw.githubusercontent.com/mozman/ezdxf/master/examples_dxf/valid_lineweights.dxf
.. _About Lineweights: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2019/ENU/AutoCAD-Core/files/GUID-4B33ACD3-F6DD-4CB5-8C55-D6D0D7130905-htm.html
.. _Entity Lineweight: https://help.bricsys.com/document/_guides--BCAD_2D_drafting--GD_lineweight/V22/EN_US?id=165079137239

--- End of file: concepts/lineweights.rst ---



--- Start of file: concepts/modelspace.rst ---

.. _modelspace_concept:

Modelspace
==========

The modelspace contains the "real" world representation of the drawing subjects
in real world units and is displayed in the tab called "Model" in CAD
applications. The modelspace is always present and can't be deleted.

The modelspace object is acquired by the method :meth:`~ezdxf.document.Drawing.modelspace`
of the :class:`~ezdxf.document.Drawing` class and new entities
should be added to the modelspace by factory methods: :ref:`thematic_factory_method_index`.

This is a common idiom for creating a new document and acquiring the modelspace::

    import ezdxf

    doc = ezdxf.new()
    msp = doc.modelspace()

The modelspace can have one or more rectangular areas called modelspace
viewports. The modelspace viewports can be used for displaying different views
of the modelspace from different locations of the modelspace or viewing
directions. It is important to know that modelspace viewports (:class:`~ezdxf.entities.VPort`)
are not the same as paperspace viewport entities (:class:`~ezdxf.entities.Viewport`).


.. seealso::

    - Reference of class :class:`~ezdxf.layouts.Modelspace`
    - :ref:`thematic_factory_method_index`
    - Example for usage of modelspace viewports: `tiled_window_setup.py`_

.. _tiled_window_setup.py: https://github.com/mozman/ezdxf/blob/master/examples/tiled_window_setup.py

--- End of file: concepts/modelspace.rst ---



--- Start of file: concepts/ocs.rst ---

.. _Object Coordinate System:

Object Coordinate System (OCS)
==============================


- `DXF Reference for OCS`_ provided by Autodesk.

The points associated with each entity are expressed in terms of the entity's
own object coordinate system (OCS). The OCS was referred to as ECS in previous
releases of AutoCAD.

With OCS, the only additional information needed to describe the entity's
position in 3D space is the 3D vector describing the z-axis of the OCS (often
referenced as extrusion vector), and the elevation value, which is the
distance of the entity xy-plane to the WCS/OCS origin.

For a given z-axis (extrusion) direction, there are an infinite number of
coordinate systems, defined by translating the origin in 3D space and by
rotating the x- and y-axis around the z-axis. However, for the same z-axis
direction, there is only one OCS. It has the following properties:

- Its origin coincides with the WCS origin.
- The orientation of the x- and y-axis within the xy-plane are calculated in an
  arbitrary but consistent manner. AutoCAD performs this calculation using the
  arbitrary axis algorithm (see below).
- Because of the `Arbitrary Axis Algorithm`_ the OCS can only represent a
  **right-handed** coordinate system!

The following entities do not lie in a particular plane. All points are
expressed in world coordinates. Of these entities, only lines and points can be
extruded. Their extrusion direction can differ from the world z-axis.

- :class:`~ezdxf.entities.Line`
- :class:`~ezdxf.entities.Point`
- :class:`~ezdxf.entities.3DFace`
- :class:`~ezdxf.entities.Polyline` (3D)
- :class:`~ezdxf.entities.Vertex` (3D)
- :class:`~ezdxf.entities.Polymesh`
- :class:`~ezdxf.entities.Polyface`
- :class:`~ezdxf.entities.Viewport`

These entities are planar in nature. All points are expressed in object
coordinates. All of these entities can be extruded. Their extrusion direction
can differ from the world z-axis.

- :class:`~ezdxf.entities.Circle`
- :class:`~ezdxf.entities.Arc`
- :class:`~ezdxf.entities.Solid`
- :class:`~ezdxf.entities.Trace`
- :class:`~ezdxf.entities.Text`
- :class:`~ezdxf.entities.Attrib`
- :class:`~ezdxf.entities.Attdef`
- :class:`~ezdxf.entities.Shape`
- :class:`~ezdxf.entities.Insert`
- :class:`~ezdxf.entities.Polyline` (2D)
- :class:`~ezdxf.entities.Vertex` (2D)
- :class:`~ezdxf.entities.LWPolyline`
- :class:`~ezdxf.entities.Hatch`
- :class:`~ezdxf.entities.Image`

Some of a :class:`~ezdxf.entities.Dimension`'s points are expressed in WCS and
some in OCS.

Elevation
---------

Elevation group code 38:

Exists only in output from versions prior to R11. Otherwise, Z coordinates are
supplied as part of each of the entity's defining points.

.. _Arbitrary Axis Algorithm:

Arbitrary Axis Algorithm
------------------------

- `DXF Reference for Arbitrary Axis Algorithm`_ provided by Autodesk.

The arbitrary axis algorithm is used by AutoCAD internally to implement the
arbitrary but consistent generation of object coordinate systems for all
entities that use object coordinates.

Given a unit-length vector to be used as the z-axis of a coordinate system, the
arbitrary axis algorithm generates a corresponding x-axis for the coordinate
system. The y-axis follows by application of the **right-hand** rule.

We are looking for the arbitrary x- and y-axis to go with the normal Az
(the arbitrary z-axis). They will be called Ax and Ay (using
:class:`~ezdxf.math.Vec3`):

.. code-block:: python

    Az = Vec3(entity.dxf.extrusion).normalize()  # normal (extrusion) vector
    if (abs(Az.x) < 1/64.) and (abs(Az.y) < 1/64.):
         Ax = Vec3(0, 1, 0).cross(Az).normalize()  # the cross-product operator
    else:
         Ax = Vec3(0, 0, 1).cross(Az).normalize()  # the cross-product operator
    Ay = Az.cross(Ax).normalize()


WCS to OCS
----------

.. code-block:: python

    def wcs_to_ocs(point):
        px, py, pz = Vec3(point)  # point in WCS
        x = px * Ax.x + py * Ax.y + pz * Ax.z
        y = px * Ay.x + py * Ay.y + pz * Ay.z
        z = px * Az.x + py * Az.y + pz * Az.z
        return Vec3(x, y, z)

OCS to WCS
----------

.. code-block:: python

    Wx = wcs_to_ocs((1, 0, 0))
    Wy = wcs_to_ocs((0, 1, 0))
    Wz = wcs_to_ocs((0, 0, 1))

    def ocs_to_wcs(point):
        px, py, pz = Vec3(point)  # point in OCS
        x = px * Wx.x + py * Wx.y + pz * Wx.z
        y = px * Wy.x + py * Wy.y + pz * Wy.z
        z = px * Wz.x + py * Wz.y + pz * Wz.z
        return Vec3(x, y, z)

.. seealso::

    - :class:`ezdxf.math.OCS` management class
    - The :meth:`ezdxf.entities.DXFGraphic.ocs` method returns the :class:`~ezdxf.math.OCS`
      of a graphical DXF entity.
    - :ref:`tut_ocs`

.. _DXF Reference for OCS: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-D99F1509-E4E4-47A3-8691-92EA07DC88F5

.. _DXF Reference for Arbitrary Axis Algorithm: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-E19E5B42-0CC7-4EBA-B29F-5E1D595149EE

--- End of file: concepts/ocs.rst ---



--- Start of file: concepts/paperspace.rst ---

.. _paperspace_concept:

Paperspace
==========

A paperspace layout is where the modelspace drawing content is assembled and
organized for 2D output, such as printing on a sheet of paper, or as a digital
document, such as a PDF file.

Each DXF document can have one or more paperspace layouts but the DXF version R12
supports only one paperspace layout and it is not recommended to rely on
paperspace layouts in DXF version R12.

Graphical entities can be added to the paperspace by factory
methods: :ref:`thematic_factory_method_index`. Views or "windows" to the
modelspace are added as :class:`~ezdxf.entities.Viewport` entities, each
viewport displays a region of the modelspace and can have an individual scaling
factor, rotation angle, clipping path, view direction or overridden layer attributes.

.. seealso::

    - Reference of class :class:`~ezdxf.layouts.Paperspace`
    - :ref:`thematic_factory_method_index`
    - Example for usage of paperspace viewports: `viewports_in_paperspace.py`_

.. _`viewports_in_paperspace.py`: https://github.com/mozman/ezdxf/blob/master/examples/viewports_in_paperspace.py


--- End of file: concepts/paperspace.rst ---



--- Start of file: concepts/transparency.rst ---

.. _transparency:

Transparency
============

The support for transparency was added to the DXF file format in revision R2004.
The raw transparency value stored as 32 bit value in the DXF namespace as
:attr:`transparency` attribute, has a range from 0 to 255 where 0 is fully
transparent and 255 if opaque and has the top byte set to ``0x02``.
For a more easy usage all graphical entities support the
:attr:`~ezdxf.entities.DXFGraphic.transparency` property to get and set the
transparency as float value in the range frem 0.0 to 1.0 where 0.0 is opaque and
1.0 is fully transparent. The transparency value can be set explicit in the
entity, by layer or by block.

.. code-block:: Python

    import ezdxf

    doc = ezdxf.new()
    msp = doc.modelspace()
    line = msp.add_line((0, 0), (10, 0))
    line.transparency = 0.5

.. seealso::

    - :mod:`ezdxf.colors`
    - :ref:`tut_common_graphical_attributes`
    - Autodesk Knowledge Network: `About Making Objects Transparent`_
    - BricsCAD Help Center: `Entity Transparency`_

.. _About Making Objects Transparent: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2019/ENU/AutoCAD-Core/files/GUID-E6EB9CA5-B039-4262-BE17-1AD3E7230EF7-htm.html
.. _Entity Transparency: https://help.bricsys.com/document/_guides--BCAD_2D_drafting--GD_transparency/V22/EN_US?id=165079137340


--- End of file: concepts/transparency.rst ---



--- Start of file: concepts/true_color.rst ---

.. _true color:

True Color
==========

The support for true color was added to the DXF file format in revision R2004.
The true color value has three components red, green and blue in the range from
0 to 255 and is stored as a 24-bit value in the DXF namespace as :attr:`true_color`
attribute and looks like this ``0xRRGGBB`` as hex value.
For a more easy usage all graphical entities support the
:attr:`~ezdxf.entities.DXFGraphic.rgb` property to get and set the true color as
(r, g, b) tuples where the components must be in the range from 0 to 255.

.. code-block:: Python

    import ezdxf

    doc = ezdxf.new()
    msp = doc.modelspace()
    line = msp.add_line((0, 0), (10, 0))
    line.rgb = (255, 128, 32)

The true color value has higher precedence than the :ref:`aci` value, if the
attributes :attr:`color` and the :attr:`true_color` are present the entity will
be rendered with the true color value.

The true color value has the advantage that it defines the color absolutely and
unambiguously, no unexpected overwriting is possible.
The representation of the color is fixed and only depends on the calibration of
the output medium:

.. image:: ../gfx/True-Color-Wheel.png

.. seealso::

    - :mod:`ezdxf.colors`
    - :ref:`tut_common_graphical_attributes`
    - Autodesk Knowledge Network: `About Setting the Color of Objects`_
    - BricsCAD Help Center: `Entity Color`_

.. _About Setting the Color of Objects: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2019/ENU/AutoCAD-Core/files/GUID-14BC039D-238D-4D9E-921B-F4015F96CB54-htm.html
.. _Entity Color: https://help.bricsys.com/document/_guides--BCAD_2D_drafting--GD_entitycolor/V22/EN_US?id=165079136935

--- End of file: concepts/true_color.rst ---



--- Start of file: concepts/units.rst ---

.. module:: ezdxf.units

.. _dxf units:

DXF Units
=========

The `DXF reference`_ has no explicit information how to handle units in DXF, any
information in this section is based on experiments with BricsCAD and may differ
in other CAD applications, BricsCAD tries to be as compatible with AutoCAD as
possible. Therefore, this information should also apply to AutoCAD.

Please open an issue on `github`_ if you have any corrections or additional
information about this topic.

Length Units
------------

Any length or coordinate value in DXF is unitless in the first place, there is
no unit information attached to the value. The unit information comes from the
context where a DXF entity is used. The document/modelspace get the unit
information from the header variable $INSUNITS, paperspace and block layouts get
their unit information from the attribute :attr:`~ezdxf.layouts.BaseLayout.units`.
The modelspace object has also a :attr:`units` property, but this value do not
represent the modelspace units, this value is always set to 0 "unitless".

Get and set  document/modelspace units as enum by the
:class:`~ezdxf.document.Drawing` property :attr:`units`:

.. code-block:: python

    import ezdxf
    from ezdxf import units

    doc = ezdxf.new()
    # Set centimeter as document/modelspace units
    doc.units = units.CM
    # which is a shortcut (including validation) for
    doc.header['$INSUNITS'] = units.CM

Block Units
-----------

As said each block definition can have independent units, but there is no
implicit unit conversion applied, not in CAD applications and not in `ezdxf`.

When inserting a block reference (INSERT) into the modelspace or another block
layout with different units, the scaling factor between these units **must** be
applied explicit as DXF attributes (:attr:`xscale`, ...) of the
:class:`~ezdxf.entities.Insert` entity, e.g. modelspace in meters and block in
centimeters, x-, y- and z-scaling has to be 0.01:

.. code-block:: python

    doc.units = units.M
    my_block = doc.blocks.new('MYBLOCK')
    my_block.units = units.CM
    block_ref = msp.add_block_ref('MYBLOCK')
    # Set uniform scaling for x-, y- and z-axis
    block_ref.set_scale(0.01)

Use helper function :func:`conversion_factor` to calculate the
scaling factor between units:

.. code-block:: python

    factor = units.conversion_factor(doc.units, my_block.units)
    # factor = 100 for 1m is 100cm
    # scaling factor = 1 / factor
    block_ref.set_scale(1.0/factor)

.. hint::

    It is never a good idea to use different measurement system in one
    project, ask the NASA about their Mars Climate Orbiter from 1999.
    The same applies for units of the same measurement system, just use one unit
    like meters or inches.


Angle Units
-----------

Angles are always in degrees (360 deg = full circle) in counter-clockwise
orientation, unless stated explicit otherwise.

Display Format
--------------

How values are shown in the CAD GUI is controlled by the header variables
$LUNITS and $AUNITS, but this has no meaning for values stored in DXF files.

$INSUNITS
---------

The most important setting is the header variable $INSUNITS, this variable
defines the drawing units for the modelspace and therefore for the DXF
document if no further settings are applied.

The modelspace LAYOUT entity has a property :attr:`~ezdxf.layouts.BaseLayout.units`
as any layout like object, but it seem to have no meaning for the modelspace,
BricsCAD set this property always to 0, which means unitless.

The most common units are 6 for meters and 1 for inches.

.. code-block:: python


    doc.header['$INSUNITS'] = 6

=== ===============
0   Unitless
1   Inches, :attr:`units.IN`
2   Feet, :attr:`units.FT`
3   Miles, :attr:`units.MI`
4   Millimeters, :attr:`units.MM`
5   Centimeters, :attr:`units.CM`
6   Meters, :attr:`units.M`
7   Kilometers, :attr:`units.KM`
8   Microinches
9   Mils
10  Yards, :attr:`units.YD`
11  Angstroms
12  Nanometers
13  Microns
14  Decimeters, :attr:`units.DM`
15  Decameters
16  Hectometers
17  Gigameters
18  Astronomical units
19  Light years
20  Parsecs
21  US Survey Feet
22  US Survey Inch
23  US Survey Yard
24  US Survey Mile
=== ===============

See also enumeration :class:`ezdxf.enums.InsertUnits`.

$MEASUREMENT
------------

The header variable $MEASUREMENT controls whether the current drawing uses
imperial or metric hatch pattern and linetype files:

This setting is independent from $INSUNITS, it is possible to set the drawing
units to inch and use metric linetypes and hatch pattern.

In BricsCAD the base scaling of linetypes and hatch pattern is defined by
the $MEASUREMENT value, the value of $INSUNITS is ignored.

.. code-block:: python

    doc.header['$MEASUREMENT'] = 1

=== ===============
0   English
1   Metric
=== ===============

See also enumeration :class:`ezdxf.enums.Measurement`

$LUNITS
-------

The header variable $LUNITS defines how CAD applications display linear values
in the GUI and has no meaning for `ezdxf`:

.. code-block:: python

    doc.header['$LUNITS'] = 2

=== ===============
1   Scientific
2   Decimal (default)
3   Engineering
4   Architectural
5   Fractional
=== ===============

See also enumeration :class:`ezdxf.enums.LengthUnits`

$AUNITS
-------

The header variable $AUNITS defines how CAD applications display angular values
in the GUI and has no meaning for `ezdxf`, DXF angles are always stored as
degrees in counter-clockwise orientation, unless stated explicit otherwise:

.. code-block:: python

    doc.header['$AUNITS'] = 0

=== ===============
0   Decimal degrees
1   Degrees/minutes/seconds
2   Grad
3   Radians
=== ===============

See also enumeration :class:`ezdxf.enums.AngularUnits`

Helper Tools
------------

.. autofunction:: conversion_factor

.. autofunction:: unit_name

.. autofunction:: angle_unit_name

.. _github: https://github.com/mozman/ezdxf/issues
.. _DXF reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-235B22E0-A567-4CF6-92D3-38A2306D73F3

--- End of file: concepts/units.rst ---



--- Start of file: const.rst ---

Const
=====

.. module:: ezdxf.lldxf.const

The module :mod:`ezdxf.lldxf.const`, is also accessible from the ``ezdxf``
namespace::

    from ezdxf.lldxf.const import DXF12
    import ezdxf

    print(DXF12)
    print(ezdxf.const.DXF12)

DXF Version Strings
-------------------

======= =========== =======
Name    Version     Alias
======= =========== =======
DXF9    "AC1004"    "R9"
DXF10   "AC1006"    "R10"
DXF12   "AC1009"    "R12"
DXF13   "AC1012"    "R13"
DXF14   "AC1014"    "R14"
DXF2000 "AC1015"    "R2000"
DXF2004 "AC1018"    "R2004"
DXF2007 "AC1021"    "R2007"
DXF2010 "AC1024"    "R2010"
DXF2013 "AC1027"    "R2013"
DXF2018 "AC1032"    "R2018"
======= =========== =======

Exceptions
----------

.. autoclass:: DXFError

.. autoclass:: DXFStructureError(DXFError)

.. autoclass:: DXFVersionError(DXFError)

.. autoclass:: DXFValueError(DXFError)

.. autoclass:: DXFInvalidLineType(DXFValueError)

.. autoclass:: DXFBlockInUseError(DXFValueError)

.. autoclass:: DXFKeyError(DXFError)

.. autoclass:: DXFUndefinedBlockError(DXFKeyError)

.. autoclass:: DXFAttributeError(DXFError)

.. autoclass:: DXFIndexError(DXFError)

.. autoclass:: DXFTypeError(DXFError)

.. autoclass:: DXFTableEntryError(DXFValueError)


--- End of file: const.rst ---



--- Start of file: develop/appdata.rst ---


Application-Defined Data (AppData)
==================================

Starting at DXF R13, DXF objects can contain application-defined codes (AppData)
outside of XDATA.

All AppData is defined with a beginning (102, "{APPID") tag and according to the
DXF reference appear should appear before the first subclass marker.

There are two known use cases of this data structure in Autodesk products:

- ``ACAD_REACTORS``, store handles to persistent reactors in a DXF entity
- ``ACAD_XDICTIONARY``, store handle to the extension dictionary of a DXF entity

Both AppIDs are not defined/stored in the AppID table!

.. module:: ezdxf.entities.appdata

.. class:: AppData

    Internal management class for Application defined data.

    .. seealso::

        - User reference: :ref:`application_defined_data`
        - Internals about :ref:`app_data_internals` tags

    .. automethod:: __contains__

    .. automethod:: __len__

    .. automethod:: add

    .. automethod:: get

    .. automethod:: set

    .. automethod:: discard


--- End of file: develop/appdata.rst ---



--- Start of file: develop/doc_formatting_guide.rst ---

.. sphinx comments

Formatting Guide
================

This section is only for `myself <https://github.com/mozman>`_, because of the
long pauses between develop iterations, I often forget to be consistent in
documentation formatting.

Documentation is written with `Sphinx`_ and `reSturcturedText`_.

Started integration of documentation into source code and using `autodoc`_
features of `Sphinx`_ wherever useful.

.. inline link

Sphinx theme provided by `Read the Docs <https://readthedocs.org>`_ : ::

    pip install sphinx-rtd-theme


:mod:`guide` --- Example module
-------------------------------

.. module:: guide
    :synopsis: Example for documentation formatting

.. function:: example_func(a:int, b:str, test:str=None, flag:bool=True) -> None

    Parameters `a` and `b` are positional arguments, argument `test` defaults
    to ``None`` and `flag` to ``True``.
    Set `a` to 70 and `b` to "x" as an example. Inline code examples
    :code:`example_func(70, 'x')` or simple ``example_func(70, "x")``

        - arguments: `a`, `b`, `test` and `flags`
        - literal number values: 1, 2 ... 999
        - literal string values: "a String"
        - literal tags: (5, "F000")
        - inline code: call a :code:`example_func(x)`
        - Python keywords: ``None``, ``True``, ``False``, ``tuple``, ``list``, ``dict``, ``str``, ``int``, ``float``
        - Exception classes: :class:`DXFAttributeError`

.. class:: ExampleCls(**kwargs)

    The :class:`ExampleCls` constructor accepts a number of optional keyword
    arguments.  Each keyword argument corresponds to an instance attribute, so
    for example ::

        e = ExampleCls(flag=True)


    .. attribute:: flag

        This is the attribute :attr:`flag`.

    .. method:: set_axis(axis)

        axis as (x, y, z) tuple

        Args:
            axis: (x, y, z) tuple

    .. method:: example_method(flag:bool=False)->None

        Method :meth:`example_method` of class :class:`ExampleCls`

Text Formatting
---------------

DXF version
    DXF R12 (AC1009), DXF R2004 (AC1018)

DXF Types
    DXF types are always written in uppercase letters but without further formatting: DXF, LINE, CIRCLE

(internal API)
    Marks methods as internal API, gets no public documentation.

(internal class)
    Marks classes only for internal usage, gets not public documentation.

Spatial Dimensions
    2D and 3D with an uppercase letter D

Axis
    x-axis, y-axis and z-axis

Planes
    xy-plane, xz-plane, yz-plane

Layouts
    modelspace, paperspace [layout], block [layout]

Extended Entity Data
    AppData, XDATA, embedded object, APPID

.. _Sphinx: http://www.sphinx-doc.org/en/master/
.. _autodoc: http://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html#module-sphinx.ext.autodoc
.. _reSturcturedText: http://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html

--- End of file: develop/doc_formatting_guide.rst ---



--- Start of file: develop/dxftag_collections.rst ---

.. automodule:: ezdxf.lldxf.tags

.. class:: Tags

    Subclass of ``list``.

    Collection of :class:`~ezdxf.lldxf.types.DXFTag` as flat list. Low level tag container, only required for advanced
    stuff.

    .. automethod:: from_text(text: str) -> Tags

    .. automethod:: dxftype

    .. automethod:: get_handle

    .. automethod:: replace_handle

    .. automethod:: has_tag

    .. automethod:: has_embedded_objects

    .. automethod:: get_first_tag(code: int, default=DXFValueError) -> DXFTag

    .. automethod:: get_first_value(code: int, default=DXFValueError) -> Any

    .. automethod:: find_all(code: int) -> List[DXFTag]

    .. automethod:: filter(codes: Iterable[int]) -> Iterable[DXFTag]

    .. automethod:: collect_consecutive_tags(codes: Iterable[int], start: int = 0, end: int = None) -> Tags

    .. automethod:: tag_index

    .. automethod:: update(tag: DXFTag)

    .. automethod:: set_first(tag: DXFTag)

    .. automethod:: remove_tags

    .. automethod:: remove_tags_except

    .. automethod:: pop_tags(codes: Iterable[int]) -> Iterable[DXFTag]

    .. automethod:: strip(tags: Tags, codes: Iterable[int]) -> Tags

.. autofunction:: group_tags(tags: Iterable[DXFTag], splitcode: int = 0) -> Iterable[Tags]


.. module:: ezdxf.lldxf.extendedtags

.. class:: ExtendedTags(tags: Iterable[DXFTag]=None, legacy=False)

    Represents the extended DXF tag structure introduced with DXF R13.

    Args:
        tags: iterable of :class:`~ezdxf.lldxf.types.DXFTag`
        legacy: flag for DXF R12 tags

    .. attribute:: appdata

        Application defined data as list of :class:`Tags`

    .. attribute:: subclasses

        Subclasses as list of :class:`Tags`

    .. attribute:: xdata

        XDATA as list of :class:`Tags`

    .. attribute:: embedded_objects

        embedded objects as list of :class:`Tags`

    .. autoattribute:: noclass

    .. automethod:: get_handle

    .. automethod:: dxftype

    .. automethod:: replace_handle

    .. automethod:: legacy_repair

    .. automethod:: clone() -> ExtendedTags

    .. automethod:: flatten_subclasses

    .. automethod:: get_subclass(name: str, pos: int = 0) -> Tags

    .. automethod:: has_xdata

    .. automethod:: get_xdata(appid: str) -> Tags

    .. automethod:: set_xdata

    .. automethod:: new_xdata(appid: str, tags: 'IterableTags' = None) -> Tags

    .. automethod:: has_app_data

    .. automethod:: get_app_data(appid: str) -> Tags

    .. automethod:: get_app_data_content(appid: str) -> Tags

    .. automethod:: set_app_data_content

    .. automethod:: new_app_data(appid: str, tags: 'IterableTags' = None, subclass_name: str = None) -> Tags

    .. automethod:: from_text(text: str, legacy: bool = False) -> ExtendedTags


.. module:: ezdxf.lldxf.packedtags

Packed DXF Tags
---------------

Store DXF tags in compact data structures as ``list`` or :class:`array.array` to reduce memory usage.

.. class:: TagList(data: Iterable = None)

    Store data in a standard Python ``list``.

    Args:
        data: iterable of DXF tag values.

    .. attribute:: values

        Data storage as ``list``.

    .. automethod:: clone() -> TagList

    .. automethod:: from_tags(tags: Tags, code: int) -> TagList

    .. automethod:: clear

.. class:: TagArray(data: Iterable = None)

    :class:`TagArray` is a subclass of :class:`TagList`, which store data in an :class:`array.array`.
    Array type is defined by class variable ``DTYPE``.

    Args:
        data: iterable of DXF tag values.

    .. attribute:: DTYPE

        :class:`array.array` type as string

    .. attribute:: values

        Data storage as :class:`array.array`

    .. automethod:: set_values

.. class:: VertexArray(data: Iterable = None)

    Store vertices in an ``array.array('d')``.
    Vertex size is defined by class variable :attr:`VERTEX_SIZE`.

    Args:
        data: iterable of vertex values as linear list e.g. :code:`[x1, y1, x2, y2, x3, y3, ...]`.

    .. attribute:: VERTEX_SIZE

        Size of vertex (2 or 3 axis).

    .. automethod:: __len__

    .. automethod:: __getitem__

    .. automethod:: __setitem__

    .. automethod:: __delitem__

    .. automethod:: __iter__

    .. automethod:: __str__

    .. automethod:: insert

    .. automethod:: append

    .. automethod:: extend

    .. automethod:: set

    .. automethod:: clear

    .. automethod:: clone() -> VertexArray

    .. automethod:: from_tags(tags: Iterable[DXFTag], code: int = 10) -> VertexArray

    .. automethod:: export_dxf



--- End of file: develop/dxftag_collections.rst ---



--- Start of file: develop/dxftags.rst ---

.. automodule:: ezdxf.lldxf.types

DXFTag Factory Functions
========================

.. autofunction:: dxftag

.. autofunction:: tuples_to_tags


DXFTag
======

.. autoclass:: DXFTag
    :members: __str__, __repr__, __getitem__, __iter__, __eq__, __hash__, dxfstr, clone

    .. attribute:: code

        group code as int (do not change)

    .. attribute:: value

        tag value (read-only property)

DXFBinaryTag
============

.. autoclass:: DXFBinaryTag(DXFTag)
    :members:

DXFVertex
=========

.. autoclass:: DXFVertex(DXFTag)
    :members:


NONE_TAG
========

.. attribute:: NONE_TAG

    Special tag representing a none existing tag.


--- End of file: develop/dxftags.rst ---



--- Start of file: develop/entitydb.rst ---

.. module:: ezdxf.entitydb

Entity Database
===============

The :class:`EntityDB` is a simple key/value database to store
:class:`~ezdxf.entities.DXFEntity` objects by it's handle,
every :class:`~ezdxf.document.Drawing` has its own :class:`EntityDB`, stored in
the :class:`Drawing` attribute :attr:`~ezdxf.document.Drawing.entitydb`.

Every DXF entity/object, except tables and sections, are represented as
:class:`DXFEntity` or inherited types, this entities are stored in the
:class:`EntityDB`, database-key is the :attr:`dxf.handle` as plain hex
string.

All iterators like :meth:`keys`, :meth:`values`, :meth:`items` and :meth:`__iter__`
do not yield destroyed entities.

.. warning::

    The :meth:`get` method and the index operator ``[]``, return destroyed
    entities and entities from the trashcan.

.. class:: EntityDB

    .. automethod:: __getitem__(handle: str) -> DXFEntity

    .. automethod:: __setitem__(handle: str, entity: DXFEntity) -> None

    .. automethod:: __delitem__

    .. automethod:: __contains__(item: Union[str, DXFEntity]) -> bool

    .. automethod:: __len__

    .. automethod:: __iter__

    .. automethod:: get(handle: str) -> Optional[DXFEntity]

    .. automethod:: next_handle

    .. automethod:: keys

    .. automethod:: values() -> Iterable[DXFEntity]

    .. automethod:: items()  -> Iterable[Tuple[str, DXFEntity]]

    .. automethod:: add(entity: DXFEntity) -> None

    .. automethod:: new_trashcan

    .. automethod:: trashcan

    .. automethod:: purge

    .. automethod:: query

Entity Space
============

.. autoclass:: EntitySpace

    .. automethod:: __iter__() -> Iterable[DXFEntity]

    .. automethod:: __getitem__(index) -> DXFEntity

    .. automethod:: __len__

    .. automethod:: has_handle

    .. automethod:: purge

    .. automethod:: add(entity: DXFEntity) -> None

    .. automethod:: extend(entities: Iterable[DXFEntity]) -> None

    .. automethod:: remove(entity: DXFEntity) -> None

    .. automethod:: clear

--- End of file: develop/entitydb.rst ---



--- Start of file: develop/index.rst ---

.. _Developer Guides:

Developer Guides
================

Information about `ezdxf` internals.

Source Code Formatting
----------------------

Reformat code by `Black`_ with the default setting of 88 characters per line::

    C:\> black <python-file>


Type Annotations
----------------

The use of type annotations is encouraged. New modules should pass `mypy`_
without errors in non-strict mode. Using ``# type: ignore`` is fine in tricky
situations - type annotations should be helpful in understanding the code
and not be a burden.

The following global options are required to pass `mypy`_ without error
messages:

.. code-block:: ini

    [mypy]
    python_version = 3.7
    ignore_missing_imports = True

Read `this <https://mypy.readthedocs.io/en/stable/config_file.html>`_ to learn
where `mypy`_ searches for config files.

Use the `mypy`_ command line option ``--ignore-missing-imports`` and ``-p`` to
check the whole package from any location in the file system:

.. code-block:: Powershell

    PS D:\Source\ezdxf.git> mypy --ignore-missing-imports -p ezdxf
    Success: no issues found in 255 source files

Design
------

The :ref:`pkg-design` section shows the structure of the `ezdxf` package for
developers with more experience, which want to have more insight into the
package an maybe want to develop add-ons or want contribute to the `ezdxf`
package.

.. toctree::
    :maxdepth: 2

    pkg-design


Internal Data Structures
------------------------

.. toctree::
    :maxdepth: 2

    entitydb
    dxftags
    dxftag_collections
    xdata
    appdata
    reactors

Documentation Guide
-------------------

.. toctree::
    :maxdepth: 1

    doc_formatting_guide

.. _Black: https://pypi.org/project/black/
.. _mypy: https://pypi.org/project/mypy/

--- End of file: develop/index.rst ---



--- Start of file: develop/pkg-design.rst ---

**!!! UNDER CONSTRUCTION !!!**

.. _pkg-design:

Package Design for Developers
=============================

.. Overall Design:

A DXF document is divided into several sections, this sections are managed by
the :class:`~ezdxf.drawing.Drawing` object. For each section exist a
corresponding attribute in the :class:`Drawing` object:

======== ==========================
Section  Attribute
======== ==========================
HEADER   :attr:`Drawing.header`
CLASSES  :attr:`Drawing.classes`
TABLES   :attr:`Drawing.tables`
BLOCKS   :attr:`Drawing.blocks`
ENTITIES :attr:`Drawing.entities`
OBJECTS  :attr:`Drawing.objects`
======== ==========================

Resource entities (LAYER, STYLE, LTYPE, ...) are stored in tables in the
TABLES section. A table owns the table entries, the owner handle of table
entry is the handle of the table. Each table has a shortcut in the
:class:`Drawing` object:

============ ==========================
Table        Attribute
============ ==========================
APPID        :attr:`Drawing.appids`
BLOCK_RECORD :attr:`Drawing.block_records`
DIMSTYLE     :attr:`Drawing.dimstyles`
LAYER        :attr:`Drawing.layers`
LTYPE        :attr:`Drawing.linetypes`
STYLE        :attr:`Drawing.styles`
UCS          :attr:`Drawing.ucs`
VIEW         :attr:`Drawing.views`
VPORT        :attr:`Drawing.viewports`
============ ==========================

Graphical entities are stored in layouts:
:class:`~ezdxf.layouts.Modelspace`, :class:`~ezdxf.layouts.Paperspace` layouts
and :class:`~ezdxf.layouts.BlockLayout`.
The core management object of this layouts is the BLOCK_RECORD entity
(:class:`~ezdxf.entities.BlockRecord`),
the BLOCK_RECORD is the real owner of the entities,
the owner handle of the entities is the handle of the BLOCK_RECORD and the
BLOCK_RECORD also owns and manages the entity space of the layout which
contains all entities of the layout.

For more information about layouts
see also: :ref:`Layout Management Structures`

For more information about blocks
see also: :ref:`Block Management Structures`

Non-graphical entities (objects) are stored in the OBJECTS section.
Every object has a parent object in the OBJECTS section, most likely a
DICTIONARY object, and is stored in the entity space of the OBJECTS section.

For more information about the OBJECTS section
see also: :ref:`objects_section_internals`

All table entries, DXF entities and DXF objects are stored in the entities
database accessible as :attr:`Drawing.entitydb`. The entity database is a simple
key, value storage, key is the entity handle, value is the DXF object.

For more information about the DXF data model
see also: :ref:`Data Model`

Terminology
+++++++++++

States
------

DXF entities and objects can have different states:

UNBOUND
    Entity is not stored in the :class:`Drawing` entity database and
    DXF attribute :attr:`handle` is ``None`` and
    attribute :attr:`doc` can be ``None``

BOUND
    Entity is stored in the :class:`Drawing` entity database,
    attribute :attr:`doc` has a reference to :class:`Drawing` and
    DXF attribute :attr:`handle` is not ``None``

UNLINKED
    Entity is not linked to a layout/owner,
    DXF attribute :attr:`owner` is ``None``

LINKED
    Entity is linked to a layout/owner,
    DXF attribute :attr:`owner` is not ``None``

Virtual Entity
    State: UNBOUND & UNLINKED

Unlinked Entity
    State: BOUND & UNLINKED

Bound Entity
    State: BOUND & LINKED

Actions
-------

NEW
    Create a new DXF document

LOAD
    Load a DXF document from an external source

CREATE
    Create DXF structures from NEW or LOAD data

DESTROY
    Delete DXF structures

BIND
    Bind an entity to a :class:`Drawing`, set entity state to BOUND &
    UNLINKED and check or create required resources

UNBIND
    unbind ...

LINK
    Link an entity to an owner/layout.
    This makes an entity to a real DXF entity, which will be exported
    at the saving process. Any DXF entity can only be linked to **one** parent
    entity like DICTIONARY or BLOCK_RECORD.

UNLINK
    unlink ...


Loading a DXF Document
++++++++++++++++++++++

Loading a DXF document from an external source, creates a new
:class:`Drawing` object. This loading process has two stages:

First Loading Stage
-------------------

- LOAD content from external source as :class:`SectionDict`:
  :func:`loader.load_dxf_structure`
- LOAD tag structures as :class:`DXFEntity` objects:
  :func:`loader.load_dxf_entities`
- BIND entities: :func:`loader.load_and_bind_dxf_content`;
  Special handling of the BIND process, because the :class:`Drawing` is not full
  initialized, a complete validation is not possible at this stage.

Second Loading Stage
--------------------

Parse :class:`SectionDict`:

- CREATE sections: HEADER, CLASSES, TABLES, BLOCKS and OBJECTS
- CREATE layouts: Blocks, Layouts
- LINK entities to a owner/layout

The ENTITIES section is a relict from older DXF versions and has to be exported
including the modelspace and active paperspace entities, but all entities
reside in a BLOCK definition, even modelspace and paperspace layouts are only
BLOCK definitions and ezdxf has no explicit ENTITIES section.

Source Code: as developer start your journey at :meth:`ezdxf.document.Drawing.read`,
which has no public documentation, because package-user should use
:func:`ezdxf.read` and :func:`ezdxf.readfile`.

New DXF Document
++++++++++++++++

Creating New DXF Entities
+++++++++++++++++++++++++

The default constructor of each entity type creates a new virtual entity:

- DXF attribute `owner` is ``None``
- DXF attribute `handle` is ``None``
- Attribute `doc` is ``None``

The :meth:`DXFEntity.new` constructor creates entities with given `owner`,
`handle` and `doc` attributes, if `doc` is not ``None`` and entity is not
already bound to a document, the :meth:`new` constructor automatically bind the
entity to the given document `doc`.

There exist only two scenarios:

1. UNBOUND: `doc` is ``None`` and `handle` is ``None``
2. BOUND: `doc` is not ``None`` and `handle` is not ``None``

Factory functions
+++++++++++++++++

- :func:`new`, create a new virtual DXF object/entity
- :func:`load`, load (create) virtual DXF object/entity from DXF tags
- :func:`bind`, bind an entity to a document, create required
  resources if necessary (e.g. ImageDefReactor, SEQEND) and raise exceptions for
  non-existing resources.

  - Bind entity loaded from an external source to a document, all referenced
    resources must exist, but try to repair as many flaws as possible because
    errors were created by another application and are not the responsibility
    of the package-user.

  - Bind an entity from another DXF document, all invalid resources will be
    removed silently or created (e.g. SEQEND). This is a simple import from
    another document without resource import, for a more advanced import
    including resources exist the :mod:`importer` add-on.

  - Bootstrap problem for binding loaded table entries and objects in the OBJECTS
    section! Can't use :class:`Auditor` to repair this objects, because the DXF
    document is not fully initialized.

- :func:`is_bound` returns True if `entity` is bound to document `doc`
- :func:`unbind` function to remove an entity from a document and set state
  to a virtual entity, which should also `UNLINK` the entity from layout,
  because an layout can not store a virtual entity.
- :func:`cls`, returns the class
- :func:`register_entity`, registration decorator
- :func:`replace_entity`, registration decorator

Class Interfaces
++++++++++++++++

DXF Entities
------------

- NEW constructor to create an entity from scratch
- LOAD constructor to create an entity loaded from an external source
- DESTROY interface to kill an entity, set entity state to `dead`, which
  means :attr:`entity.is_alive` returns False. All entity iterators like
  :class:`EntitySpace`, :class:`EntityQuery`,  and :class:`EntityDB` must
  filter (ignore) `dead` entities.
  Calling :func:`DXFEntity.destroy()` is a regular way to delete entities.
- LINK an entity to a layout by :meth:`BlockRecord.link`, which set the `owner`
  handle to BLOCK_RECORD handle (= layout key) and add the entity to the entity
  space of the BLOCK_RECORD and set/clear the paperspace flag.

DXF Objects
-----------

- NEW, LOAD, DESTROY see DXF entities
- LINK: Linking an DXF object means adding the entity to a parent object in the
  OBJECTS section, most likely a DICTIONARY object, and adding the object to the
  entity space of the OBJECTS section, the root-dict is the only entity in the
  OBJECTS section which has an invalid owner handle "0". Any other object with
  an invalid or destroyed owner is an orphaned entity.
  The audit process destroys and removes orphaned objects.
- Extension dictionaries (ACAD_XDICTIONARY) are DICTIONARY objects
  located in the OBJECTS sections and can reference/own other entities of the
  OBJECTS section.
- The root-dictionary is the only entity in the OBJECTS section which has an
  invalid owner handle "0". Any other object with an invalid or destroyed owner
  is an orphaned entity.

Layouts
-------

- LINK interface to link an entity to a layout
- UNLINK interface to remove an entity from a layout

Database
--------

- BIND interface to add an entity to the database of a document
- :func:`delete_entity` interface, same as UNBIND and DESTROY an entity


--- End of file: develop/pkg-design.rst ---



--- Start of file: develop/reactors.rst ---


.. module:: ezdxf.entities.appdata
    :noindex:


Reactors
========

.. class:: Reactors

    Internal management class for persistent reactor handles. Handles are stored
    as hex strings like ``"ABBA"``.

    .. seealso::

        - User reference: :ref:`reactors`
        - Internals about :ref:`reactors_internals` tags

    .. automethod:: __contains__

    .. automethod:: __len__

    .. automethod:: __iter__

    .. automethod:: add

    .. automethod:: get

    .. automethod:: set

    .. automethod:: discard


--- End of file: develop/reactors.rst ---



--- Start of file: develop/xdata.rst ---

XData
=====

.. module:: ezdxf.entities.xdata

.. class:: XData

    Internal management class for XDATA.

    .. seealso::

        - XDATA user reference: :ref:`extended_data`
        - Wrapper class to store a list in XDATA: :class:`XDataUserList`
        - Wrapper class to store a dict in XDATA: :class:`XDataUserDict`
        - Tutorial: :ref:`tut_custom_data`
        - DXF Internals: :ref:`xdata_internals`
        - `DXF R2018 Reference <https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A2A628B0-3699-4740-A215-C560E7242F63>`_

    .. automethod:: __contains__

    .. automethod:: add

    .. automethod:: get

    .. automethod:: discard

    .. automethod:: has_xlist

    .. automethod:: get_xlist

    .. automethod:: set_xlist

    .. automethod:: discard_xlist

    .. automethod:: replace_xlist

    .. automethod:: transform(m: Matrix44) -> None

--- End of file: develop/xdata.rst ---



--- Start of file: disassemble.rst ---

Disassemble
===========

.. module:: ezdxf.disassemble

This module provide tools for the recursive decomposition of nested block
reference structures into a flat stream of DXF entities and converting DXF
entities into geometric primitives of :class:`~ezdxf.path.Path` and
:class:`~ezdxf.render.mesh.MeshBuilder` objects encapsulated into
intermediate :class:`Primitive` classes.

.. warning::

    Do not expect advanced vectorization capabilities: Text entities like TEXT,
    ATTRIB, ATTDEF and MTEXT get only a rough border box representation.
    The :mod:`~ezdxf.addons.text2path` add-on can convert text into paths.
    VIEWPORT, IMAGE and WIPEOUT are represented by their clipping path.
    Unsupported entities: all ACIS based entities, XREF, UNDERLAY, ACAD_TABLE,
    RAY, XLINE. Unsupported entities will be ignored.

.. _Text Boundary Calculation:

Text Boundary Calculation
-------------------------

Text boundary calculations are based on monospaced (fixed-pitch, fixed-width,
non-proportional) font metrics, which do not provide a good accuracy for text
height calculation and much less accuracy for text width calculation. It is
possible to improve this results by using the font support from the
**optional**  `Matplotlib` package.

Install Matplotlib from command line::

    C:\> pip3 install matplotlib

The `Matplotlib` font support will improve the results for TEXT, ATTRIB and
ATTDEF. The MTEXT entity has many advanced features which would require a full
"Rich Text Format" rendering and that is far beyond the goals and capabilities
of this library, therefore the boundary box for MTEXT will **never** be as
accurate as in a dedicated CAD application.

Using the `Matplotlib` font support adds **runtime overhead**, therefore it is
possible to deactivate the `Matplotlib` font support by setting the
global option::

    options.use_matplotlib_font_support = False


Flatten Complex DXF Entities
----------------------------

.. autofunction:: recursive_decompose

Entity Deconstruction
---------------------

These functions disassemble DXF entities into simple geometric objects
like meshes, paths or vertices. The :class:`Primitive` is a simplified
intermediate class to use a common interface on various DXF entities.

.. autofunction:: make_primitive

.. autofunction:: to_primitives

.. autofunction:: to_meshes

.. autofunction:: to_paths

.. autofunction:: to_vertices

.. autofunction:: to_control_vertices

.. class:: Primitive

    Interface class for path/mesh primitives.

    .. attribute:: entity

    Reference to the source DXF entity of this primitive.

    .. attribute:: max_flattening_distance

    The `max_flattening_distance` attribute defines the max distance in drawing
    units between the approximation line and the original curve.
    Set the value by direct attribute access. (float) default = 0.01

    .. autoproperty:: path

    .. autoproperty:: mesh

    .. autoproperty:: is_empty

    .. automethod:: vertices

    .. automethod:: bbox


--- End of file: disassemble.rst ---



--- Start of file: drawing/drawing.rst ---

Drawing Class
=============

.. module:: ezdxf.document

The :class:`Drawing` class is the central management structure of a DXF document.

Access Layouts
--------------

- :meth:`Drawing.modelspace`
- :meth:`Drawing.paperspace`

Access Resources
----------------

- Application ID Table: :attr:`Drawing.appids`
- Block Definition Table: :attr:`Drawing.blocks`
- Dimension Style Table: :attr:`Drawing.dimstyles`
- Layer Table: :attr:`Drawing.layers`
- Linetype Table: :attr:`Drawing.linetypes`
- MLeader Style Table: :attr:`Drawing.mleader_styles`
- MLine Style Table: :attr:`Drawing.mline_styles`
- Material Table: :attr:`Drawing.materials`
- Text Style Table: :attr:`Drawing.styles`
- UCS Table: :attr:`Drawing.ucs`
- VPort Table: :attr:`Drawing.viewports`
- View Table: :attr:`Drawing.views`

- Classes Section: :attr:`Drawing.classes`
- Object Section: :attr:`Drawing.objects`

- Entity Database: :attr:`Drawing.entitydb`
- Entity Groups: :attr:`Drawing.groups`
- Header Variables: :attr:`Drawing.header`


Drawing Class
-------------

.. class:: Drawing

    The :class:`Drawing` class is the central management structure of a DXF document.

    .. attribute:: dxfversion

        Actual DXF version like ``'AC1009'``, set by :func:`ezdxf.new` or
        :func:`ezdxf.readfile`.

        For supported DXF versions see :ref:`dwgmanagement`

    .. attribute:: acad_release

        The AutoCAD release name like ``'R12'`` or ``'R2000'`` for actual
        :attr:`dxfversion`.

    .. attribute:: encoding

        Text encoding of :class:`Drawing`, the default encoding for new drawings
        is ``'cp1252'``. Starting with DXF R2007 (AC1021), DXF files are written
        as UTF-8 encoded text files, regardless of the attribute
        :attr:`encoding`.
        The text encoding can be changed to encodings listed below.

        see also: :ref:`dxf file encoding`

        ============ =================
        supported    encodings
        ============ =================
        ``'cp874'``  Thai
        ``'cp932'``  Japanese
        ``'gbk'``    UnifiedChinese
        ``'cp949'``  Korean
        ``'cp950'``  TradChinese
        ``'cp1250'`` CentralEurope
        ``'cp1251'`` Cyrillic
        ``'cp1252'`` WesternEurope
        ``'cp1253'`` Greek
        ``'cp1254'`` Turkish
        ``'cp1255'`` Hebrew
        ``'cp1256'`` Arabic
        ``'cp1257'`` Baltic
        ``'cp1258'`` Vietnam
        ============ =================

    .. attribute:: output_encoding

        Returns required output encoding for saving to filesystem or encoding
        to binary data.

    .. attribute:: filename

        :class:`Drawing` filename, if loaded by :func:`ezdxf.readfile` else ``None``.

    .. attribute:: rootdict

        Reference to the root dictionary of the OBJECTS section.


    .. attribute:: header

        Reference to the :class:`~ezdxf.sections.header.HeaderSection`, get/set
        drawing settings as header variables.

    .. attribute:: entities

        Reference to the :class:`EntitySection` of the drawing, where all
        graphical entities are stored, but only from modelspace and the
        *active* paperspace layout. Just for your information: Entities of other
        paperspace layouts are stored as :class:`~ezdxf.layouts.BlockLayout`
        in the :class:`~ezdxf.sections.blocks.BlocksSection`.

    .. attribute:: objects

        Reference to the objects section, see also :class:`~ezdxf.sections.objects.ObjectsSection`.

    .. attribute:: blocks

        Reference to the blocks section, see also :class:`~ezdxf.sections.blocks.BlocksSection`.

    .. attribute:: tables

        Reference to the tables section, see also :class:`~ezdxf.sections.tables.TablesSection`.

    .. attribute:: classes

        Reference to the classes section, see also :class:`~ezdxf.sections.classes.ClassesSection`.

    .. attribute:: layouts

        Reference to the layout manager, see also :class:`~ezdxf.layouts.Layouts`.

    .. attribute:: groups

        Collection of all groups, see also :class:`~ezdxf.entities.dxfgroups.GroupCollection`.

        requires DXF R13 or later

    .. attribute:: layers

        Shortcut for :attr:`Drawing.tables.layers`

        Reference to the layers table, where you can create, get and
        remove layers, see also :class:`~ezdxf.sections.table.Table` and
        :class:`~ezdxf.entities.Layer`

    .. attribute:: styles

        Shortcut for :attr:`Drawing.tables.styles`

        Reference to the styles table, see also :class:`~ezdxf.entities.Textstyle`.

    .. attribute:: dimstyles

        Shortcut for :attr:`Drawing.tables.dimstyles`

        Reference to the dimstyles table, see also :class:`~ezdxf.entities.DimStyle`.

    .. attribute:: linetypes

        Shortcut for :attr:`Drawing.tables.linetypes`

        Reference to the linetypes table, see also :class:`~ezdxf.entities.Linetype`.

    .. attribute:: views

        Shortcut for :attr:`Drawing.tables.views`

        Reference to the views table, see also :class:`~ezdxf.entities.View`.

    .. attribute:: viewports

        Shortcut for :attr:`Drawing.tables.viewports`

        Reference to the viewports table, see also :class:`~ezdxf.entities.VPort`.

    .. attribute:: ucs

        Shortcut for :attr:`Drawing.tables.ucs`

        Reference to the ucs table, see also :class:`~ezdxf.entities.UCSTableEntry`.

    .. attribute:: appids

        Shortcut for :attr:`Drawing.tables.appids`

        Reference to the appids table, see also :class:`~ezdxf.entities.AppID`.

    .. attribute:: materials

        :class:`~ezdxf.entities.MaterialCollection` of all
        :class:`~ezdxf.entities.Material` objects.

    .. attribute:: mline_styles

        :class:`~ezdxf.entities.MLineStyleCollection` of all
        :class:`~ezdxf.entities.MLineStyle` objects.

    .. attribute:: mleader_styles

        :class:`~ezdxf.entities.MLeaderStyleCollection` of all
        :class:`~ezdxf.entities.MLeaderStyle` objects.

    .. autoattribute:: units

    .. autoattribute:: get_abs_filepath

    .. automethod:: save

    .. automethod:: saveas

    .. automethod:: write

    .. automethod:: encode_base64

    .. automethod:: encode

    .. automethod:: query

    .. automethod:: groupby

    .. automethod:: modelspace

    .. automethod:: paperspace

    .. automethod:: layout

    .. automethod:: active_layout

    .. automethod:: layout_names

    .. automethod:: layout_names_in_taborder

    .. automethod:: new_layout

    .. automethod:: page_setup

    .. automethod:: delete_layout

    .. automethod:: add_image_def

    .. automethod:: set_raster_variables

    .. automethod:: set_wipeout_variables

    .. automethod:: add_underlay_def

    .. automethod:: add_xref_def

    .. automethod:: layouts_and_blocks

    .. automethod:: chain_layouts_and_blocks

    .. automethod:: reset_fingerprint_guid

    .. automethod:: reset_version_guid

    .. automethod:: set_modelspace_vport

    .. automethod:: audit

    .. automethod:: validate

    .. automethod:: ezdxf_metadata


--- End of file: drawing/drawing.rst ---



--- Start of file: drawing/management.rst ---

.. _dwgmanagement:

Document Management
===================

Create New Drawings
-------------------

.. autofunction:: ezdxf.new(dxfversion='AC1027', setup=False, units=6) -> Drawing

Open Drawings
-------------

Open DXF drawings from file system or text stream, byte stream usage is not supported.

DXF files prior to R2007 requires file encoding defined by header variable $DWGCODEPAGE, DXF R2007 and later
requires an UTF-8 encoding.

`ezdxf` supports reading of files for following DXF versions:

=========== ========== ============== ===================================
Version     Release    Encoding       Remarks
=========== ========== ============== ===================================
< AC1009               $DWGCODEPAGE   pre AutoCAD R12 upgraded to AC1009
AC1009      R12        $DWGCODEPAGE   AutoCAD R12
AC1012      R13        $DWGCODEPAGE   AutoCAD R13 upgraded to AC1015
AC1014      R14        $DWGCODEPAGE   AutoCAD R14 upgraded to AC1015
AC1015      R2000      $DWGCODEPAGE   AutoCAD R2000
AC1018      R2004      $DWGCODEPAGE   AutoCAD R2004
AC1021      R2007      UTF-8          AutoCAD R2007
AC1024      R2010      UTF-8          AutoCAD R2010
AC1027      R2013      UTF-8          AutoCAD R2013
AC1032      R2018      UTF-8          AutoCAD R2018
=========== ========== ============== ===================================

.. autofunction:: ezdxf.readfile

.. autofunction:: ezdxf.read

.. autofunction:: ezdxf.readzip

.. autofunction:: ezdxf.decode_base64

.. hint::

    This works well with DXF files from trusted sources like AutoCAD or BricsCAD,
    for loading DXF files with minor or major flaws look at the
    :mod:`ezdxf.recover` module.

Save Drawings
-------------

Save the DXF document to the file system by :class:`~ezdxf.document.Drawing` methods
:meth:`~ezdxf.document.Drawing.save` or :meth:`~ezdxf.document.Drawing.saveas`.
Write the DXF document to a text stream with :meth:`~ezdxf.document.Drawing.write`,
the text stream requires at least a :meth:`write` method. Get required output
encoding for text streams by property :attr:`Drawing.output_encoding`

.. _globaloptions:

Drawing Settings
----------------

The :class:`~ezdxf.sections.header.HeaderSection` stores meta data like modelspace extensions, user name or saving time
and current application settings, like actual layer, text style or dimension style settings. These settings are not
necessary to process DXF data and therefore many of this settings are not maintained by `ezdxf` automatically.

Header variables set at new
~~~~~~~~~~~~~~~~~~~~~~~~~~~

================ =================================
$ACADVER         DXF version
$TDCREATE        date/time at creating the drawing
$FINGERPRINTGUID every drawing gets a GUID
================ =================================

Header variables updated at saving
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

================ =================================
$TDUPDATE        actual date/time at saving
$HANDSEED        next available handle as hex string
$DWGCODEPAGE     encoding setting
$VERSIONGUID     every saved version gets a new GUID
================ =================================

.. seealso::

    - Howto: :ref:`set/get header variables`
    - Howto: :ref:`set drawing units`

.. _ezdxf_metadata:

Ezdxf Metadata
~~~~~~~~~~~~~~

Store internal metadata like *ezdxf* version and creation time for
a new created document as metadata in the DXF file. Only standard DXF features
are used to store meta data and this meta data is preserved by Autodesk products,
BricsCAD and of course *ezdxf*. Other 3rd party DXF libraries may remove this
meta data.

For DXF R12 the meta data is stored as XDATA by AppID ``EZDXF`` in the model
space BLOCK entity in the BLOCKS section.

For DXF R2000+ the meta data is stored in the "root" DICTIONARY in the
OBJECTS section as a DICTIONARY object by the key ``EZDXF_META``.


The :class:`MetaData` object has a dict-like interface and can also store
custom metadata::

    metadata = doc.ezdxf_metadata()

    # set data
    metadata["MY_CUSTOM_META_DATA"] = "a string with max. length of 254"

    # get data, raises a KeyError() if key not exist
    value = metadata["MY_CUSTOM_META_DATA"]

    # get data, returns an empty string if key not exist
    value = metadata.get("MY_CUSTOM_META_DATA")

    # delete entry, raises a KeyError() if key not exist
    del metadata["MY_CUSTOM_META_DATA"]

    # discard entry, does not raise a KeyError() if key not exist
    metadata.discard("MY_CUSTOM_META_DATA")

Keys and values are limited to strings with a max. length of 254 characters
and line ending ``\n`` will be replaced by ``\P``.

Keys used by *ezdxf*:

    - ``WRITTEN_BY_EZDXF``: *ezdxf* version and UTC time in ISO format
    - ``CREATED_BY_EZDXF``: *ezdxf* version and UTC time in ISO format

Example of the ezdxf marker string: ``0.16.4b1 @ 2021-06-12T07:35:34.898808+00:00``

.. class:: ezdxf.document.MetaData

    .. automethod:: __contains__

    .. automethod:: __getitem__

    .. automethod:: get

    .. automethod:: __setitem__

    .. automethod:: __delitem__

    .. automethod:: discard


Export/Load JSON Encoded Tags
-----------------------------

Tag format of DXF documents:

.. code-block:: text

    0
    SECTION
    2
    HEADER
    9
    $ACADVER
    1
    AC1027
    ...
    9
    $LIMMIN
    10
    0.0
    20
    0.0
    9
    $LIMMAX
    10
    420.0
    20
    297.0
    9
    $ORTHOMODE
    70
    0
    9
    $REGENMODE
    70
    1
    ...
    0
    EOF

The `compact` format is a list of ``[group-code, value]`` pairs where each pair is 
a DXF tag. The group-code has to be an integer and the value has to be a string, 
integer, float or list of floats for vertices. 

.. code-block:: text

    [
    [0, "SECTION"],
    [2, "HEADER"],
    [9, "$ACADVER"],
    [1, "AC1027"],
    ...
    [9, "$LIMMIN"],
    [10, [0.0,0.0]],
    [9, "$LIMMAX"],
    [10, [420.0,297.0]],
    [9, "$ORTHOMODE"],
    [70, 0],
    [9, "$REGENMODE"],
    [70, 1]
    ...
    [0, "EOF"]
    ]


The `verbose` format (`compact` is ``False``) is a list of ``[group-code, value]`` 
pairs where each pair is a 1:1 representation of a DXF tag. The group-code has to be an 
integer and the value has to be a string. 

.. code-block:: text

    [
    [0, "SECTION"],
    [2, "HEADER"],
    [9, "$ACADVER"],
    [1, "AC1027"],
    ...
    [9, "$LIMMIN"],
    [10, "0.0"],
    [20, "0.0"],
    [9, "$LIMMAX"],
    [10, "420.0"],
    [20, "297.0"],
    [9, "$ORTHOMODE"],
    [70, "0"],
    [9, "$REGENMODE"],
    [70, "1"],

    ...
    [0, "EOF"]
    ]


.. autofunction:: ezdxf.document.export_json_tags

.. autofunction:: ezdxf.document.load_json_tags

--- End of file: drawing/management.rst ---



--- Start of file: drawing/recover.rst ---

.. _recover:

.. module:: ezdxf.recover

Recover
=======

This module provides functions to "recover" ASCII DXF documents with structural
flaws, which prevents the regular :func:`ezdxf.read` and :func:`ezdxf.readfile`
functions to load the document.

The :func:`read` and :func:`readfile` functions will repair as much
flaws as possible and run the required audit process automatically
afterwards and return the result of this audit process:

.. code-block:: Python

    import sys
    import ezdxf
    from ezdxf import recover

    try:
        doc, auditor = recover.readfile("messy.dxf")
    except IOError:
        print(f'Not a DXF file or a generic I/O error.')
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f'Invalid or corrupted DXF file.')
        sys.exit(2)

    # DXF file can still have unrecoverable errors, but this is maybe just
    # a problem when saving the recovered DXF file.
    if auditor.has_errors:
        auditor.print_error_report()

The loading functions also decode DXF-Unicode encoding automatically
e.g. "\\U+00FC" -> "".
All these efforts cost some time, loading the DXF document with
:func:`ezdxf.read` or :func:`ezdxf.readfile` is faster.

.. warning::

    This module will load DXF files which have decoding errors, most likely binary
    data stored in XRECORD entities, these errors are logged as unrecoverable
    ``AuditError.DECODE_ERRORS`` in the :attr:`Auditor.errors` attribute, but no
    :class:`DXFStructureError` exception will be raised, because for many use
    cases this errors can be ignored.

    Writing such files back with `ezdxf` may create **invalid** DXF files, or
    at least some **information will be lost** - handle with care!

    To avoid this problem use :code:`recover.readfile(filename, errors='strict')`
    which raises an :class:`UnicodeDecodeError` exception for such binary data.
    Catch the exception and handle this DXF files as unrecoverable.

Loading Scenarios
-----------------

1. It will work
~~~~~~~~~~~~~~~

Mostly DXF files from AutoCAD or BricsCAD (e.g. for In-house solutions):

.. code-block:: Python

    try:
        doc = ezdxf.readfile(name)
    except IOError:
        print(f'Not a DXF file or a generic I/O error.')
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f'Invalid or corrupted DXF file: {name}.')
        sys.exit(2)

2. DXF file with minor flaws
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

DXF files have only minor flaws, like undefined resources:

.. code-block:: Python

    try:
        doc = ezdxf.readfile(name)
    except IOError:
        print(f'Not a DXF file or a generic I/O error.')
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f'Invalid or corrupted DXF file: {name}.')
        sys.exit(2)

    auditor = doc.audit()
    if auditor.has_errors:
        auditor.print_error_report()



3. Try Hard
~~~~~~~~~~~

From trusted and untrusted sources but with good hopes, the worst case works
like a cache miss, you pay for the first try and pay the extra fee for the
recover mode:

.. code-block:: Python

    try:  # Fast path:
        doc = ezdxf.readfile(name)
    except IOError:
        print(f'Not a DXF file or a generic I/O error.')
        sys.exit(1)
    # Catch all DXF errors:
    except ezdxf.DXFError:
        try:  # Slow path including fixing low level structures:
            doc, auditor = recover.readfile(name)
        except ezdxf.DXFStructureError:
            print(f'Invalid or corrupted DXF file: {name}.')
            sys.exit(2)

        # DXF file can still have unrecoverable errors, but this is maybe
        # just a problem when saving the recovered DXF file.
        if auditor.has_errors:
            print(f'Found unrecoverable errors in DXF file: {name}.')
            auditor.print_error_report()

4. Just use the slow recover module
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Untrusted sources and expecting many invalid or corrupted  DXF files, you
always pay an extra fee for the recover mode:

.. code-block:: Python

    try:  # Slow path including fixing low level structures:
        doc, auditor = recover.readfile(name)
    except IOError:
        print(f'Not a DXF file or a generic I/O error.')
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f'Invalid or corrupted DXF file: {name}.')
        sys.exit(2)

    # DXF file can still have unrecoverable errors, but this is maybe
    # just a problem when saving the recovered DXF file.
    if auditor.has_errors:
        print(f'Found unrecoverable errors in DXF file: {name}.')
        auditor.print_error_report()

5. Unrecoverable Decoding Errors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If files contain binary data which can not be decoded by the document encoding,
it is maybe the best to ignore these files, this works in normal and recover
mode:

.. code-block:: Python

    try:
        doc, auditor = recover.readfile(name, errors='strict')
    except IOError:
        print(f'Not a DXF file or a generic I/O error.')
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f'Invalid or corrupted DXF file: {name}.')
        sys.exit(2)
    except UnicodeDecodeError:
        print(f'Decoding error in DXF file: {name}.')
        sys.exit(3)

6. Ignore/Locate Decoding Errors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes ignoring decoding errors can recover DXF files or at least
you can detect where the decoding errors occur:

.. code-block:: Python

    try:
        doc, auditor = recover.readfile(name, errors='ignore')
    except IOError:
        print(f'Not a DXF file or a generic I/O error.')
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f'Invalid or corrupted DXF file: {name}.')
        sys.exit(2)
    if auditor.has_errors:
        auditor.print_report()

The error messages with code :attr:`AuditError.DECODING_ERROR` shows the
approximate line number of the decoding error:
"Fixed unicode decoding error near line: xxx."



.. hint::

    This functions can handle only ASCII DXF files!

.. autofunction:: readfile

.. autofunction:: read

.. autofunction:: explore





--- End of file: drawing/recover.rst ---



--- Start of file: dxfentities/3dface.rst ---

Face3d
======

.. module:: ezdxf.entities
    :noindex:

The 3DFACE entity (`DXF Reference`_) is real 3D solid filled triangle or quadrilateral.
Access vertices by name (:code:`entity.dxf.vtx0 = (1.7, 2.3)`) or by index
(:code:`entity[0] = (1.7, 2.3)`).

Unlike the entities :class:`Solid` and :class:`Trace`, the vertices of
:class:`Face3d` have the expected vertex order:

.. code-block:: Python

    msp.add_3dface([(0, 0), (10, 0), (10, 10), (0, 10)])

.. image:: gfx/3dface.png
    :align: center

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'3DFACE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_3dface`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided
    factory functions!

.. class:: Face3d

    The class name is :class:`Face3d` because :class:`3dface` is not a valid
    Python class name.

    .. attribute:: dxf.vtx0

        Location of 1. vertex (3D Point in :ref:`WCS`)

    .. attribute:: dxf.vtx1

        Location of 2. vertex (3D Point in :ref:`WCS`)

    .. attribute:: dxf.vtx2

        Location of 3. vertex (3D Point in :ref:`WCS`)

    .. attribute:: dxf.vtx3

        Location of 4. vertex (3D Point in :ref:`WCS`)

    .. attribute:: dxf.invisible_edges

        invisible edge flag (int, default=0)

        === ==============================
        1   first edge is invisible
        2   second edge is invisible
        4   third edge is invisible
        8   fourth edge is invisible
        === ==============================

        Combine values by adding them, e.g. 1+4 = first and third edge is invisible.

    .. automethod:: transform

    .. automethod:: wcs_vertices(close: bool = False) -> list[Vec3]

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-747865D5-51F0-45F2-BEFE-9572DBC5B151

--- End of file: dxfentities/3dface.rst ---



--- Start of file: dxfentities/3dsolid.rst ---

Solid3d
=======

.. module:: ezdxf.entities
    :noindex:

3DSOLID entity (`DXF Reference`_) created by an ACIS geometry kernel provided by
the `Spatial Corp.`_


.. seealso::

    `Ezdxf` has only very limited support for ACIS based entities, for more
    information see the FAQ: :ref:`faq003`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Body`
DXF type                 ``'3DSOLID'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_3dsolid`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. class:: Solid3d

    Same attributes and methods as parent class :class:`Body`.

    .. attribute:: dxf.history_handle

        Handle to history object.


.. _Spatial Corp.: http://www.spatial.com/products/3d-acis-modeling

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-19AB1C40-0BE0-4F32-BCAB-04B37044A0D3

--- End of file: dxfentities/3dsolid.rst ---



--- Start of file: dxfentities/acad_proxy_entity.rst ---

ACADProxyEntity
===============

.. module:: ezdxf.entities
    :noindex:


An ACAD_PROXY_ENTITY (`DXF Reference`_) is a proxy entity that represents an entity
created by an Autodesk or 3rd party application.
It stores the graphics and data of the original entity.

The internals of this entity are unknown, so the entity cannot be copied or transformed.
However, `ezdxf` can extract the proxy graphic from these entities as virtual entities
or replace (explode) the entire entity with its proxy graphic. The meaning and data of
this entity is lost when the entity is exploded.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'ACAD_PROXY_ENTITY'``
Factory function         not supported
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. class:: ACADProxyEntity

    .. automethod:: virtual_entities

    .. automethod:: explode

.. _DXF Reference: https://help.autodesk.com/view/OARX/2019/ENU/?guid=GUID-89A690F9-E859-4D57-89EA-750F3FB76C6B

--- End of file: dxfentities/acad_proxy_entity.rst ---



--- Start of file: dxfentities/arc.rst ---

Arc
===

.. module:: ezdxf.entities
    :noindex:

The ARC entity (`DXF Reference`_) represents a circular arc, which is defined by the DXF
attributes :attr:`dxf.center`, :attr:`dxf.radius`, :attr:`dxf.start_angle` and
:attr:`dxf.end_angle`.
The arc-curve goes always from :attr:`dxf.start_angle` to :attr:`dxf.end_angle` in
counter-clockwise orientation around the :attr:`dxf.extrusion` vector, which is (0, 0, 1)
by default and the usual case for 2D arcs. The ARC entity has :ref:`OCS`
coordinates.

The helper tool :class:`ezdxf.math.ConstructionArc` supports creating arcs from
various scenarios, like from 3 points or 2 points and an angle or 2 points and
a radius and the :mod:`~ezdxf.upright` module can convert inverted extrusion vectors
from (0, 0, -1) to (0, 0, 1) without changing the curve.

.. seealso::

    - :ref:`tut_dxf_primitives`, section :ref:`tut_dxf_primitives_arc`
    - :class:`ezdxf.math.ConstructionArc`
    - :ref:`Object Coordinate System`
    - :mod:`ezdxf.upright` module

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Circle`
DXF type                 ``'ARC'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_arc`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided
    factory functions!

.. class:: Arc

    .. attribute:: dxf.center

        Center point of arc (2D/3D Point in :ref:`OCS`)

    .. attribute:: dxf.radius

        Radius of arc (float)

    .. attribute:: dxf.start_angle

        Start angle in degrees (float)

    .. attribute:: dxf.end_angle

        End angle in degrees (float)

    .. autoattribute:: start_point

    .. autoattribute:: end_point

    .. automethod:: angles

    .. automethod:: flattening

    .. automethod:: transform

    .. automethod:: to_ellipse

    .. automethod:: to_spline

    .. automethod:: construction_tool

    .. automethod:: apply_construction_tool

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-0B14D8F1-0EBA-44BF-9108-57D8CE614BC8


--- End of file: dxfentities/arc.rst ---



--- Start of file: dxfentities/arcdim.rst ---

ArcDimension
============

.. module:: ezdxf.entities
    :noindex:

The ARC_DIMENSION entity was introduced in DXF R2004 and is **not** documented
in the DXF reference.

.. seealso::

    :ref:`tut_arc_dimension`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Dimension`
DXF type                 ``'ARC_DIMENSION'``
factory function         - :meth:`~ezdxf.layouts.BaseLayout.add_arc_dim_3p`
                         - :meth:`~ezdxf.layouts.BaseLayout.add_arc_dim_cra`
                         - :meth:`~ezdxf.layouts.BaseLayout.add_arc_dim_arc`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     R2004 / AC1018
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided
    factory functions!

.. class:: ArcDimension

    .. attribute:: dxf.defpoint2

        start point of first extension line in :ref:`OCS`

    .. attribute:: dxf.defpoint3

        start point of second extension line in :ref:`OCS`

    .. attribute:: dxf.defpoint4

        center point of arc in :ref:`OCS`

    .. attribute:: dxf.start_angle

    .. attribute:: dxf.end_angle

    .. attribute:: dxf.is_partial

    .. attribute:: dxf.has_leader

    .. attribute:: dxf.leader_point1

    .. attribute:: dxf.leader_point2

    .. attribute:: dimtype

        Returns always ``8``.


--- End of file: dxfentities/arcdim.rst ---



--- Start of file: dxfentities/body.rst ---

Body
====

.. module:: ezdxf.entities
    :noindex:

BODY entity (`DXF Reference`_) created by an ACIS geometry kernel provided by
the `Spatial Corp.`_

.. seealso::

    `Ezdxf` has only very limited support for ACIS based entities, for more
    information see the FAQ: :ref:`faq003`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'BODY'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_body`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided
    factory functions!

.. class:: Body

    .. attribute:: dxf.version

        Modeler format version number, default value is 1

    .. attribute:: dxf.flags

        Require DXF R2013.

    .. attribute:: dxf.uid

        Require DXF R2013.

    .. autoproperty:: acis_data

    .. autoproperty:: sat

    .. autoproperty:: sab

    .. autoproperty:: has_binary_data

    .. automethod:: tostring


.. _Spatial Corp.: http://www.spatial.com/products/3d-acis-modeling

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-7FB91514-56FF-4487-850E-CF1047999E77

--- End of file: dxfentities/body.rst ---



--- Start of file: dxfentities/circle.rst ---

Circle
======

.. module:: ezdxf.entities
    :noindex:

The CIRCLE entity (`DXF Reference`_) defined by the DXF attributes :attr:`dxf.center`
and :attr:`dxf.radius`. The CIRCLE entity has :ref:`OCS` coordinates.

.. seealso::

    - :ref:`tut_dxf_primitives`, section :ref:`tut_dxf_primitives_circle`
    - :class:`ezdxf.math.ConstructionCircle`
    - :ref:`Object Coordinate System`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'CIRCLE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_circle`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided
    factory functions!

.. class:: Circle

    .. attribute:: dxf.center

        Center point of circle (2D/3D Point in :ref:`OCS`)

    .. attribute:: dxf.radius

        Radius of circle (float)

    .. automethod:: vertices

    .. automethod:: flattening

    .. automethod:: transform

    .. automethod:: translate

    .. automethod:: to_ellipse

    .. automethod:: to_spline

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-8663262B-222C-414D-B133-4A8506A27C18

--- End of file: dxfentities/circle.rst ---



--- Start of file: dxfentities/dimension.rst ---

Dimension
=========

.. module:: ezdxf.entities
    :noindex:

The DIMENSION entity (`DXF Reference`_) represents several types of dimensions
in many orientations and alignments. The basic types of dimensioning are linear,
radial, angular, ordinate, and arc length.

For more information about dimensions see the online help from AutoDesk:
`About the Types of Dimensions`_

.. important::

    The DIMENSION entity is reused to create dimensional constraints, such
    entities do not have an associated geometrical block nor a dimension type
    group code (2) and reside on layer ``*ADSK_CONSTRAINTS``.
    Use property :attr:`Dimension.is_dimensional_constraint` to check for this
    objects. Dimensional constraints are not documented in the DXF reference and
    not supported by `ezdxf`.

.. seealso::

    - :ref:`tut_linear_dimension`
    - :ref:`tut_radius_dimension`
    - :ref:`tut_diameter_dimension`
    - :ref:`tut_angular_dimension`
    - :ref:`tut_ordinate_dimension`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'DIMENSION'``
factory function         see table below
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

Factory Functions
-----------------

=========================================== ==========================================
`Linear and Rotated Dimension (DXF)`_       :meth:`~ezdxf.layouts.BaseLayout.add_linear_dim`
`Aligned Dimension (DXF)`_                  :meth:`~ezdxf.layouts.BaseLayout.add_aligned_dim`
`Angular Dimension (DXF)`_                  :meth:`~ezdxf.layouts.BaseLayout.add_angular_dim_2l`
`Angular 3P Dimension (DXF)`_               :meth:`~ezdxf.layouts.BaseLayout.add_angular_dim_3p`
Angular Dimension by center, radius, angles :meth:`~ezdxf.layouts.BaseLayout.add_angular_dim_cra`
Angular Dimension by ConstructionArc        :meth:`~ezdxf.layouts.BaseLayout.add_angular_dim_arc`
`Diameter Dimension (DXF)`_                 :meth:`~ezdxf.layouts.BaseLayout.add_diameter_dim`
`Radius Dimension (DXF)`_                   :meth:`~ezdxf.layouts.BaseLayout.add_radius_dim`
`Ordinate Dimension (DXF)`_                 :meth:`~ezdxf.layouts.BaseLayout.add_ordinate_dim`
=========================================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. class:: Dimension

    There is only one :class:`Dimension` class to represent all different dimension types.

    .. attribute:: dxf.version

        Version number: ``0`` = R2010. (int, DXF R2010)

    .. attribute:: dxf.geometry

        Name of the BLOCK that contains the entities that make up the dimension picture.

        For AutoCAD this graphical representation is mandatory, otherwise AutoCAD will
        not open the DXF document.  BricsCAD will render the DIMENSION entity by itself,
        if the graphical representation is not present, but displays the BLOCK content
        if present.

    .. attribute:: dxf.dimstyle

        Dimension style (:class:`DimStyle`) name as string.

    .. attribute:: dxf.dimtype

        Values 0-6 are integer values that represent the dimension type. Values 32, 64,
        and 128 are bit values, which are added to the integer values.

        === ===================================================================
        0   `Linear and Rotated Dimension (DXF)`_
        1   `Aligned Dimension (DXF)`_
        2   `Angular Dimension (DXF)`_
        3   `Diameter Dimension (DXF)`_
        4   `Radius Dimension (DXF)`_
        5   `Angular 3P Dimension (DXF)`_
        6   `Ordinate Dimension (DXF)`_
        8   subclass :class:`ezdxf.entities.ArcDimension` introduced in DXF R2004
        32  Indicates that graphical representation :attr:`geometry` is referenced by
            this dimension only. (always set in DXF R13 and later)
        64  Ordinate type. This is a bit value (bit 7) used only with integer value 6.
            If set, ordinate is `X-type`; if not set, ordinate is `Y-type`
        128 This is a bit value (bit 8) added to the other :attr:`dimtype` values if the
            dimension text has been positioned at a user-defined location rather than at
            the default location
        === ===================================================================

    .. attribute:: dxf.defpoint

        Definition point for all dimension types. (3D Point in :ref:`WCS`)

        - Linear- and rotated dimension: :attr:`dxf.defpoint` specifies the dimension line
          location.
        - Arc- and angular dimension: :attr:`dxf.defpoint` and :attr:`dxfdefpoint4`
          specify the endpoints of the line used to determine the second extension line.

    .. attribute:: dxf.defpoint2

        Definition point for linear- and angular dimensions. (3D Point in :ref:`WCS`)

        - Linear- and rotated dimension: The :attr:`dxf.defpoint2` specifies the start
          point of the first extension line.
        - Arc- and angular dimension: The :attr:`dxf.defpoint2` and :attr:`dxf.defpoint3`
          specify the endpoints of the line used to determine the first extension line.

    .. attribute:: dxf.defpoint3

        Definition point for linear- and angular dimensions. (3D Point in :ref:`WCS`)

        - Linear- and rotated dimension: The :attr:`dxf.defpoint3` specifies the start
          point of the second extension line.
        - Arc- and angular dimension: The :attr:`dxf.defpoint2` and :attr:`dxf.defpoint3`
          specify the endpoints of the line used to determine the first extension line.

    .. attribute:: dxf.defpoint4

        Definition point for diameter-, radius-, and angular dimensions.
        (3D Point in :ref:`WCS`)

        The :attr:`dxf.defpoint` and :attr:`dxf.defpoint4` specify the endpoints of the
        line used to determine the second extension line for arc- and angular dimension:

    .. attribute:: dxf.defpoint5

        This point defines the location of the arc for angular dimensions.
        (3D Point in :ref:`OCS`)

    .. attribute:: dxf.angle

        Rotation angle of linear and rotated dimensions in degrees. (float)

    .. attribute:: dxf.leader_length

        Leader length for radius and diameter dimensions. (float)

    .. attribute:: dxf.text_midpoint

        Middle point of dimension text. (3D Point in :ref:`OCS`)

    .. attribute:: dxf.insert

        Insertion point for clones of a linear dimensions. (3D Point in :ref:`OCS`)

        This value translates the content of the associated anonymous block for
        cloned linear dimensions, similar to the :attr:`insert` attribute of
        the :class:`Insert` entity.

    .. attribute:: dxf.attachment_point

        Text attachment point (int, DXF R2000), default value is 5.

        === ================
        1   Top left
        2   Top center
        3   Top right
        4   Middle left
        5   Middle center
        6   Middle right
        7   Bottom left
        8   Bottom center
        9   Bottom right
        === ================

    .. attribute:: dxf.line_spacing_style

        Dimension text line-spacing style (int, DXF R2000), default value is 1.

        === ============================================
        1   At least (taller characters will override)
        2   Exact (taller characters will not override)
        === ============================================

    .. attribute:: dxf.line_spacing_factor

        Dimension text-line spacing factor. (float, DXF R2000)

        Percentage of default (3-on-5) line spacing to be applied. Valid values range
        from 0.25 to 4.00.

    .. attribute:: dxf.actual_measurement

        Actual measurement (float, DXF R2000), this is an optional attribute and often
        not present. (read-only value)

    .. attribute:: dxf.text

        Dimension text explicitly entered by the user (str), default value is an empty string.

        If empty string or "<>", the dimension measurement is drawn as the text, if " "
        (one blank space), the text is suppressed. Anything else will be displayed as
        the dimension text.

    .. attribute:: dxf.oblique_angle

        The optional :attr:`dxf.oblique_angle` defines the angle of the extension lines
        for linear dimension.

    .. attribute:: dxf.text_rotation

        Defines is the rotation angle of the dimension text away from its default
        orientation (the direction of the dimension line). (float)

    .. attribute:: dxf.horizontal_direction

        Indicates the horizontal direction for the dimension entity (float).

        This attribute determines the orientation of dimension text and lines for
        horizontal, vertical, and  rotated linear dimensions.  This value is the
        negative of the angle in the OCS xy-plane between the dimension line and the
        OCS x-axis.

    .. autoproperty:: dimtype

    .. autoproperty:: is_dimensional_constraint

    .. automethod:: get_dim_style

    .. automethod:: get_geometry_block

    .. automethod:: get_measurement

    .. automethod:: override

    .. automethod:: render

    .. automethod:: transform

    .. automethod:: virtual_entities

    .. automethod:: explode


DimStyleOverride
----------------

All of the :class:`DimStyle` attributes can be overridden for each :class:`Dimension` entity individually.

The :class:`DimStyleOverride` class manages all the complex dependencies between :class:`DimStyle` and
:class:`Dimension`, the different features of all DXF versions and the rendering process to create the
:class:`Dimension` picture as BLOCK, which is required for AutoCAD.

.. class:: DimStyleOverride

    .. attribute:: dimension

        Base :class:`Dimension` entity.

    .. attribute:: dimstyle

        By :attr:`dimension` referenced :class:`DimStyle` entity.

    .. attribute:: dimstyle_attribs

        Contains all overridden attributes of :attr:`dimension`, as a ``dict`` with :class:`DimStyle` attribute names
        as keys.

    .. automethod:: __getitem__

    .. automethod:: __setitem__

    .. automethod:: __delitem__

    .. automethod:: get

    .. automethod:: pop

    .. automethod:: update

    .. automethod:: commit

    .. automethod:: get_arrow_names

    .. automethod:: set_arrows

    .. automethod:: set_tick

    .. automethod:: set_text_align

    .. automethod:: set_tolerance

    .. automethod:: set_limits

    .. automethod:: set_text_format

    .. automethod:: set_dimline_format

    .. automethod:: set_extline_format

    .. automethod:: set_extline1

    .. automethod:: set_extline2

    .. automethod:: set_text

    .. automethod:: shift_text

    .. automethod:: set_location

    .. automethod:: user_location_override

    .. automethod:: render

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-239A1BDD-7459-4BB9-8DD7-08EC79BF1EB0

.. _About the Types of Dimensions: https://knowledge.autodesk.com/support/autocad/getting-started/caas/CloudHelp/cloudhelp/2020/ENU/AutoCAD-Core/files/GUID-9A8AB1F2-4754-444C-B90D-CD3F2FC8A3E0-htm.html

.. _Aligned Dimension (DXF): http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-7A123D5D-AC98-4A9A-A8CF-1A7EF5030418

.. _Angular Dimension (DXF): http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-09821B78-9F8E-43BA-82F2-8C931485EDC9

.. _Angular 3P Dimension (DXF): http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-09821B78-9F8E-43BA-82F2-8C931485EDC9

.. _Linear and Rotated Dimension (DXF): http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-F0004556-493C-48D5-8619-61D6ADF05C04

.. _Ordinate Dimension (DXF): http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-72F01288-0D63-43E8-8179-8CE3BA544C40

.. _Radius Dimension (DXF): http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-165A992D-9017-4C1E-B8CC-E70A17191BFE

.. _Diameter Dimension (DXF): http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-165A992D-9017-4C1E-B8CC-E70A17191BFE

.. _Dimension Style Overrides (DXF): http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-6A4C31C0-4988-499C-B5A4-15582E433B0F


--- End of file: dxfentities/dimension.rst ---



--- Start of file: dxfentities/dxfentity.rst ---

DXF Entity Base Class
=====================

.. module:: ezdxf.entities
    :noindex:

Common base class for all DXF entities and objects.

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. if adding features - also update DXFObject

.. class:: DXFEntity

    .. attribute:: dxf

        The DXF attributes namespace::

            # set attribute value
            entity.dxf.layer = 'MyLayer'

            # get attribute value
            linetype = entity.dxf.linetype

            # delete attribute
            del entity.dxf.linetype



    .. attribute:: dxf.handle

        DXF `handle` is a unique identifier as plain hex string like ``F000``. (feature for experts)

    .. attribute:: dxf.owner

        Handle to `owner` as plain hex string like ``F000``. (feature for experts)

    .. attribute:: doc

        Get the associated :class:`~ezdxf.document.Drawing` instance.

    .. autoproperty:: is_alive

    .. autoproperty:: is_virtual

    .. autoproperty:: is_bound

    .. autoproperty:: is_copy

    .. autoproperty:: uuid

    .. autoproperty:: source_of_copy

    .. autoproperty:: origin_of_copy

    .. autoproperty:: has_source_block_reference

    .. autoproperty:: source_block_reference

    .. automethod:: dxftype

    .. automethod:: __str__

    .. automethod:: __repr__

    .. automethod:: has_dxf_attrib

    .. automethod:: is_supported_dxf_attrib

    .. automethod:: get_dxf_attrib

    .. automethod:: set_dxf_attrib

    .. automethod:: del_dxf_attrib

    .. automethod:: dxfattribs

    .. automethod:: update_dxf_attribs

    .. automethod:: set_flag_state

    .. automethod:: get_flag_state

    .. autoattribute:: has_extension_dict

    .. automethod:: get_extension_dict

    .. automethod:: new_extension_dict

    .. automethod:: discard_extension_dict
        
    .. automethod:: discard_empty_extension_dict

    .. automethod:: has_app_data

    .. automethod:: get_app_data

    .. automethod:: set_app_data

    .. automethod:: discard_app_data

    .. automethod:: has_xdata

    .. automethod:: get_xdata

    .. automethod:: set_xdata

    .. automethod:: discard_xdata

    .. automethod:: has_xdata_list

    .. automethod:: get_xdata_list

    .. automethod:: set_xdata_list

    .. automethod:: discard_xdata_list

    .. automethod:: replace_xdata_list

    .. automethod:: has_reactors

    .. automethod:: get_reactors

    .. automethod:: set_reactors

    .. automethod:: append_reactor_handle

    .. automethod:: discard_reactor_handle



--- End of file: dxfentities/dxfentity.rst ---



--- Start of file: dxfentities/dxfgfx.rst ---

DXF Graphic Entity Base Class
=============================

.. module:: ezdxf.entities
    :noindex:

Common base class for all graphical DXF entities.

All graphical entities reside in an entity space like :class:`~ezdxf.layouts.Modelspace`,
any :class:`~ezdxf.layouts.Paperspace` or :class:`~ezdxf.layouts.BlockLayout`.

.. seealso::

    - :mod:`ezdxf.gfxattribs` module, helper tools to set graphical attributes
      of DXF entities
    - :mod:`ezdxf.colors` module
    - :ref:`tut_common_graphical_attributes`

============ =================================
Subclass of  :class:`ezdxf.entities.DXFEntity`
============ =================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided
    factory functions!

.. class:: DXFGraphic

    .. attribute:: rgb

        Get/set/delete DXF attribute :attr:`dxf.true_color` as (r, g, b) tuple, returns
        ``None`` if attribute :attr:`dxf.true_color` is not set.

        .. code-block:: python

            entity.rgb = (30, 40, 50)  # set as tuple[int, int, int] or color.RGB
            r, g, b = entity.rgb  # returns tuple[int, int, int] or None
            del entity.rgb  # discard true color value, no exception if not exist

        This is the recommend method to get/set/delete RGB values, when ever possible
        do not use the DXF low level attribute :attr:`dxf.true_color`.


    .. attribute:: transparency

        Get/set the transparency value as float. The transparency value is in the
        range from 0 to 1, where 0 means the entity is opaque and 1 means the
        entity is 100% transparent (invisible).  This is the recommend method to
        get/set the transparency value, when ever possible do not use the DXF
        low level attribute :attr:`DXFGraphic.dxf.transparency`.

        This attribute requires DXF R2004 or later, returns 0 for older DXF
        versions and raises :class:`DXFAttributeError` for setting transparency
        in older DXF versions.

    .. autoproperty:: is_transparency_by_layer

    .. autoproperty:: is_transparency_by_block

    .. automethod:: ocs

    .. automethod:: get_layout

    .. automethod:: unlink_from_layout

    .. automethod:: copy_to_layout

    .. automethod:: move_to_layout

    .. automethod:: graphic_properties

    .. automethod:: has_hyperlink

    .. automethod:: get_hyperlink

    .. automethod:: set_hyperlink

    .. automethod:: transform

    .. automethod:: translate

    .. automethod:: scale

    .. automethod:: scale_uniform

    .. automethod:: rotate_x

    .. automethod:: rotate_y

    .. automethod:: rotate_z

    .. automethod:: rotate_axis

.. _Common graphical DXF attributes:

Common graphical DXF attributes
-------------------------------

    .. attribute:: DXFGraphic.dxf.layer

        Layer name as string; default = "0"

    .. attribute:: DXFGraphic.dxf.linetype

        Linetype as string, special names "BYLAYER", "BYBLOCK"; default value
        is "BYLAYER"

    .. attribute:: DXFGraphic.dxf.color

        :ref:`aci`,  default value is 256

        Constants defined in :mod:`ezdxf.lldxf.const` or use the :mod:`ezdxf.colors`
        module

        === =========
        0   BYBLOCK
        256 BYLAYER
        257 BYOBJECT
        === =========

    .. attribute:: DXFGraphic.dxf.lineweight

        Line weight in mm times 100 (e.g. 0.13mm = 13). There are fixed valid
        lineweights which are accepted by AutoCAD, other values prevents AutoCAD
        from loading the DXF document, BricsCAD isn't that picky.
        (requires DXF R2000)

        Constants defined in :mod:`ezdxf.lldxf.const`

        === ==================
        -1  LINEWEIGHT_BYLAYER
        -2  LINEWEIGHT_BYBLOCK
        -3  LINEWEIGHT_DEFAULT
        === ==================

        Valid DXF lineweights stored in ``VALID_DXF_LINEWEIGHTS``:
        0, 5, 9, 13, 15, 18, 20, 25, 30, 35, 40, 50, 53, 60, 70, 80, 90, 100, 106, 120, 140, 158, 200, 211

    .. attribute:: DXFGraphic.dxf.ltscale

        Line type scale as float; default value is 1.0; (requires DXF R2000)

    .. attribute:: DXFGraphic.dxf.invisible

        1 for invisible, 0 for visible; default value is 0; (requires DXF R2000)

    .. attribute:: DXFGraphic.dxf.paperspace

        0 for entity resides in modelspace or a block, 1 for paperspace,
        this attribute is set automatically by adding an entity to a layout
        (feature for experts); default value is 0

    .. attribute:: DXFGraphic.dxf.extrusion

        Extrusion direction as 3D vector; default value is (0, 0, 1)

    .. attribute:: DXFGraphic.dxf.thickness

        Entity thickness as float; default value is 0.0; (requires DXF R2000)

    .. attribute:: DXFGraphic.dxf.true_color

        True color value as int 0x00RRGGBB, use :attr:`DXFGraphic.rgb` to
        get/set true color values as (r, g, b) tuples. (requires DXF R2004)

    .. attribute:: DXFGraphic.dxf.color_name

        Color name as string. (requires DXF R2004)

    .. attribute:: DXFGraphic.dxf.transparency

        Transparency value as int, 0x020000TT, 0x00 = 100% transparent /
        0xFF = opaque, special value 0x01000000 means transparency by
        block. An unset transparency value means transparency by layer.
        Use :attr:`DXFGraphic.transparency` to get/set transparency as float
        value, and the properties :attr:`DXFGraphic.is_transparency_by_block`
        and :attr:`DXFGraphic.is_transparency_by_layer` to check special cases.

        (requires DXF R2004)

    .. attribute:: DXFGraphic.dxf.shadow_mode

        === ==========================
        0   casts and receives shadows
        1   casts shadows
        2   receives shadows
        3   ignores shadows
        === ==========================

        (requires DXF R2007)

.. seealso::

    - :mod:`ezdxf.gfxattribs` module, helper tools to set graphical attributes
      of DXF entities
    - :mod:`ezdxf.colors` module
    - :ref:`tut_common_graphical_attributes`


--- End of file: dxfentities/dxfgfx.rst ---



--- Start of file: dxfentities/ellipse.rst ---

Ellipse
=======

.. module:: ezdxf.entities
    :noindex:

The ELLIPSE entity (`DXF Reference`_) is an elliptic 3D curve defined by the DXF
attributes :attr:`dxf.center`, the :attr:`dxf.major_axis` vector and the
:attr:`dxf.extrusion` vector.

The :attr:`dxf.ratio` attribute is the ratio of minor axis to major axis and has
to be smaller or equal 1.  The :attr:`dxf.start_param` and :attr:`dxf.end_param`
attributes defines the starting- and the end point of the ellipse, a full
ellipse goes from 0 to 2.  The curve always goes from start- to end
param in counter clockwise orientation.

The :attr:`dxf.extrusion` vector defines the normal vector of the ellipse plane.
The minor axis direction is calculated by :attr:`dxf.extrusion` cross
:attr:`dxf.major_axis`. The default extrusion vector (0, 0, 1) defines an ellipse
plane parallel to xy-plane of the :ref:`WCS`.

All coordinates and vectors in :ref:`WCS`.

.. seealso::

    - :ref:`tut_dxf_primitives`, section :ref:`tut_dxf_primitives_ellipse`
    - :class:`ezdxf.math.ConstructionEllipse`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'ELLIPSE'``
factory function         :meth:`~ezdxf.layouts.BaseLayout.add_ellipse`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. class:: Ellipse

    .. attribute:: dxf.center

        Center point of circle (2D/3D Point in :ref:`WCS`)

    .. attribute:: dxf.major_axis

        Endpoint of major axis, relative to the :attr:`dxf.center` (Vec3),
        default value is (1, 0, 0).

    .. attribute:: dxf.ratio

        Ratio of minor axis to major axis (float), has to be in range from
        0.000001 to 1.0, default value is 1.

    .. attribute:: dxf.start_param

        Start parameter (float), default value is 0.

    .. attribute:: dxf.end_param

        End parameter (float), default value is 2.

    .. attribute:: start_point

        Returns the start point of the ellipse in WCS.

    .. attribute:: end_point

        Returns the end point of the ellipse in WCS.

    .. attribute:: minor_axis

        Returns the minor axis of the ellipse as :class:`Vec3` in WCS.

    .. automethod:: construction_tool

    .. automethod:: apply_construction_tool

    .. automethod:: vertices

    .. automethod:: flattening

    .. automethod:: params

    .. automethod:: transform

    .. automethod:: translate

    .. automethod:: to_spline

    .. automethod:: from_arc

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-107CB04F-AD4D-4D2F-8EC9-AC90888063AB

--- End of file: dxfentities/ellipse.rst ---



--- Start of file: dxfentities/hatch.rst ---

Hatch
=====

.. module:: ezdxf.entities
    :noindex:

The HATCH entity (`DXF Reference`_) fills a closed area defined by one or
more boundary paths by a hatch pattern, a solid fill, or a gradient fill.

All points in :ref:`OCS` as (x, y) tuples (:attr:`Hatch.dxf.elevation` is the
z-axis value).

There are two different hatch pattern default scaling, depending on the HEADER
variable $MEASUREMENT, one for ISO measurement (m, cm, mm, ...) and one for
imperial measurement (in, ft, yd, ...).

The default scaling for predefined hatch pattern will be chosen according this
measurement setting in the HEADER section, this replicates the behavior of
BricsCAD and other CAD applications. `Ezdxf` uses the ISO pattern definitions as
a base line and scales this pattern down by factor 1/25.6 for imperial
measurement usage.
The pattern scaling is independent from the drawing units of the document
defined by the HEADER variable $INSUNITS.

.. seealso::

    :ref:`tut_hatch` and :ref:`DXF Units`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'HATCH'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_hatch`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-C6C71CED-CE0F-4184-82A5-07AD6241F15B

.. rubric:: Boundary paths classes

Path manager: :class:`BoundaryPaths`

- :class:`PolylinePath`
- :class:`EdgePath`
    - :class:`LineEdge`
    - :class:`ArcEdge`
    - :class:`EllipseEdge`
    - :class:`SplineEdge`

.. rubric:: Pattern and gradient classes

- :class:`Pattern`
- :class:`PatternLine`
- :class:`Gradient`

.. class:: Hatch

    .. attribute:: dxf.pattern_name

        Pattern name as string

    .. attribute:: dxf.solid_fill

        === ==========================================================
        1   solid fill,  use method :meth:`Hatch.set_solid_fill`
        0   pattern fill, use method :meth:`Hatch.set_pattern_fill`
        === ==========================================================

    .. attribute:: dxf.associative

        === =========================
        1   associative hatch
        0   not associative hatch
        === =========================

        Associations are not managed by `ezdxf`.

    .. attribute:: dxf.hatch_style

        === ========
        0   normal
        1   outer
        2   ignore
        === ========

        (search AutoCAD help for more information)

    .. attribute:: dxf.pattern_type

        === ===================
        0   user
        1   predefined
        2   custom
        === ===================

    .. attribute:: dxf.pattern_angle

        The actual pattern rotation angle in degrees (float). Changing this value does not
        rotate the pattern, use :meth:`~Hatch.set_pattern_angle` for this task.

    .. attribute:: dxf.pattern_scale

        The actual pattern scale factor (float). Changing this value does not
        scale the pattern use :meth:`~Hatch.set_pattern_scale` for this task.

    .. attribute:: dxf.pattern_double

        1 = double pattern size else 0. (int)

    .. attribute:: dxf.n_seed_points

        Count of seed points (use :meth:`get_seed_points`)

    .. attribute:: dxf.elevation

       Z value represents the elevation height of the :ref:`OCS`. (float)

    .. attribute:: paths

        :class:`BoundaryPaths` object.

    .. attribute:: pattern

        :class:`Pattern` object.

    .. attribute:: gradient

        :class:`Gradient` object.

    .. attribute:: seeds

        A list of seed points as (x, y) tuples.

    .. autoproperty:: has_solid_fill

    .. autoproperty:: has_pattern_fill

    .. autoproperty:: has_gradient_data

    .. autoproperty:: bgcolor

    .. automethod:: set_pattern_definition

    .. automethod:: set_pattern_scale

    .. automethod:: set_pattern_angle

    .. automethod:: set_solid_fill

    .. automethod:: set_pattern_fill

    .. automethod:: set_gradient

    .. automethod:: set_seed_points

    .. automethod:: transform(m: Matrix44) -> Hatch

    .. automethod:: associate

    .. automethod:: remove_association

Boundary Paths
--------------

The hatch entity is build by different path types, these are the
filter flags for the :attr:`Hatch.dxf.hatch_style`:

- EXTERNAL: defines the outer boundary of the hatch
- OUTERMOST: defines the first tier of inner hatch boundaries
- DEFAULT: default boundary path

As you will learn in the next sections, these are more the recommended
usage type for the flags, but the fill algorithm doesn't care much about that,
for instance an OUTERMOST path doesn't have to be inside the EXTERNAL path.

Island Detection
----------------

In general the island detection algorithm works always from outside to inside
and alternates filled and unfilled areas. The area between then 1st and the 2nd
boundary is filled, the area between the 2nd and the 3rd boundary is unfilled
and so on. The different hatch styles defined by the :attr:`Hatch.dxf.hatch_style`
attribute are created by filtering some boundary path types.

Hatch Style
-----------

- HATCH_STYLE_IGNORE: Ignores all paths except the paths marked as EXTERNAL, if
  there are more than one path marked as EXTERNAL, they are filled in NESTED
  style. Creates no hatch if no path is marked as EXTERNAL.
- HATCH_STYLE_OUTERMOST: Ignores all paths marked as DEFAULT, remaining EXTERNAL
  and OUTERMOST paths are filled in NESTED style. Creates no hatch if no path is
  marked as EXTERNAL or OUTERMOST.
- HATCH_STYLE_NESTED: Use all existing paths.

Hatch Boundary Classes
----------------------

.. class:: BoundaryPaths

    Defines the borders of the hatch, a hatch can consist of more than one path.

    .. attribute:: paths

        List of all boundary paths. Contains :class:`PolylinePath` and
        :class:`EdgePath` objects. (read/write)

    .. automethod:: external_paths

    .. automethod:: outermost_paths

    .. automethod:: default_paths

    .. automethod:: rendering_paths

    .. automethod:: append

    .. automethod:: add_polyline_path

    .. automethod:: add_edge_path

    .. automethod:: polyline_to_edge_paths

    .. automethod:: edge_to_polyline_paths

    .. automethod:: arc_edges_to_ellipse_edges

    .. automethod:: ellipse_edges_to_spline_edges

    .. automethod:: spline_edges_to_line_edges

    .. automethod:: all_to_spline_edges

    .. automethod:: all_to_line_edges

    .. automethod:: clear


.. class:: BoundaryPathType

    .. attribute:: POLYLINE

        polyline path type

    .. attribute:: EDGE

        edge path type


.. class:: PolylinePath

    A polyline as hatch boundary path.

    .. attribute:: type

        Path type as :attr:`BoundaryPathType.POLYLINE` enum

    .. attribute:: path_type_flags

        (bit coded flags)

        === ====================================
        0   default
        1   external
        2   polyline, will be set by `ezdxf`
        4   derived (?)
        8   textbox
        16  outermost
        === ====================================

        My interpretation of the :attr:`path_type_flags`, see also :ref:`tut_hatch`:

            - external: path is part of the hatch outer border
            - outermost: path is completely inside of one or more external paths
            - default: path is completely inside of one or more outermost paths

        If there are troubles with AutoCAD, maybe the hatch entity has the
        :attr:`Hatch.dxf.pixel_size` attribute set - delete it
        :code:`del hatch.dxf.pixel_size` and maybe the problem is solved.
        `Ezdxf` does not use the :attr:`Hatch.dxf.pixel_size` attribute, but it
        can occur in DXF files created by other applications.

    .. attribute:: PolylinePath.is_closed

        ``True`` if polyline path is closed.

    .. attribute:: vertices

        List of path vertices as (x, y, bulge)-tuples. (read/write)

    .. attribute:: source_boundary_objects

        List of handles of the associated DXF entities for associative hatches.
        There is no support for associative hatches by `ezdxf`, you have to do
        it all by yourself. (read/write)

    .. automethod:: set_vertices

    .. automethod:: clear


.. class:: EdgePath

    Boundary path build by edges. There are four different edge types:
    :class:`LineEdge`, :class:`ArcEdge`, :class:`EllipseEdge` of :class:`SplineEdge`.
    Make sure there are no gaps between edges and the edge path must be closed
    to be recognized as path. AutoCAD is very picky in this regard.
    `Ezdxf` performs no checks on gaps between the edges and does not prevent
    creating open loops.

    .. note::

        :class:`ArcEdge` and :class:`EllipseEdge` are ALWAYS represented in
        counter-clockwise orientation, even if an clockwise oriented edge is
        required to build a closed loop. To add a clockwise oriented curve swap
        start- and end angles and set the `ccw` flag to `False` and `ezdxf`
        will export a correct clockwise orientated curve.

    .. attribute:: type

        Path type as :attr:`BoundaryPathType.EDGE` enum

    .. attribute:: path_type_flags

        (bit coded flags)

        === ==============
        0   default
        1   external
        16  outermost
        === ==============

        see :attr:`PolylinePath.path_type_flags`

    .. attribute:: edges

        List of boundary edges of type :class:`LineEdge`, :class:`ArcEdge`,
        :class:`EllipseEdge` of :class:`SplineEdge`

    .. attribute:: source_boundary_objects

        Required for associative hatches, list of handles to the associated DXF
        entities.

    .. automethod:: clear

    .. automethod:: add_line

    .. automethod:: add_arc

    .. automethod:: add_ellipse

    .. automethod:: add_spline

    .. automethod:: close_gaps


.. class:: EdgeType

    .. attribute:: LINE

    .. attribute:: ARC

    .. attribute:: ELLIPSE

    .. attribute:: SPLINE


.. class:: LineEdge

    Straight boundary edge.

    .. attribute:: type

        Edge type as :attr:`EdgeType.LINE` enum

    .. attribute:: start

        Start point as (x, y)-tuple. (read/write)

    .. attribute:: end

        End point as (x, y)-tuple. (read/write)


.. class:: ArcEdge

    Arc as boundary edge in counter-clockwise orientation,
    see :meth:`EdgePath.add_arc`.

    .. attribute:: type

        Edge type as :attr:`EdgeType.ARC` enum

    .. attribute:: center

        Center point of arc as (x, y)-tuple. (read/write)

    .. attribute:: radius

        Arc radius as float. (read/write)

    .. attribute:: start_angle

        Arc start angle in counter-clockwise orientation in degrees. (read/write)

    .. attribute:: end_angle

        Arc end angle in counter-clockwise orientation in degrees. (read/write)

    .. attribute:: ccw

        ``True`` for counter clockwise arc else ``False``. (read/write)


.. class:: EllipseEdge

    Elliptic arc as boundary edge in counter-clockwise orientation,
    see :meth:`EdgePath.add_ellipse`.

    .. attribute:: type

        Edge type as :attr:`EdgeType.ELLIPSE` enum

    .. attribute:: major_axis_vector

        Ellipse major axis vector as (x, y)-tuple. (read/write)

    .. attribute:: minor_axis_length

        Ellipse minor axis length as float. (read/write)

    .. attribute:: radius

        Ellipse radius as float. (read/write)

    .. attribute:: start_angle

        Ellipse start angle in counter-clockwise orientation in degrees. (read/write)

    .. attribute:: end_angle

        Ellipse end angle in counter-clockwise orientation in degrees. (read/write)

    .. attribute:: ccw

        ``True`` for counter clockwise ellipse else ``False``. (read/write)


.. class:: SplineEdge

    Spline as boundary edge.

    .. attribute:: type

        Edge type as :attr:`EdgeType.SPLINE` enum

    .. attribute:: degree

        Spline degree as int. (read/write)

    .. attribute:: rational

        1 for rational spline else 0. (read/write)

    .. attribute:: periodic

        1 for periodic spline else 0. (read/write)

    .. attribute:: knot_values

        List of knot values as floats. (read/write)

    .. attribute:: control_points

        List of control points as (x, y)-tuples. (read/write)

    .. attribute:: fit_points

        List of fit points as (x, y)-tuples. (read/write)

    .. attribute:: weights

        List of weights (of control points) as floats. (read/write)

    .. attribute:: start_tangent

        Spline start tangent (vector) as (x, y)-tuple. (read/write)

    .. attribute:: end_tangent

        Spline end tangent (vector)  as (x, y)-tuple. (read/write)


Hatch Pattern Definition Classes
--------------------------------

.. class:: Pattern

    .. attribute:: lines

        List of pattern definition lines (read/write). see :class:`PatternLine`

    .. automethod:: add_line

    .. automethod:: clear

    .. automethod:: scale


.. class:: PatternLine

    Represents a pattern definition line, use factory function :meth:`Pattern.add_line`
    to create new pattern definition lines.

    .. attribute:: angle

        Line angle in degrees. (read/write)

    .. attribute:: base_point

        Base point as (x, y)-tuple. (read/write)

    .. attribute:: offset

        Offset as (x, y)-tuple. (read/write)

    .. attribute:: dash_length_items

        List of dash length items (item > 0 is line, < 0 is gap, 0.0 = dot). (read/write)

Hatch Gradient Fill Class
-------------------------

.. class:: Gradient

    .. attribute:: color1

        First rgb color as (r, g, b)-tuple, rgb values in range 0 to 255. (read/write)

    .. attribute:: color2

        Second rgb color as (r, g, b)-tuple, rgb values in range 0 to 255. (read/write)

    .. attribute:: one_color

        If :attr:`one_color` is 1 - the hatch is filled with a smooth transition between
        :attr:`color1` and a specified :attr:`tint` of :attr:`color1`. (read/write)

    .. attribute:: rotation

        Gradient rotation in degrees. (read/write)

    .. attribute:: centered

        Specifies a symmetrical gradient configuration. If this option is not
        selected, the gradient fill is shifted up and to the left, creating the
        illusion of a light source to the left of the object. (read/write)

    .. attribute:: tint

        Specifies the tint (:attr:`color1` mixed with white) of a color to be
        used for a gradient fill of one color. (read/write)

.. seealso::

    :ref:`tut_hatch_pattern`


--- End of file: dxfentities/hatch.rst ---



--- Start of file: dxfentities/helix.rst ---

Helix
=====

.. module:: ezdxf.entities
    :noindex:


The HELIX entity (`DXF Reference`_).

The helix curve is represented by a cubic B-spline curve, therefore the HELIX
entity is also derived from the SPLINE entity.

.. seealso::

    - `Wikipedia`_ article about the helix shape

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Spline`
DXF type                 ``'HELIX'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_helix`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. _DXF Reference: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-76DB3ABF-3C8C-47D1-8AFB-72942D9AE1FF

.. class:: Helix

    All points in :ref:`WCS` as (x, y, z) tuples

    .. attribute:: dxf.axis_base_point

        The base point of the helix axis (Vec3).

    .. attribute:: dxf.start_point

        The starting point of the helix curve (Vec3).
        This also defines the base radius as the distance from the start point
        to the axis base point.

    .. attribute:: dxf.axis_vector

        Defines the direction of the helix axis (Vec3).

    .. attribute:: dxf.radius

        Defines the top radius of the helix (float).

    .. attribute:: dxf.turn_height

        Defines the pitch (height if one helix turn) of the helix  (float).

    .. attribute:: dxf.turns

        The count of helix turns (float).

    .. attribute:: dxf.handedness

        Helix orientation (int).

        === ================================
        0   clock wise (left handed)
        1   counter clockwise (right handed)
        === ================================

    .. attribute:: dxf.constrain

        === =========================
        0   constrain turn height (pitch)
        1   constrain count of turns
        2   constrain total height
        === =========================

.. _Wikipedia: https://en.wikipedia.org/wiki/Helix


--- End of file: dxfentities/helix.rst ---



--- Start of file: dxfentities/image.rst ---

Image
=====

.. module:: ezdxf.entities
    :noindex:

The IMAGE entity (`DXF Reference`_) represents a raster image, the image file itself is
not embedded into the DXF file, it is always a separated file.
The IMAGE entity is like a block reference, it can be used to add the image multiple times
at different locations with different scale and rotation angles.  Every IMAGE entity
requires an image definition, see entity :class:`ImageDef`.
`Ezdxf` creates only images in the xy-plan, it's possible to place images in 3D space,
therefore the :attr:`Image.dxf.u_pixel` and the :attr:`Image.dxf.v_pixel` vectors
has to be set accordingly.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'IMAGE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_image`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. class:: Image

    .. attribute:: dxf.insert

        Insertion point, lower left corner of the image (3D Point in :ref:`WCS`).

    .. attribute:: dxf.u_pixel

        U-vector of a single pixel as (x, y, z) tuple. This vector points along the
        visual bottom of the image, starting at the insertion point.

    .. attribute:: dxf.v_pixel

        V-vector of a single pixel as (x, y, z) tuple. This vector points along the
        visual left side of the image, starting at the insertion point.

    .. attribute:: dxf.image_size

        Image size in pixels as (x, y) tuple

    .. attribute:: dxf.image_def_handle

        Handle to the image definition entity, see :class:`ImageDef`

    .. attribute:: dxf.flags

        =================================== ======= ===========
        :attr:`Image.SHOW_IMAGE`            1       Show image
        :attr:`Image.SHOW_WHEN_NOT_ALIGNED` 2       Show image when not aligned with screen
        :attr:`Image.USE_CLIPPING_BOUNDARY` 4       Use clipping boundary
        :attr:`Image.USE_TRANSPARENCY`      8       Transparency is on
        =================================== ======= ===========

    .. attribute:: dxf.clipping

        Clipping state:

        === ============
        0   clipping off
        1   clipping on
        === ============

    .. attribute:: dxf.brightness

        Brightness value in the range [0, 100], default is 50

    .. attribute:: dxf.contrast

        Contrast value in the range [0, 100], default is 50

    .. attribute:: dxf.fade

        Fade value in the range [0, 100], default is 0

    .. attribute:: dxf.clipping_boundary_type

        === ============
        1   Rectangular
        2   Polygonal
        === ============

    .. attribute:: dxf.count_boundary_points

        Number of clip boundary vertices, this attribute is maintained by `ezdxf`.

    .. attribute:: Image.dxf.clip_mode

        === ========
        0   Outside
        1   Inside
        === ========

        requires DXF R2010 or newer

    .. autoattribute:: boundary_path

    .. autoattribute:: image_def

    .. automethod:: reset_boundary_path

    .. automethod:: set_boundary_path

    .. automethod:: pixel_boundary_path
    
    .. automethod:: boundary_path_wcs

    .. automethod:: transform

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-3A2FF847-BE14-4AC5-9BD4-BD3DCAEF2281

--- End of file: dxfentities/image.rst ---



--- Start of file: dxfentities/index.rst ---

DXF Entities
============

.. module:: ezdxf.entities

All DXF entities can only reside in the :class:`~ezdxf.layouts.BaseLayout`
and inherited classes like :class:`~ezdxf.layouts.Modelspace`,
:class:`~ezdxf.layouts.Paperspace` and :class:`~ezdxf.layouts.BlockLayout`.

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. toctree::
    :maxdepth: 1

    dxfentity
    dxfgfx
    3dface
    3dsolid
    acad_proxy_entity
    arc
    ../blocks/attrib
    body
    circle
    dimension
    arcdim
    ellipse
    hatch
    helix
    image
    ../blocks/insert
    leader
    line
    lwpolyline
    mline
    mesh
    mpolygon
    mtext
    mleader
    point
    polyline
    ray
    region
    shape
    solid
    spline
    surface
    text
    trace
    underlay
    viewport
    wipeout
    xline

--- End of file: dxfentities/index.rst ---



--- Start of file: dxfentities/leader.rst ---

Leader
======

.. module:: ezdxf.entities
    :noindex:

The LEADER entity (`DXF Reference`_) represents a pointer line, made up of one or more
vertices (or spline fit points) and an arrowhead. The label or other content to which
the :class:`Leader` is attached is stored as a separate entity, and is not part of
the :class:`Leader` itself.

The LEADER entity uses parts of the styling infrastructure of the DIMENSION entity.

By default a :class:`Leader` without any annotation is created. For creating more fancy
leaders and annotations see the documentation provided by Autodesk or
`Demystifying DXF: LEADER and MULTILEADER implementation notes <https://atlight.github.io/formats/dxf-leader.html>`_  .

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'LEADER'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_leader`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-396B2369-F89F-47D7-8223-8B7FB794F9F3

.. class:: Leader

    .. attribute:: dxf.dimstyle

        Name of :class:`Dimstyle` as string.

    .. attribute:: dxf.has_arrowhead

        == ============
        0  Disabled
        1  Enabled
        == ============

    .. attribute:: dxf.path_type

        Leader path type:

        == ==========================
        0  Straight line segments
        1  Spline
        == ==========================


    .. attribute:: dxf.annotation_type

        == ===========================================
        0  Created with text annotation
        1  Created with tolerance annotation
        2  Created with block reference annotation
        3  Created without any annotation (default)
        == ===========================================

    .. attribute:: dxf.hookline_direction

        Hook line direction flag:

        == =================================================================
        0  Hookline (or end of tangent for a splined leader) is the opposite
           direction from the horizontal vector
        1  Hookline (or end of tangent for a splined leader) is the same
           direction as horizontal vector (see ``has_hook_line``)
        == =================================================================

    .. attribute:: dxf.has_hookline

        == ==================
        0  No hookline
        1  Has a hookline
        == ==================

    .. attribute:: dxf.text_height

        Text annotation height in drawing units.

    .. attribute:: dxf.text_width

        Text annotation width.

    .. attribute:: dxf.block_color

        Color to use if leader's DIMCLRD = BYBLOCK

    .. attribute:: dxf.annotation_handle

        Hard reference (handle) to associated annotation (:class:`MText`, :class:`Tolerance`,
        or :class:`Insert` entity)

    .. attribute:: dxf.normal_vector

        Extrusion vector? default is (0, 0, 1).

    .. attribute:: .dxf.horizontal_direction

        `Horizontal` direction for leader, default is (1, 0, 0).

    .. attribute:: dxf.leader_offset_block_ref

        Offset of last leader vertex from block reference insertion point, default is
        (0, 0, 0).

    .. attribute:: dxf.leader_offset_annotation_placement

        Offset of last leader vertex from annotation placement point, default
        (0, 0, 0).


    .. attribute:: vertices

        List of :class:`~ezdxf.math.Vec3` objects, representing the vertices of the
        leader (3D Point in :ref:`WCS`).

    .. automethod:: set_vertices

    .. automethod:: transform

    .. automethod:: virtual_entities

    .. automethod:: explode


--- End of file: dxfentities/leader.rst ---



--- Start of file: dxfentities/line.rst ---

Line
====

.. module:: ezdxf.entities
    :noindex:

The LINE entity (`DXF Reference`_) is a 3D line defined by the DXF attributes
:attr:`dxf.start` and :attr:`dxf.end`. The LINE entity has :ref:`WCS` coordinates.

.. seealso::

    - :ref:`tut_dxf_primitives`, section :ref:`tut_dxf_primitives_line`
    - :class:`ezdxf.math.ConstructionRay`
    - :class:`ezdxf.math.ConstructionLine`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'LINE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_line`
Inherited DXF Attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided
    factory functions!

.. class:: Line


    .. attribute:: dxf.start

        start point of line (2D/3D Point in :ref:`WCS`)

    .. attribute:: dxf.end

        end point of line (2D/3D Point in :ref:`WCS`)

    .. attribute:: dxf.thickness

        Line thickness in 3D space in direction :attr:`extrusion`, default value
        is 0. This value should not be confused with the
        :attr:`~ezdxf.entities.DXFGraphic.dxf.lineweight` value.

    .. attribute:: dxf.extrusion

        extrusion vector, default value is (0, 0, 1)

    .. automethod:: transform

    .. automethod:: translate

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-FCEF5726-53AE-4C43-B4EA-C84EB8686A66

--- End of file: dxfentities/line.rst ---



--- Start of file: dxfentities/lwpolyline.rst ---

LWPolyline
==========

.. module:: ezdxf.entities
    :noindex:

The LWPOLYLINE entity (Lightweight POLYLINE, `DXF Reference`_) is defined as 
a single graphic entity, which differs from the old-style :class:`Polyline` 
entity, which is defined as a group of sub-entities. :class:`LWPolyline` 
display faster (in AutoCAD) and consume less disk space, it is a planar 
element, therefore all points are located in the :ref:`OCS` as (x, y)-tuples
(:attr:`LWPolyline.dxf.elevation` is the z-axis value).


======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'LWPOLYLINE'``
factory function         :meth:`~ezdxf.layouts.BaseLayout.add_lwpolyline`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-748FC305-F3F2-4F74-825A-61F04D757A50

.. _bulge value:

.. rubric:: Bulge value

The bulge value is used to create arc shaped line segments for :class:`Polyline`
and :class:`LWPolyline` entities. The arc starts at the vertex which includes
the bulge value and ends at the following vertex. The bulge value defines the
ratio of the arc sagitta (versine) to half line segment length, a bulge value
of 1 defines a semicircle.

The sign of the bulge value defines the side of the bulge:

    - positive value (> 0): bulge is right of line (counter clockwise)
    - negative value (< 0): bulge is left of line (clockwise)
    - 0 = no bulge

.. image:: ../tutorials/gfx/bulge.png

.. rubric:: Start- and end width

The start width and end width values defines the width in drawing units for the
following line segment. To use the default width value for a line segment set
value to 0.

.. rubric:: Width and bulge values at last point

The width and bulge values of the last point has only a meaning if the polyline
is closed, and they apply to the last line segment from the last to the first
point.

.. seealso::

    :ref:`tut_lwpolyline` and :ref:`bulge_related_functions`


.. _format codes:

User Defined Point Format Codes
-------------------------------


    ==== =====================
    Code Point Component
    ==== =====================
       x x-coordinate
       y y-coordinate
       s start width
       e end width
       b bulge value
       v (x, y [, z]) as tuple
    ==== =====================

.. class:: LWPolyline

    .. attribute:: dxf.elevation

        :ref:`OCS` z-axis value for all polyline points, default=0

    .. attribute:: dxf.flags

        Constants defined in :mod:`ezdxf.lldxf.const`:

        ============================== ======= ===========
        dxf.flags                      Value   Description
        ============================== ======= ===========
        LWPOLYLINE_CLOSED              1       polyline is closed
        LWPOLYLINE_PLINEGEN            128     linetype is generated across the points
        ============================== ======= ===========

    .. attribute:: dxf.const_width

        Constant line width (float), default value is 0.

    .. attribute:: dxf.count

        Count of polyline points (read only), same as :code:`len(polyline)`

    .. autoproperty:: closed

    .. autoproperty:: is_closed

    .. automethod:: close

    .. autoproperty:: has_arc

    .. autoproperty:: has_width

    .. automethod:: __len__

    .. automethod:: __getitem__

    .. automethod:: __setitem__

    .. automethod:: __delitem__

    .. automethod:: __iter__

    .. automethod:: vertices

    .. automethod:: vertices_in_wcs

    .. automethod:: append

    .. automethod:: append_points

    .. automethod:: insert

    .. automethod:: clear

    .. automethod:: get_points

    .. automethod:: set_points

    .. automethod:: points

    .. automethod:: transform

    .. automethod:: virtual_entities

    .. automethod:: explode


--- End of file: dxfentities/lwpolyline.rst ---



--- Start of file: dxfentities/mesh.rst ---

Mesh
====

.. module:: ezdxf.entities
    :noindex:

The MESH entity (`DXF Reference`_) is a 3D surface in :ref:`WCS` build up
from vertices and faces similar to the :class:`Polyface` entity.

All vertices in :ref:`WCS` as (x, y, z) tuples


======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'MESH'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_mesh`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. seealso::

    :ref:`tut_mesh` and helper classes: :class:`~ezdxf.render.MeshBuilder`,
    :class:`~ezdxf.render.MeshVertexMerger`

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-4B9ADA67-87C8-4673-A579-6E4C76FF7025

.. class:: Mesh

    .. attribute:: dxf.version

    .. attribute:: dxf.blend_crease

        0 = off, 1 = on

    .. attribute:: dxf.subdivision_levels

        0 for no smoothing else integer greater than 0.

    .. autoattribute:: vertices

    .. autoattribute:: edges

    .. autoattribute:: faces

    .. autoattribute:: creases

    .. automethod:: edit_data

    .. automethod:: transform

MeshData
--------

.. class:: MeshData

    .. attribute:: vertices

        A standard Python list with (x, y, z) tuples (read/write)

    .. attribute:: faces

        A standard Python list with (v1, v2, v3,...) tuples (read/write)

        Each face consist of a list of vertex indices (= index in :attr:`vertices`).

    .. attribute:: edges

        A Python list with (v1, v2) tuples (read/write). This list
        represents the edges to which the :attr:`edge_crease_values` values
        will be applied. Each edge consist of exact two vertex indices
        (= index in :attr:`vertices`).

    .. attribute:: edge_crease_values

        A Python list of float values, one value for each edge. (read/write)

    .. automethod:: add_face

    .. automethod:: add_edge_crease

    .. automethod:: optimize




--- End of file: dxfentities/mesh.rst ---



--- Start of file: dxfentities/mleader.rst ---

MultiLeader
===========

.. module:: ezdxf.entities
    :noindex:

The MULTILEADER entity (`DXF Reference`_) represents one or more leaders,
made up of one or more vertices (or spline fit points) and an arrowhead.
In contrast to the :class:`Leader` entity the text- or block content is part of
the MULTILEADER entity.

AutoCAD, BricsCAD and maybe other CAD applications do accept "MLEADER" as
type string but they always create entities with "MULTILEADER" as type
string.

Because of the complexity of the MULTILEADER entity, the usage of factory methods to
create new entities by special builder classes is recommended:

- :meth:`~ezdxf.layouts.BaseLayout.add_multileader_mtext` returns a new
  :class:`~ezdxf.render.MultiLeaderMTextBuilder` instance
- :meth:`~ezdxf.layouts.BaseLayout.add_multileader_block` returns a new
  :class:`~ezdxf.render.MultiLeaderBlockBuilder` instance

The visual design is based on an associated :class:`~ezdxf.entities.MLeaderStyle`,
but almost all attributes are also stored in the MULTILEADER entity itself.

The attribute :attr:`MultiLeader.dxf.property_override_flags` should indicate
which MLEADERSTYLE attributes are overridden by MULTILEADER attributes,
but these flags do not always reflect the state of overridden attributes.
The `ezdxf` MULTILEADER renderer uses always the attributes from
the MULTILEADER entity and ignores the override flags.

All vertices are WCS coordinates, even those for BLOCK entities which are OCS
coordinates for regular usage.

.. seealso::

    - :class:`ezdxf.entities.MLeaderStyle`
    - :class:`ezdxf.render.MultiLeaderBuilder`
    - :ref:`tut_mleader`
    - :ref:`MLEADER Internals`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'MULTILEADER'``
Factory functions        - :meth:`ezdxf.layouts.BaseLayout.add_multileader_mtext`
                         - :meth:`ezdxf.layouts.BaseLayout.add_multileader_block`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. _DXF Reference: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-72D20B8C-0F5E-4993-BEB7-0FCF94F32BE0


.. class:: MultiLeader

    .. attribute:: dxf.arrow_head_handle

        handle of the arrow head, see also :mod:`ezdxf.render.arrows` module,
        "closed filled" arrow if not set

    .. attribute:: dxf.arrow_head_size

        arrow head size in drawing units

    .. attribute:: dxf.block_color

        block color as :term:`raw-color` value, default is BY_BLOCK_RAW_VALUE

    .. attribute:: dxf.block_connection_type

        === ================
        0   center extents
        1   insertion point
        === ================

    .. attribute:: dxf.block_record_handle

        handle to block record of the BLOCK content

    .. attribute:: dxf.block_rotation

        BLOCK rotation in radians

    .. attribute:: dxf.block_scale_vector

        :class:`Vec3` object which stores the scaling factors for the x-, y-
        and z-axis

    .. attribute:: dxf.content_type

        === =========
        0   none
        1   BLOCK
        2   MTEXT
        3   TOLERANCE
        === =========

    .. attribute:: dxf.dogleg_length

        dogleg length in drawing units

    .. attribute:: dxf.has_dogleg

    .. attribute:: dxf.has_landing

    .. attribute:: dxf.has_text_frame

    .. attribute:: dxf.is_annotative

    .. attribute:: dxf.is_text_direction_negative

    .. attribute:: dxf.leader_extend_to_text

    .. attribute:: dxf.leader_line_color

         leader line color as :term:`raw-color` value

    .. attribute:: dxf.leader_linetype_handle

        handle of the leader linetype, "CONTINUOUS" if not set

    .. attribute:: dxf.leader_lineweight

    .. attribute:: dxf.leader_type

        === ====================
        0   invisible
        1   straight line leader
        2   spline leader
        === ====================

    .. attribute:: dxf.property_override_flags

        Each bit shows if the MLEADERSTYLE is overridden by the value in the
        MULTILEADER entity, but this is not always the case for all values,
        it seems to be save to always use the value from the MULTILEADER entity.

    .. attribute:: dxf.scale

        overall scaling factor

    .. attribute:: dxf.style_handle

        handle to the associated MLEADERSTYLE object

    .. attribute:: dxf.text_IPE_align

        unknown meaning

    .. attribute:: dxf.text_alignment_type

        unknown meaning - its not the MTEXT attachment point!

    .. attribute:: dxf.text_angle_type

        === =======================================================
        0   text angle is equal to last leader line segment angle
        1   text is horizontal
        2   text angle is equal to last leader line segment angle, but potentially
            rotated by 180 degrees so the right side is up for readability.
        === =======================================================

    .. attribute:: dxf.text_attachment_direction

        defines whether the leaders attach to the left & right of the content
        BLOCK/MTEXT or attach to the top & bottom:

        === =====================================
        0   horizontal - left & right of content
        1   vertical - top & bottom of content
        === =====================================

    .. attribute:: dxf.text_attachment_point

        MTEXT attachment point

        === =============
        1   top left
        2   top center
        3   top right
        === =============

    .. attribute:: dxf.text_bottom_attachment_type

        === ===============================
        9   center
        10  overline and center
        === ===============================

    .. attribute:: dxf.text_color

        MTEXT color as :term:`raw-color` value

    .. attribute:: dxf.text_left_attachment_type

        === ========================================================
        0   top of top MTEXT line
        1   middle of top MTEXT line
        2   middle of whole MTEXT
        3   middle of bottom MTEXT line
        4   bottom of bottom MTEXT line
        5   bottom of bottom MTEXT line & underline bottom MTEXT line
        6   bottom of top MTEXT line & underline top MTEXT line
        7   bottom of top MTEXT line
        8   bottom of top MTEXT line & underline all MTEXT lines
        === ========================================================

    .. attribute:: dxf.text_right_attachment_type

        === ========================================================
        0   top of top MTEXT line
        1   middle of top MTEXT line
        2   middle of whole MTEXT
        3   middle of bottom MTEXT line
        4   bottom of bottom MTEXT line
        5   bottom of bottom MTEXT line & underline bottom MTEXT line
        6   bottom of top MTEXT line & underline top MTEXT line
        7   bottom of top MTEXT line
        8   bottom of top MTEXT line & underline all MTEXT lines
        === ========================================================

    .. attribute:: dxf.text_style_handle

        handle of the MTEXT text style, "Standard" if not set

    .. attribute:: dxf.text_top_attachment_type

        === ===============================
        9   center
        10  overline and center
        === ===============================

    .. attribute:: dxf.version

        always 2?

    .. attribute:: context

        :class:`MLeaderContext` instance

    .. attribute:: arrow_heads

        list of :class:`ArrowHeadData`

    .. attribute:: block_attribs

        list of :class:`AttribData`

    .. autoproperty:: has_mtext_content

    .. automethod:: get_mtext_content

    .. automethod:: set_mtext_content

    .. autoproperty:: has_block_content

    .. automethod:: get_block_content

    .. automethod:: set_block_content

    .. automethod:: virtual_entities

    .. automethod:: explode

    .. automethod:: transform

.. class:: MLeaderContext

    .. attribute:: leaders

        list of :class:`LeaderData` objects

    .. attribute:: scale

        redundant data: :attr:`MultiLeader.dxf.scale`

    .. attribute:: base_point

        insert location as :class:`Vec3` of the MTEXT or the BLOCK entity?

    .. attribute:: char_height

        MTEXT char height, already scaled

    .. attribute:: arrow_head_size

        redundant data: :attr:`MultiLeader.dxf.arrow_head_size`

    .. attribute:: landing_gap_size

    .. attribute:: left_attachment

        redundant data: :attr:`MultiLeader.dxf.text_left_attachment_type`

    .. attribute:: right_attachment

        redundant data: :attr:`MultiLeader.dxf.text_right_attachment_type`

    .. attribute:: text_align_type

        redundant data: :attr:`MultiLeader.dxf.text_attachment_point`

    .. attribute:: attachment_type

        BLOCK alignment?

        === ===============
        0   content extents
        1   insertion point
        === ===============

    .. attribute:: mtext

        instance of :class:`MTextData` if content is MTEXT otherwise ``None``

    .. attribute:: block

        instance of :class:`BlockData` if content is BLOCK otherwise ``None``

    .. attribute:: plane_origin

        :class:`Vec3`

    .. attribute:: plane_x_axis

        :class:`Vec3`

    .. attribute:: plane_y_axis

        :class:`Vec3`

    .. attribute:: plane_normal_reversed

        the plan normal is x-axis "cross" y-axis (right-hand-rule), this flag
        indicates to invert this plan normal

    .. attribute:: top_attachment

        redundant data: :attr:`MultiLeader.dxf.text_top_attachment_type`

    .. attribute:: bottom_attachment

        redundant data: :attr:`MultiLeader.dxf.text_bottom_attachment_type`

.. class:: LeaderData

    .. attribute:: lines

        list of :class:`LeaderLine`

    .. attribute:: has_last_leader_line

        unknown meaning

    .. attribute:: has_dogleg_vector

    .. attribute:: last_leader_point

        WCS point as :class:`Vec3`

    .. attribute:: dogleg_vector

        WCS direction as :class:`Vec3`

    .. attribute:: dogleg_length

        redundant data: :attr:`MultiLeader.dxf.dogleg_length`

    .. attribute:: index

        leader index?

    .. attribute:: attachment_direction

        redundant data: :attr:`MultiLeader.dxf.text_attachment_direction`

    .. attribute:: breaks

        list of break vertices as :class:`Vec3` objects

.. class:: LeaderLine

    .. attribute:: vertices

        list of WCS coordinates as :class:`Vec3`

    .. attribute:: breaks

        mixed list of mixed integer indices and break coordinates
        or ``None`` leader lines without breaks in it

    .. attribute:: index

        leader line index?

    .. attribute:: color

        leader line color override, ignore override value if BY_BLOCK_RAW_VALUE

.. class:: ArrowHeadData

    .. attribute:: index

        arrow head index?

    .. attribute:: handle

        handle to arrow head block

.. class:: AttribData

    .. attribute:: handle

        handle to :class:`Attdef` entity in the BLOCK definition

    .. attribute:: index

        unknown meaning

    .. attribute:: width

        text width factor?

    .. attribute:: text

        :class:`Attrib` content

.. class:: MTextData

    stores the content and attributes of the MTEXT entity

    .. attribute:: default_content

        content as string

    .. attribute:: extrusion

        extrusion vector of the MTEXT entity but MTEXT is not an OCS entity!

    .. attribute:: style_handle

        redundant data: :attr:`MultiLeader.dxf.text_style_handle`

    .. attribute:: insert

        insert location in WCS coordinates, same as
        :attr:`MLeaderContext.base_point`?

    .. attribute:: text_direction

        "horizontal" text direction vector in WCS

    .. attribute:: rotation

        rotation angle in radians (!) around the extrusion vector, calculated
        as it were an OCS entity

    .. attribute:: width

        unscaled column width

    .. attribute:: defined_height

        unscaled defined column height

    .. attribute:: line_spacing_factor

        see :attr:`MText.dxf.line_spacing_factor`

    .. attribute:: line_spacing_style

        see :attr:`MText.dxf.line_spacing_style`

    .. attribute:: color

        redundant data: :attr:`MultiLeader.dxf.text_color`

    .. attribute:: alignment

        redundant data: :attr:`MultiLeader.dxf.text_attachment_point`

    .. attribute:: flow_direction

        === ==================
        1   horizontal
        3   vertical
        6   by text style
        === ==================

    .. attribute:: bg_color

        background color as :term:`raw-color` value

    .. attribute:: bg_scale_factor

        see :attr:`MText.dxf.box_fill_scale`

    .. attribute:: bg_transparency

        background transparency value

    .. attribute:: use_window_bg_color

    .. attribute:: has_bg_fill

    .. attribute:: column_type

        unknown meaning - most likely:

        === ========
        0   none
        1   static
        2   dynamic
        === ========

    .. attribute:: use_auto_height

    .. attribute:: column_width

        unscaled column width, redundant data :attr:`width`

    .. attribute:: column_gutter_width

        unscaled column gutter width

    .. attribute:: column_flow_reversed

    .. attribute:: column_sizes

        list of unscaled columns heights for dynamic column with manual heights

    .. attribute:: use_word_break

.. class:: BlockData

    stores the attributes for the :class:`Insert` entity

    .. attribute:: block_record_handle

        redundant data: :attr:`MultiLeader.dxf.block_record_handle`

    .. attribute:: extrusion

        extrusion vector in WCS

    .. attribute:: insert

        insertion location in WCS as :class:`Vec3`, same as
        :attr:`MLeaderContext.base_point`?

    .. attribute:: scale

        redundant data: :attr:`MultiLeader.dxf.block_scale_vector`

    .. attribute:: rotation

        redundant data: :attr:`MultiLeader.dxf.block_rotation`

    .. attribute:: color

        redundant data: :attr:`MultiLeader.dxf.block_color`



--- End of file: dxfentities/mleader.rst ---



--- Start of file: dxfentities/mline.rst ---

MLine
=====

.. module:: ezdxf.entities
    :noindex:

The MLINE entity (`DXF Reference`_).


======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'MLINE'``
factory function         :meth:`~ezdxf.layouts.BaseLayout.add_mline`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-590E8AE3-C6D9-4641-8485-D7B3693E432C

.. class:: MLine

    .. attribute:: dxf.style_name

        :class:`MLineStyle` name stored in :attr:`Drawing.mline_styles`
        dictionary, use :meth:`~MLine.set_style` to change the MLINESTYLE
        and update geometry accordingly.

    .. attribute:: dxf.style_handle

        Handle of :class:`MLineStyle`, use :meth:`~MLine.set_style` to change
        the MLINESTYLE and update geometry accordingly.

    .. attribute:: dxf.scale_factor

        MLINE scaling factor, use method :meth:`~MLine.set_scale_factor`
        to change the scaling factor and update geometry accordingly.

    .. attribute:: dxf.justification

        Justification defines the location of the MLINE in relation to
        the reference line, use method :meth:`~MLine.set_justification`
        to change the justification and update geometry accordingly.

        Constants defined in :mod:`ezdxf.lldxf.const`:

        ============================== =======
        dxf.justification              Value
        ============================== =======
        MLINE_TOP                      0
        MLINE_ZERO                     1
        MLINE_BOTTOM                   2
        MLINE_RIGHT (alias)            0
        MLINE_CENTER (alias)           1
        MLINE_LEFT (alias)             2
        ============================== =======

    .. attribute:: dxf.flags

        Use method :meth:`~MLine.close` and the properties :attr:`~MLine.start_caps`
        and :attr:`~MLine.end_caps` to change these flags.

        Constants defined in :mod:`ezdxf.lldxf.const`:

        ============================== =======
        dxf.flags                      Value
        ============================== =======
        MLINE_HAS_VERTEX               1
        MLINE_CLOSED                   2
        MLINE_SUPPRESS_START_CAPS      4
        MLINE_SUPPRESS_END_CAPS        8
        ============================== =======

    .. attribute:: dxf.start_location

        Start location of the reference line. (read only)

    .. attribute:: dxf.count

        Count of MLINE vertices. (read only)

    .. attribute:: dxf.style_element_count

        Count of elements in :class:`MLineStyle` definition. (read only)

    .. attribute:: dxf.extrusion

        Normal vector of the entity plane, but MLINE is not an OCS entity, all
        vertices of the reference line are WCS! (read only)

    .. attribute:: vertices

        MLINE vertices as :class:`MLineVertex` objects, stored in a
        regular Python list.

    .. autoproperty:: style

    .. automethod:: set_style

    .. automethod:: set_scale_factor

    .. automethod:: set_justification

    .. autoproperty:: is_closed

    .. automethod:: close

    .. autoproperty:: start_caps

    .. autoproperty:: end_caps

    .. automethod:: __len__

    .. automethod:: start_location

    .. automethod:: get_locations

    .. automethod:: extend

    .. automethod:: clear

    .. automethod:: update_geometry

    .. automethod:: generate_geometry

    .. automethod:: transform

    .. automethod:: virtual_entities

    .. automethod:: explode

.. class:: MLineVertex

    .. attribute:: location

        Reference line vertex location.

    .. attribute:: line_direction

        Reference line direction.

    .. attribute:: miter_direction

    .. attribute:: line_params

        The line parameterization is a list of float values. The list may
        contain zero or more items.

        The first value (miter-offset) is the distance from the vertex
        :attr:`location` along the :attr:`miter_direction` vector to the
        point where the line element's path intersects the miter vector.

        The next value (line-start-offset) is the distance along the
        :attr:`line_direction` from the miter/line path intersection point to
        the actual start of the line element.

        The next value (dash-length) is the distance from the start of the
        line element (dash) to the first break (gap) in the line element.
        The successive values continue to list the start and stop points of
        the line element in this segment of the mline.

    .. attribute:: fill_params

        The fill parameterization is also a list of float values.
        Similar to the line parameterization, it describes the
        parameterization of the fill area for this mline segment.
        The values are interpreted identically to the line parameters and when
        taken as a whole for all line elements in the mline segment, they
        define the boundary of the fill area for the mline segment.

.. class:: MLineStyle

    The :class:`MLineStyle` stores the style properties for the MLINE entity.

    .. attribute:: dxf.name

    .. attribute:: dxf.description

    .. attribute:: dxf.flags

    .. attribute:: dxf.fill_color

        :ref:`ACI` value of the fill color

    .. attribute:: dxf.start_angle

    .. attribute:: dxf.end_angle

    .. attribute:: elements

        :class:`~ezdxf.entities.mline.MLineStyleElements` object

    .. automethod:: update_all

.. class:: ezdxf.entities.mline.MLineStyleElements

    .. attribute:: elements

        List of :class:`~ezdxf.entities.mline.MLineStyleElement` objects, one
        for each line element.

    .. automethod:: __len__

    .. automethod:: __getitem__

    .. automethod:: append

.. class:: ezdxf.entities.mline.MLineStyleElement

    Named tuple to store properties of a line element.

    .. attribute:: offset

        Normal offset from the reference line: if justification is ``MLINE_ZERO``,
        positive values are above and negative values are below the reference
        line.

    .. attribute:: color

        :ref:`ACI` value

    .. attribute:: linetype

        Linetype name

--- End of file: dxfentities/mline.rst ---



--- Start of file: dxfentities/mpolygon.rst ---

MPolygon
========

.. module:: ezdxf.entities
    :noindex:

The MPOLYGON entity is not a core DXF entity and is not supported by all CAD
applications and DXF libraries.
The :class:`MPolygon` class is very similar to the :class:`Hatch` class with
small differences in the supported features and DXF attributes.

The boundary paths of the MPOLYGON are visible and use the graphical DXF
attributes of the main entity like :attr:`dxf.color`, :attr:`dxf.linetype` and so on.
The solid filling is only visible if the attribute :attr:`dxf.solid_fill` is 1,
the color of the solid fill is defined by :attr:`dxf.fill_color` as :ref:`ACI`.
The MPOLYGON supports :class:`ezdxf.entities.Gradient` settings like HATCH
for DXF R2004 and newer. This feature is used by method :meth:`MPolygon.set_solid_fill`
to set a solid RGB fill color as linear gradient, this disables pattern fill
automatically.
The MPOLYGON does not support associated source path entities, because the
MPOLYGON also represents the boundary paths as visible graphical objects.
Hatch patterns are supported, but the hatch style tag is not supported, the
default hatch style is :attr:`ezdxf.const.HATCH_STYLE_NESTED` and the style
flags of the boundary paths are ignored.
Background color for pattern fillings is supported, set background color
by property :attr:`MPolygon.bgcolor` as RGB tuple.

.. note::

    Background RGB fill color for solid fill and pattern fill is set
    differently!

Autodesk products do support polyline paths including bulges.
An example for edge paths as boundary paths is not available or edge paths
are not supported. `Ezdxf` does **not** export MPOLYGON entities including
edge paths! The :meth:`BoundaryPaths.edge_to_polyline_paths` method converts
all edge paths to simple polyline paths with approximated curves, this
conversion has to be done explicit.

.. seealso::

    For more information see the :class:`ezdxf.entities.Hatch` documentation.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'MPOLYGON'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_mpolygon`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. class:: MPolygon

    .. attribute:: dxf.pattern_name

        Pattern name as string

    .. attribute:: dxf.solid_fill

        === ==========================================================
        1   solid fill, better use: :meth:`MPolygon.set_solid_fill`
        0   pattern fill, better use: :meth:`MPolygon.set_pattern_fill`
        === ==========================================================

        (search AutoCAD help for more information)

    .. attribute:: dxf.pattern_type

        === ===================
        0   user
        1   predefined
        2   custom
        === ===================

    .. attribute:: dxf.pattern_angle

        Actual pattern angle in degrees (float). Changing this value does not
        rotate the pattern, use :meth:`~MPolygon.set_pattern_angle` for this task.

    .. attribute:: dxf.pattern_scale

        Actual pattern scaling factor (float). Changing this value does not
        scale the pattern use :meth:`~MPolygon.set_pattern_scale` for this task.

    .. attribute:: dxf.pattern_double

        1 = double pattern size else 0. (int)

    .. attribute:: dxf.elevation

       Z value represents the elevation height of the :ref:`OCS`. (float)

    .. attribute:: paths

        :class:`BoundaryPaths` object.

    .. attribute:: pattern

        :class:`Pattern` object.

    .. attribute:: gradient

        :class:`Gradient` object.

    .. autoproperty:: has_solid_fill

    .. autoproperty:: has_pattern_fill

    .. autoproperty:: has_gradient_data

    .. autoproperty:: bgcolor

    .. automethod:: set_pattern_definition

    .. automethod:: set_pattern_scale

    .. automethod:: set_pattern_angle

    .. automethod:: set_solid_fill

    .. automethod:: set_pattern_fill

    .. automethod:: set_gradient

    .. automethod:: transform



--- End of file: dxfentities/mpolygon.rst ---



--- Start of file: dxfentities/mtext.rst ---

MText
=====

.. module:: ezdxf.entities
    :noindex:

The MTEXT entity (`DXF Reference`_) fits a multiline text in a specified width but can
extend vertically to an indefinite length. You can format individual words or characters
within the :class:`MText`.

.. seealso::

    :ref:`tut_mtext`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'MTEXT'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_mtext`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. _DXF Reference: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-5E5DB93B-F8D3-4433-ADF7-E92E250D2BAB

.. class:: MText

    .. attribute:: dxf.insert

        Insertion point (3D Point in :ref:`OCS`)

    .. attribute:: dxf.char_height

        Initial text height (float); default=1.0

    .. attribute:: dxf.width

        Reference text width (float), forces text wrapping at given width.

    .. attribute:: dxf.attachment_point

        Constants defined in :mod:`ezdxf.lldxf.const`:

        ============================== =======
        MText.dxf.attachment_point     Value
        ============================== =======
        MTEXT_TOP_LEFT                 1
        MTEXT_TOP_CENTER               2
        MTEXT_TOP_RIGHT                3
        MTEXT_MIDDLE_LEFT              4
        MTEXT_MIDDLE_CENTER            5
        MTEXT_MIDDLE_RIGHT             6
        MTEXT_BOTTOM_LEFT              7
        MTEXT_BOTTOM_CENTER            8
        MTEXT_BOTTOM_RIGHT             9
        ============================== =======

    .. attribute:: dxf.flow_direction

        Constants defined in :mod:`ezdxf.const`:

        ============================== ======= ===========
        MText.dxf.flow_direction       Value   Description
        ============================== ======= ===========
        MTEXT_LEFT_TO_RIGHT            1       left to right
        MTEXT_TOP_TO_BOTTOM            3       top to bottom
        MTEXT_BY_STYLE                 5       by style (the flow direction is inherited from the associated text style)
        ============================== ======= ===========


    .. attribute:: dxf.style

        Text style (string); default is "STANDARD"

    .. attribute:: dxf.text_direction

        X-axis direction vector in :ref:`WCS` (3D Point); default value is (1, 0, 0);
        if :attr:`dxf.rotation` and :attr:`dxf.text_direction` are present,
        :attr:`dxf.text_direction` wins.

    .. attribute:: dxf.rotation

        Text rotation in degrees (float); default is 0

    .. attribute:: dxf.line_spacing_style

        Line spacing style (int), see table below

    .. attribute:: dxf.line_spacing_factor

        Percentage of default (3-on-5) line spacing to be applied. Valid values range
        from 0.25 to 4.00 (float).

        Constants defined in :mod:`ezdxf.lldxf.const`:

        ============================== ======= ===========
        MText.dxf.line_spacing_style   Value   Description
        ============================== ======= ===========
        MTEXT_AT_LEAST                 1       taller characters will override
        MTEXT_EXACT                    2       taller characters will not override
        ============================== ======= ===========

    .. attribute:: dxf.bg_fill

        Defines the background fill type. (DXF R2007)

        ============================== ======= ===========
        MText.dxf.bg_fill              Value   Description
        ============================== ======= ===========
        MTEXT_BG_OFF                   0       no background color
        MTEXT_BG_COLOR                 1       use specified color
        MTEXT_BG_WINDOW_COLOR          2       use window color (?)
        MTEXT_BG_CANVAS_COLOR          3       use canvas background color
        ============================== ======= ===========

    .. attribute:: dxf.box_fill_scale

        Determines how much border there is around the text.  (DXF R2007)

        Requires that the attributes `bg_fill`, `bg_fill_color` are present otherwise
        AutoCAD complains.

        It's recommended to use :meth:`set_bg_color`

    .. attribute:: dxf.bg_fill_color

        Background fill color as :ref:`ACI` (DXF R2007)

        It's recommended to use :meth:`set_bg_color`

    .. attribute:: dxf.bg_fill_true_color

        Background fill color as true color value (DXF R2007), also the
        :attr:`dxf.bg_fill_color` attribute must be present otherwise AutoCAD complains.

        It's recommended to use :meth:`set_bg_color`

    .. attribute:: dxf.bg_fill_color_name

        Background fill color as name string (?) (DXF R2007), also the
        :attr:`dxf.bg_fill_color` attribute must be present otherwise AutoCAD complains.

        It's recommended to use :meth:`set_bg_color`

    .. attribute:: dxf.transparency

        Transparency of background fill color (DXF R2007), not supported by AutoCAD nor
        BricsCAD.

    .. attribute:: text

        MTEXT content as string (read/write).

        The line ending character ``\n`` will be replaced by the MTEXT line ending
        ``\P`` at DXF export, but **not** vice versa the ``\P`` character by ``\n`` at
        DXF file loading, therefore loaded MTEXT entities always use the ``\P``
        character for line endings.

    .. automethod:: set_location

    .. automethod:: get_rotation

    .. automethod:: set_rotation

    .. automethod:: get_text_direction

    .. automethod:: set_bg_color

    .. automethod:: __iadd__

    .. automethod:: append

    .. automethod:: plain_text

    .. automethod:: all_columns_plain_text

    .. automethod:: all_columns_raw_content

    .. automethod:: transform

    .. automethod:: ucs

.. _mtext_inline_codes:

MText Inline Codes
------------------

======= ===========
Code    Description
======= ===========
\\L     Start underline
\\l     Stop underline
\\O	    Start overline
\\o	    Stop overline
\\K	    Start strike-through
\\k	    Stop strike-through
\\P	    New paragraph (new line)
\\p     Paragraphs properties: indentation, alignment, tabulator stops
\\X	    Paragraph wrap on the dimension line (only in dimensions)
\\Q	    Slanting (oblique) text by angle - e.g. \\Q30;
\\H     Text height - e.g. relative \\H3x; absolut \\H3;
\\W	    Text width - e.g. relative \\W0.8x; absolut \\W0.8;
\\T     Tracking, character spacing - e.g. relative \\T0.5x; absolut \\T2;
\\F	    Font selection e.g. \\Fgdt;o - GDT-tolerance
\\S     Stacking, fractions e.g. \\SA^ B; space after "^" is required to avoid
        caret decoding, \\SX/Y; \\S1#4;
\\A     Alignment

        - \\A0; = bottom
        - \\A1; = center
        - \\A2; = top

\\C     Color change

        - \\C1; = red
        - \\C2; = yellow
        - \\C3; = green
        - \\C4; = cyan
        - \\C5; = blue
        - \\C6; = magenta
        - \\C7; = white

\\~     Non breaking space
{}      Braces - define the text area influenced by the code, codes and braces
        can be nested up to 8 levels deep
\\      Escape character - e.g. \\{ = "{"
======= ===========

Convenient constants defined in MTextEditor:
--------------------------------------------

=================== ===========
Constant            Description
=================== ===========
UNDERLINE_START     start underline text
UNDERLINE_STOP      stop underline text
OVERSTRIKE_START    start overline
OVERSTRIKE_STOP     stop overline
STRIKE_START        start strike through
STRIKE_STOP         stop strike through
GROUP_START         start of group
GROUP_END           end of group
NEW_LINE            start in new line
NBSP                none breaking space
=================== ===========


--- End of file: dxfentities/mtext.rst ---



--- Start of file: dxfentities/point.rst ---

Point
=====

.. module:: ezdxf.entities
    :noindex:

The POINT entity (`DXF Reference`_) represents a dimensionless point in :ref:`WCS`.

The POINT styling is a global setting, stored as header variable `$PDMODE`_,
this also means **all** POINT entities in a DXF document have the same styling:

=== ==============
0   center dot (.)
1   none ( )
2   cross (+)
3   x-cross (x)
4   tick (')
=== ==============

Combined with these bit values

=== ==============
32  circle
64  Square
=== ==============

e.g. circle + square + center dot = 32 + 64 + 0 = 96

.. image:: ../gfx/pdmode.png

The size of the points is defined by the header variable `$PDSIZE`_:

=== ==============
0   5% of draw area height
<0  Specifies a percentage of the viewport size
>0  Specifies an absolute size
=== ==============

.. seealso::

    - :ref:`tut_dxf_primitives`, section :ref:`tut_dxf_primitives_point`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'POINT'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_point`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. class:: Point

    .. attribute:: dxf.location

        Location of the point (2D/3D Point in :ref:`WCS`)

    .. attribute:: dxf.angle

        Angle in degrees of the x-axis for the UCS in effect when POINT was drawn (float); used when PDMODE is nonzero.

    .. automethod:: transform

    .. automethod:: translate

    .. automethod:: virtual_entities

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-9C6AD32D-769D-4213-85A4-CA9CCB5C5317
.. _$PDMODE: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2019/ENU/AutoCAD-Core/files/GUID-82F9BB52-D026-4D6A-ABA6-BF29641F459B-htm.html
.. _$PDSIZE: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2021/ENU/AutoCAD-Core/files/GUID-826CA91D-704B-400B-B784-7FCC9619AFB9-htm.html?st=$PDSIZE

--- End of file: dxfentities/point.rst ---



--- Start of file: dxfentities/polyline.rst ---

Polyline
========

.. module:: ezdxf.entities
    :noindex:

The POLYLINE entity (`POLYLINE DXF Reference`_) is very complex, it's used to build
2D/3D polylines, 3D meshes and 3D polyfaces.  For every type exists a different wrapper
class but they all have the same DXF type "POLYLINE". Detect the actual POLYLINE
type by the method :meth:`Polyline.get_mode`.

POLYLINE types returned by :meth:`Polyline.get_mode`:

    - ``'AcDb2dPolyline'`` for 2D :class:`Polyline`
    - ``'AcDb3dPolyline'`` for 3D :class:`Polyline`
    - ``'AcDbPolygonMesh'`` for :class:`Polymesh`
    - ``'AcDbPolyFaceMesh'`` for :class:`Polyface`

For 2D entities all vertices in :ref:`OCS`.

For 3D entities all vertices in :ref:`WCS`.


======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'POLYLINE'``
2D factory function      :meth:`ezdxf.layouts.BaseLayout.add_polyline2d`
3D factory function      :meth:`ezdxf.layouts.BaseLayout.add_polyline3d`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. _POLYLINE DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-ABF6B778-BE20-4B49-9B58-A94E64CEFFF3

.. class:: Polyline

    The :class:`Vertex` entities are stored in the Python list :attr:`Polyline.vertices`.
    The VERTEX entities can be retrieved and deleted by direct access to the
    :attr:`Polyline.vertices` attribute:

    .. code-block:: python

        # delete first and second vertex
        del polyline.vertices[:2]

    .. attribute:: dxf.elevation

        Elevation point, the X and Y values are always 0, and the Z value is the
        polyline elevation (3D Point).

    .. attribute:: dxf.flags

        Constants defined in :mod:`ezdxf.lldxf.const`:

        ================================== ===== ====================================
        :attr:`Polyline.dxf.flags`         Value Description
        ================================== ===== ====================================
        POLYLINE_CLOSED                    1     This is a closed Polyline (or a
                                                 polygon mesh closed in the M
                                                 direction)
        POLYLINE_MESH_CLOSED_M_DIRECTION   1     equals POLYLINE_CLOSED
        POLYLINE_CURVE_FIT_VERTICES_ADDED  2     Curve-fit vertices have been added
        POLYLINE_SPLINE_FIT_VERTICES_ADDED 4     Spline-fit vertices have been added
        POLYLINE_3D_POLYLINE               8     This is a 3D Polyline
        POLYLINE_3D_POLYMESH               16    This is a 3D polygon mesh
        POLYLINE_MESH_CLOSED_N_DIRECTION   32    The polygon mesh is closed in the
                                                 N direction
        POLYLINE_POLYFACE_MESH             64    This Polyline is a polyface mesh
        POLYLINE_GENERATE_LINETYPE_PATTERN 128   The linetype pattern is generated
                                                 continuously around the vertices of
                                                 this Polyline
        ================================== ===== ====================================

    .. attribute:: dxf.default_start_width

        Default line start width (float); default is 0

    .. attribute:: dxf.default_end_width

        Default line end width (float); default is 0

    .. attribute:: dxf.m_count

        Polymesh M vertex count (int); default is 1

    .. attribute:: dxf.n_count

        Polymesh N vertex count (int); default is 1

    .. attribute:: dxf.m_smooth_density

        Smooth surface M density (int); default is 0

    .. attribute:: dxf.n_smooth_density

        Smooth surface N density (int); default is 0

    .. attribute:: dxf.smooth_type

        Curves and smooth surface type (int); default is 0, see table below

        Constants for :attr:`smooth_type` defined in :mod:`ezdxf.lldxf.const`:

        ================================ =====  =============================
        :attr:`Polyline.dxf.smooth_type` Value  Description
        ================================ =====  =============================
        POLYMESH_NO_SMOOTH               0      no smooth surface fitted
        POLYMESH_QUADRATIC_BSPLINE       5      quadratic B-spline surface
        POLYMESH_CUBIC_BSPLINE           6      cubic B-spline surface
        POLYMESH_BEZIER_SURFACE          8      Bezier surface
        ================================ =====  =============================

    .. attribute:: vertices

        List of :class:`Vertex` entities.

    .. autoattribute:: is_2d_polyline

    .. autoattribute:: is_3d_polyline

    .. autoattribute:: is_polygon_mesh

    .. autoattribute:: is_poly_face_mesh

    .. autoattribute:: is_closed

    .. autoattribute:: is_m_closed

    .. autoattribute:: is_n_closed

    .. autoattribute:: has_arc

    .. autoattribute:: has_width

    .. automethod:: get_mode

    .. automethod:: m_close

    .. automethod:: n_close

    .. automethod:: close

    .. automethod:: __len__

    .. automethod:: __getitem__

    .. automethod:: points

    .. automethod:: points_in_wcs

    .. automethod:: append_vertex

    .. automethod:: append_vertices

    .. automethod:: append_formatted_vertices

    .. automethod:: insert_vertices

    .. automethod:: transform

    .. automethod:: virtual_entities

    .. automethod:: explode

Vertex
======

A VERTEX (`VERTEX DXF Reference`_) represents a polyline/mesh vertex.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'VERTEX'``
Factory function         :meth:`Polyline.append_vertex`
Factory function         :meth:`Polyline.extend`
Factory function         :meth:`Polyline.insert_vertices`
Inherited DXF Attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. _VERTEX DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-0741E831-599E-4CBF-91E1-8ADBCFD6556D

.. class:: Vertex

    .. attribute:: dxf.location

        Vertex location (2D/3D Point :ref:`OCS` when 2D, :ref:`WCS` when 3D)

    .. attribute:: dxf.start_width

        Line segment start width (float); default is 0

    .. attribute:: dxf.end_width

        Line segment end width (float); default is 0

    .. attribute:: dxf.bulge

        :ref:`bulge value` (float); default is 0.

        The bulge value is used to create arc shaped line segments.

    .. attribute:: dxf.flags

        Constants defined in :mod:`ezdxf.lldxf.const`:

        ============================== ======= ===========
        Vertex.dxf.flags               Value   Description
        ============================== ======= ===========
        VTX_EXTRA_VERTEX_CREATED       1       Extra vertex created by curve-fitting
        VTX_CURVE_FIT_TANGENT          2       curve-fit tangent defined for this vertex. A curve-fit tangent direction of 0 may be omitted from the DXF output, but is significant if this bit is set.
        VTX_SPLINE_VERTEX_CREATED      8       spline vertex created by spline-fitting
        VTX_SPLINE_FRAME_CONTROL_POINT 16      spline frame control point
        VTX_3D_POLYLINE_VERTEX         32      3D polyline vertex
        VTX_3D_POLYGON_MESH_VERTEX     64      3D polygon mesh
        VTX_3D_POLYFACE_MESH_VERTEX    128     polyface mesh vertex
        ============================== ======= ===========

    .. attribute:: dxf.tangent

        Curve fit tangent direction (float), used for 2D spline in DXF R12.

    .. attribute:: dxf.vtx1

        Index of 1st vertex, if used as face (feature for experts)

    .. attribute:: dxf.vtx2

        Index of 2nd vertex, if used as face (feature for experts)

    .. attribute:: dxf.vtx3

        Index of 3rd vertex, if used as face (feature for experts)

    .. attribute:: dxf.vtx4

        Index of 4th vertex, if used as face (feature for experts)

    .. attribute:: is_2d_polyline_vertex

    .. attribute:: is_3d_polyline_vertex

    .. attribute:: is_polygon_mesh_vertex

    .. attribute:: is_poly_face_mesh_vertex

    .. attribute:: is_face_record

    .. method:: format(format='xyz') -> Sequence

        Return formatted vertex components as tuple.

        Format codes:

            - "x" = x-coordinate
            - "y" = y-coordinate
            - "z" = z-coordinate
            - "s" = start width
            - "e" = end width
            - "b" = bulge value
            - "v" = (x, y, z) as tuple

        Args:
            format: format string, default is "xyz"


Polymesh
========

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Polyline`
DXF type                 ``'POLYLINE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_polymesh`
Inherited DXF Attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. class:: Polymesh

    A polymesh is a grid of :attr:`m_count` by :attr:`n_count` vertices, every vertex has
    its own (x, y, z) location. The :class:`Polymesh` is a subclass of :class:`Polyline`,
    the DXF type is also "POLYLINE", the method :meth:`get_mode` returns "AcDbPolygonMesh".

    .. automethod:: get_mesh_vertex

    .. automethod:: set_mesh_vertex

    .. automethod:: get_mesh_vertex_cache


MeshVertexCache
---------------

.. class:: MeshVertexCache

    Cache mesh vertices in a dict, keys are 0-based (row, col) tuples.

    Set vertex location: :code:`cache[row, col] = (x, y, z)`

    Get vertex location: :code:`x, y, z = cache[row, col]`

    .. attribute:: vertices

        Dict of mesh vertices, keys are 0-based (row, col) tuples.

    .. automethod:: __getitem__

    .. automethod:: __setitem__

Polyface
========

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Polyline`
DXF type                 ``'POLYLINE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_polyface`
Inherited DXF Attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. seealso::

    :ref:`tut_polyface`

.. class:: Polyface

    A polyface consist of multiple 3D areas called faces, only faces with 3 or 4
    vertices are supported.
    The :class:`Polyface` is a subclass of :class:`Polyline`, the DXF type is also
    "POLYLINE", the :meth:`~Polyline.get_mode` returns "AcDbPolyFaceMesh".

    .. automethod:: append_face

    .. automethod:: append_faces

    .. automethod:: faces

    .. automethod:: optimize




--- End of file: dxfentities/polyline.rst ---



--- Start of file: dxfentities/ray.rst ---

Ray
===

.. module:: ezdxf.entities
    :noindex:

The RAY entity (`DXF Reference`_) starts at :attr:`Ray.dxf.point` and continues to
infinity (construction line).

======================== ==========================================
Subclass of              :class:`ezdxf.entities.XLine`
DXF type                 ``'RAY'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_ray`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-638B9F01-5D86-408E-A2DE-FA5D6ADBD415

.. class:: Ray

    .. attribute:: dxf.start

    Start point as (3D Point in :ref:`WCS`)

    .. attribute:: dxf.unit_vector

    Unit direction vector as (3D Point in :ref:`WCS`)

    .. automethod:: transform

    .. automethod:: translate


--- End of file: dxfentities/ray.rst ---



--- Start of file: dxfentities/region.rst ---

Region
======

.. module:: ezdxf.entities
    :noindex:

REGION entity (`DXF Reference`_) created by an ACIS geometry kernel provided by
the `Spatial Corp.`_

.. seealso::

    `Ezdxf` has only very limited support for ACIS based entities, for more
    information see the FAQ: :ref:`faq003`


======================== ==========================================
Subclass of              :class:`ezdxf.entities.Body`
DXF type                 ``'REGION'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_region`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. class:: Region

    Same attributes and methods as parent class :class:`Body`.

.. _Spatial Corp.: http://www.spatial.com/products/3d-acis-modeling

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-644BF0F0-FD79-4C5E-AD5A-0053FCC5A5A4

--- End of file: dxfentities/region.rst ---



--- Start of file: dxfentities/shape.rst ---

Shape
=====

.. module:: ezdxf.entities
    :noindex:

The SHAPE entity (`DXF Reference`_) is used like a block references, each SHAPE
reference can be scaled and rotated individually.
The SHAPE definitions are stored in external shape files (\*.SHX), and
`ezdxf` can not load or create these shape files.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'SHAPE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_shape`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. class:: Shape

    .. attribute:: dxf.insert

        Insertion location as (2D/3D Point in :ref:`WCS`)

    .. attribute:: dxf.name

        Shape name (str)

    .. attribute:: dxf.size

        Shape size (float)

    .. attribute:: dxf.rotation

        Rotation angle in degrees; default value is 0

    .. attribute:: dxf.xscale

        Relative X scale factor (float); default value is 1

    .. attribute:: dxf.oblique

        Oblique angle in degrees (float); default value is 0

    .. automethod:: transform

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-0988D755-9AAB-4D6C-8E26-EC636F507F2C


--- End of file: dxfentities/shape.rst ---



--- Start of file: dxfentities/solid.rst ---

Solid
=====

.. module:: ezdxf.entities
    :noindex:

The SOLID entity (`DXF Reference`_) is a filled triangle or quadrilateral.
Access vertices by name (:code:`entity.dxf.vtx0 = (1.7, 2.3)`) or by index
(:code:`entity[0] = (1.7, 2.3)`). If only 3 vertices are provided the
last (3rd) vertex will be repeated in the DXF file.

The SOLID entity stores the vertices in an unusual way, the last two vertices
are reversed:

.. code-block:: Python

    msp.add_solid([(0, 0), (10, 0), (10, 10), (0, 10)])


.. image:: gfx/solid0.png
    :align: center

Reverse the last two vertices to get the `expected` square:

.. code-block:: Python

    msp.add_solid([(0, 0), (10, 0), (0, 10), (10, 10)])

.. image:: gfx/solid1.png
    :align: center


.. note::

    The quirky vertex order is preserved at the lowest access level because
    `ezdxf` is intended as a DXF file format interface and presents the content
    of the DXF document to the package user as natively as possible.

    The :meth:`Solid.vertices` and :meth:`Solid.wcs_vertices` methods return the
    vertices in the `expected` (reversed) order.


======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'SOLID'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_solid`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided
    factory functions!

.. class:: Solid

    .. attribute:: dxf.vtx0

        Location of 1. vertex (2D/3D Point in :ref:`OCS`)

    .. attribute:: dxf.vtx1

        Location of 2. vertex (2D/3D Point in :ref:`OCS`)

    .. attribute:: dxf.vtx2

        Location of 3. vertex (2D/3D Point in :ref:`OCS`)

    .. attribute:: dxf.vtx3

        Location of 4. vertex (2D/3D Point in :ref:`OCS`)

    .. automethod:: transform

    .. automethod:: vertices

    .. automethod:: wcs_vertices

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-E0C5F04E-D0C5-48F5-AC09-32733E8848F2


--- End of file: dxfentities/solid.rst ---



--- Start of file: dxfentities/spline.rst ---

Spline
======

.. module:: ezdxf.entities
    :noindex:

The SPLINE entity (`DXF Reference`_) is a 3D curve, all coordinates have to be 3D
coordinates even if the spline is just a 2D planar curve.

The spline curve is defined by control points, knot values and weights. The
control points establish the spline, the various types of knot vector determines
the shape of the curve and the weights of rational splines define how
strong a control point influences the shape.

A SPLINE can be created just from fit points - knot values and weights are
optional (tested with AutoCAD 2010). If you add additional data,
be sure you know what you do, because invalid data may invalidate
the whole DXF file.

The function :func:`ezdxf.math.fit_points_to_cad_cv` calculates control
vertices from given fit points. This control vertices define a cubic
B-spline which matches visually the SPLINE entities created by BricsCAD and
AutoCAD from fit points.

.. seealso::

    - `Wikipedia`_ article about B_splines
    - Department of Computer Science and Technology at the `Cambridge`_ University
    - :ref:`tut_spline`


======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'SPLINE'``
Factory function         see table below
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

Factory Functions
-----------------

=========================================== ==========================================
Basic spline entity                         :meth:`~ezdxf.layouts.BaseLayout.add_spline`
Spline control frame from fit points        :meth:`~ezdxf.layouts.BaseLayout.add_spline_control_frame`
Open uniform spline                         :meth:`~ezdxf.layouts.BaseLayout.add_open_spline`
Closed uniform spline                       :meth:`~ezdxf.layouts.BaseLayout.add_closed_spline`
Open rational uniform spline                :meth:`~ezdxf.layouts.BaseLayout.add_rational_spline`
Closed rational uniform spline              :meth:`~ezdxf.layouts.BaseLayout.add_closed_rational_spline`
=========================================== ==========================================

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-E1F884F8-AA90-4864-A215-3182D47A9C74

.. class:: Spline

    All points in :ref:`WCS` as (x, y, z) tuples

    .. attribute:: dxf.degree

        Degree of the spline curve (int).

    .. attribute:: dxf.flags

        Bit coded option flags, constants defined in :mod:`ezdxf.lldxf.const`:

        =================== ======= ===========
        dxf.flags           Value   Description
        =================== ======= ===========
        CLOSED_SPLINE       1       Spline is closed
        PERIODIC_SPLINE     2
        RATIONAL_SPLINE     4
        PLANAR_SPLINE       8
        LINEAR_SPLINE       16      planar bit is also set
        =================== ======= ===========

    .. attribute:: dxf.n_knots

        Count of knot values (int), automatically set by `ezdxf` (read only)

    .. attribute:: dxf.n_fit_points

        Count of fit points (int), automatically set by ezdxf (read only)

    .. attribute:: dxf.n_control_points

        Count of control points (int), automatically set by ezdxf (read only)

    .. attribute:: dxf.knot_tolerance

        Knot tolerance (float); default is 1e-10

    .. attribute:: dxf.fit_tolerance

        Fit tolerance (float); default is 1e-10

    .. attribute:: dxf.control_point_tolerance

        Control point tolerance (float); default is 1e-10

    .. attribute:: dxf.start_tangent

        Start tangent vector as 3D vector in :ref:`WCS`

    .. attribute:: dxf.end_tangent

        End tangent vector as 3D vector in :ref:`WCS`

    .. autoattribute:: closed

    .. autoattribute:: control_points

    .. autoattribute:: fit_points

    .. autoattribute:: knots

    .. autoattribute:: weights

    .. automethod:: control_point_count

    .. automethod:: fit_point_count

    .. automethod:: knot_count

    .. automethod:: construction_tool

    .. automethod:: apply_construction_tool

    .. automethod:: flattening

    .. automethod:: set_open_uniform

    .. automethod:: set_uniform

    .. automethod:: set_closed

    .. automethod:: set_open_rational

    .. automethod:: set_uniform_rational

    .. automethod:: set_closed_rational

    .. automethod:: transform

    .. automethod:: from_arc

.. _Cambridge: https://www.cl.cam.ac.uk/teaching/2000/AGraphHCI/SMEG/node4.html

.. _Wikipedia: https://en.wikipedia.org/wiki/Spline_%28mathematics%29


--- End of file: dxfentities/spline.rst ---



--- Start of file: dxfentities/surface.rst ---

Surface
=======

.. module:: ezdxf.entities
    :noindex:

SURFACE entity (`DXF Reference`_) created by an ACIS geometry kernel provided by
the `Spatial Corp.`_

.. seealso::

    `Ezdxf` has only very limited support for ACIS based entities, for more
    information see the FAQ: :ref:`faq003`


======================== ==========================================
Subclass of              :class:`ezdxf.entities.Body`
DXF type                 ``'SURFACE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_surface`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. class:: Surface

    Same attributes and methods as parent class :class:`Body`.

    .. attribute:: dxf.u_count

        Number of U isolines.

    .. attribute:: dxf.v_count

        Number of V2 isolines.

.. _Spatial Corp.: http://www.spatial.com/products/3d-acis-modeling

ExtrudedSurface
---------------

(`DXF Reference`_)

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Surface`
DXF type                 ``'EXTRUDEDSURFACE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_extruded_surface`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2007 (``'AC1021'``)
======================== ==========================================

.. class:: ExtrudedSurface

    Same attributes and methods as parent class :class:`Surface`.

    .. attribute:: dxf.class_id

    .. attribute:: dxf.sweep_vector

    .. attribute:: dxf.draft_angle

    .. attribute:: dxf.draft_start_distance

    .. attribute:: dxf.draft_end_distance

    .. attribute:: dxf.twist_angle

    .. attribute:: dxf.scale_factor

    .. attribute:: dxf.align_angle

    .. attribute:: dxf.solid

    .. attribute:: dxf.sweep_alignment_flags

        === ===============================
        0   No alignment
        1   Align sweep entity to path
        2   Translate sweep entity to path
        3   Translate path to sweep entity
        === ===============================

    .. attribute:: dxf.align_start

    .. attribute:: dxf.bank

    .. attribute:: dxf.base_point_set

    .. attribute:: dxf.sweep_entity_transform_computed

    .. attribute:: dxf.path_entity_transform_computed

    .. attribute:: dxf.reference_vector_for_controlling_twist

    .. attribute:: transformation_matrix_extruded_entity

        type: :class:`~ezdxf.math.Matrix44`

    .. attribute:: sweep_entity_transformation_matrix

        type: :class:`~ezdxf.math.Matrix44`

    .. attribute:: path_entity_transformation_matrix

        type: :class:`~ezdxf.math.Matrix44`

LoftedSurface
-------------

(`DXF Reference`_)

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Surface`
DXF type                 ``'LOFTEDSURFACE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_lofted_surface`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2007 (``'AC1021'``)
======================== ==========================================

.. class:: LoftedSurface

    Same attributes and methods as parent class :class:`Surface`.

    .. attribute:: dxf.plane_normal_lofting_type

    .. attribute:: dxf.start_draft_angle

    .. attribute:: dxf.end_draft_angle

    .. attribute:: dxf.start_draft_magnitude

    .. attribute:: dxf.end_draft_magnitude

    .. attribute:: dxf.arc_length_parameterization

    .. attribute:: dxf.no_twist

    .. attribute:: dxf.align_direction

    .. attribute:: dxf.simple_surfaces

    .. attribute:: dxf.closed_surfaces

    .. attribute:: dxf.solid

    .. attribute:: dxf.ruled_surface

    .. attribute:: dxf.virtual_guide

    .. attribute:: set_transformation_matrix_lofted_entity

        type: :class:`~ezdxf.math.Matrix44`

RevolvedSurface
---------------

(`DXF Reference`_)

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Surface`
DXF type                 ``'REVOLVEDSURFACE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_revolved_surface`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2007 (``'AC1021'``)
======================== ==========================================

.. class:: RevolvedSurface

    Same attributes and methods as parent class :class:`Surface`.

    .. attribute:: dxf.class_id

    .. attribute:: dxf.axis_point

    .. attribute:: dxf.axis_vector

    .. attribute:: dxf.revolve_angle

    .. attribute:: RevolvedSurface.dxf.start_angle

    .. attribute:: dxf.draft_angle

    .. attribute:: dxf.start_draft_distance

    .. attribute:: dxf.end_draft_distance

    .. attribute:: dxf.twist_angle

    .. attribute:: dxf.solid

    .. attribute:: dxf.close_to_axis

    .. attribute:: transformation_matrix_revolved_entity

        type: :class:`~ezdxf.math.Matrix44`

SweptSurface
------------

(`DXF Reference`_)

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Surface`
DXF type                 ``'SWEPTSURFACE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_swept_surface`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2007 (``'AC1021'``)
======================== ==========================================

.. class:: SweptSurface

    Same attributes and methods as parent class :class:`Surface`.

    .. attribute:: dxf.swept_entity_id

    .. attribute:: dxf.path_entity_id

    .. attribute:: dxf.draft_angle

    .. attribute:: draft_start_distance

    .. attribute:: dxf.draft_end_distance

    .. attribute:: dxf.twist_angle

    .. attribute:: dxf.scale_factor

    .. attribute:: dxf.align_angle

    .. attribute:: dxf.solid

    .. attribute:: dxf.sweep_alignment

    .. attribute:: dxf.align_start

    .. attribute:: dxf.bank

    .. attribute:: dxf.base_point_set

    .. attribute:: dxf.sweep_entity_transform_computed

    .. attribute:: dxf.path_entity_transform_computed

    .. attribute:: dxf.reference_vector_for_controlling_twist

    .. attribute:: transformation_matrix_sweep_entity

        type: :class:`~ezdxf.math.Matrix44`

    .. method:: transformation_matrix_path_entity

        type: :class:`~ezdxf.math.Matrix44`

    .. method:: sweep_entity_transformation_matrix

        type: :class:`~ezdxf.math.Matrix44`

    .. method:: path_entity_transformation_matrix

        type: :class:`~ezdxf.math.Matrix44`

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-BB62483A-89C3-47C4-80E5-EA3F08979863

--- End of file: dxfentities/surface.rst ---



--- Start of file: dxfentities/text.rst ---

Text
====

.. module:: ezdxf.entities
    :noindex:

The TEXT entity (`DXF Reference`_) represents a single line of text.
The :attr:`~Text.dxf.style` attribute stores the associated :class:`Textstyle` entity as
string, which defines the basic font properties. The text size is stored as cap-height
in the :attr:`~Text.dxf.height` attribute in drawing units. Text alignments
are defined as enums of type :class:`ezdxf.enums.TextEntityAlignment`.

.. seealso::

    See the documentation for the :class:`Textstyle` class to understand the
    limitations of text representation in the DXF format.

    :ref:`tut_text`

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'TEXT'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_text`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided
    factory functions!


.. class:: Text

    .. attribute:: dxf.text

        Text content as string.

    .. attribute:: dxf.insert

        First alignment point of text (2D/3D Point in :ref:`OCS`), relevant for
        the adjustments LEFT, ALIGNED  and FIT.

    .. attribute:: dxf.align_point

        The main alignment point of text (2D/3D Point in :ref:`OCS`), if the
        alignment is anything else than LEFT, or the second alignment point
        for the ALIGNED and FIT alignments.

    .. attribute:: dxf.height

        Text height in drawing units as float value, the default value is 1.

    .. attribute:: dxf.rotation

        Text rotation in degrees as float value, the default value is 0.

    .. attribute:: dxf.oblique

        Text oblique angle (slanting)  in degrees as float value, the default
        value is 0 (straight vertical text).

    .. attribute:: dxf.style

        :class:`Textstyle` name as case insensitive string, the default value
        is "Standard"

    .. attribute:: dxf.width

        Width scale factor as float value, the default value is 1.

    .. attribute:: dxf.halign

        Horizontal alignment flag as int value, use the :meth:`~Text.set_placement`
        and :meth:`~Text.get_align_enum` methods to handle text alignment, the
        default value is 0.

        === =========
        0   Left
        2   Right
        3   Aligned (if vertical alignment = 0)
        4   Middle (if vertical alignment = 0)
        5   Fit (if vertical alignment = 0)
        === =========

    .. attribute:: dxf.valign

        Vertical alignment flag as int value, use the :meth:`~Text.set_placement`
        and :meth:`~Text.get_align_enum` methods to handle text alignment, the
        default value is 0.

        === =========
        0   Baseline
        1   Bottom
        2   Middle
        3   Top
        === =========

    .. attribute:: dxf.text_generation_flag

        Text generation flags as int value, use the :attr:`is_backward` and
        :attr:`is_upside_down` attributes to handle this flags.

        === =========
        2   text is backward (mirrored in X)
        4   text is upside down (mirrored in Y)
        === =========

    .. autoproperty:: is_backward

    .. autoproperty:: is_upside_down

    .. automethod:: set_placement

    .. automethod:: get_placement

    .. automethod:: get_align_enum

    .. automethod:: set_align_enum

    .. automethod:: transform

    .. automethod:: translate

    .. automethod:: plain_text

    .. automethod:: font_name

    .. automethod:: fit_length

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-62E5383D-8A14-47B4-BFC4-35824CAE8363

--- End of file: dxfentities/text.rst ---



--- Start of file: dxfentities/trace.rst ---

Trace
=====

.. module:: ezdxf.entities
    :noindex:

The TRACE entity (`DXF Reference`_) is solid filled triangle or quadrilateral.
Access vertices by name (:code:`entity.dxf.vtx0 = (1.7, 2.3)`) or by
index (:code:`entity[0] = (1.7, 2.3)`). If only 3 vertices are provided the
last (3rd) vertex will be repeated in the DXF file.


The TRACE entity stores the vertices in an unusual way, the last two vertices
are reversed:

.. code-block:: Python

    msp.add_solid([(0, 0), (10, 0), (10, 10), (0, 10)])


.. image:: gfx/solid0.png
    :align: center

Reverse the last two vertices to get the `expected` square:

.. code-block:: Python

    msp.add_solid([(0, 0), (10, 0), (0, 10), (10, 10)])

.. image:: gfx/solid1.png
    :align: center


.. note::

    The quirky vertex order is preserved at the lowest access level because
    `ezdxf` is intended as a DXF file format interface and presents the content
    of the DXF document to the package user as natively as possible.

    The :meth:`Trace.vertices` and :meth:`Trace.wcs_vertices` methods return the
    vertices in the `expected` (reversed) order.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'TRACE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_trace`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided
    factory functions!


.. class:: Trace

    .. attribute:: dxf.vtx0

        Location of 1. vertex (2D/3D Point in :ref:`OCS`)

    .. attribute:: dxf.vtx1

        Location of 2. vertex (2D/3D Point in :ref:`OCS`)

    .. attribute:: dxf.vtx2

        Location of 3. vertex (2D/3D Point in :ref:`OCS`)

    .. attribute:: dxf.vtx3

        Location of 4. vertex (2D/3D Point in :ref:`OCS`)

    .. automethod:: transform

    .. automethod:: vertices

    .. automethod:: wcs_vertices

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-EA6FBCA8-1AD6-4FB2-B149-770313E93511

--- End of file: dxfentities/trace.rst ---



--- Start of file: dxfentities/underlay.rst ---

Underlay
========

.. module:: ezdxf.entities
    :noindex:

The UNDERLAY entity (`DXF Reference`_) links an underlay file to the DXF file, the file
itself is not embedded into the DXF file, it is always a separated file.
The (PDF)UNDERLAY entity is like a block reference, you can use it multiple times to add
the underlay on different locations with different scales and rotations. But therefore
you need a also a (PDF)DEFINITION entity, see :class:`UnderlayDefinition`.

The DXF standard supports three different file formats: PDF, DWF (DWFx) and DGN.
An Underlay can be clipped by a rectangle or a polygon path. The clipping coordinates
are 2D :ref:`OCS` coordinates in drawing units but without scaling.

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-3EC8FBCC-A85A-4B0B-93CD-C6C785959077

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 internal base class
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_underlay`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. class:: Underlay

    Base class of :class:`PdfUnderlay`, :class:`DwfUnderlay` and :class:`DgnUnderlay`

    .. attribute:: dxf.insert

        Insertion point, lower left corner of the image in :ref:`OCS`.

    .. attribute:: dxf.scale_x

        Scaling factor in x-direction (float)

    .. attribute:: dxf.scale_y

        Scaling factor in y-direction (float)

    .. attribute:: dxf.scale_z

        Scaling factor in z-direction (float)

    .. attribute:: dxf.rotation

        ccw rotation in degrees around the extrusion vector (float)

    .. attribute:: dxf.extrusion

        extrusion vector, default is (0, 0, 1)

    .. attribute:: dxf.underlay_def_handle

        Handle to the underlay definition entity, see :class:`UnderlayDefinition`

    .. attribute:: dxf.flags

        ============================== ======= ===========
        :attr:`dxf.flags`              Value   Description
        ============================== ======= ===========
        UNDERLAY_CLIPPING              1       clipping is on/off
        UNDERLAY_ON                    2       underlay is on/off
        UNDERLAY_MONOCHROME            4       Monochrome
        UNDERLAY_ADJUST_FOR_BACKGROUND 8       Adjust for background
        ============================== ======= ===========

    .. attribute:: dxf.contrast

        Contrast value (20 - 100; default is 100)

    .. attribute:: dxf.fade

        Fade value (0 - 80; default is 0)


    .. attribute:: clipping

        ``True`` or ``False`` (read/write)

    .. attribute:: on

        ``True`` or ``False`` (read/write)

    .. attribute:: monochrome

        ``True`` or ``False`` (read/write)

    .. attribute:: adjust_for_background

        ``True`` or ``False`` (read/write)

    .. attribute:: scale

        Scaling (x, y, z) tuple (read/write)

    .. attribute:: boundary_path

        Boundary path as list of vertices (read/write).

        Two vertices describe a rectangle (lower left and upper right corner), more than
        two vertices is a polygon as clipping path.

    .. method:: get_underlay_def

        Returns the associated DEFINITION entity. see :class:`UnderlayDefinition`.

    .. method:: set_underlay_def

        Set the associated DEFINITION entity. see :class:`UnderlayDefinition`.

    .. automethod:: reset_boundary_path

PdfUnderlay
-----------

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Underlay`
DXF type                 ``'PDFUNDERLAY'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_underlay`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. class:: PdfUnderlay

    PDF underlay.

DwfUnderlay
-----------

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Underlay`
DXF type                 ``'DWFUNDERLAY'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_underlay`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. class:: DwfUnderlay

    DWF underlay.

DgnUnderlay
-----------

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Underlay`
DXF type                 ``'DGNUNDERLAY'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_underlay`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. class:: DgnUnderlay

    DGN underlay.


--- End of file: dxfentities/underlay.rst ---



--- Start of file: dxfentities/viewport.rst ---

Viewport
========

.. module:: ezdxf.entities
    :noindex:

The VIEWPORT entity (`DXF Reference`_) is a window from a paperspace layout to the
modelspace.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'VIEWPORT'``
Factory function         :meth:`ezdxf.layouts.Paperspace.add_viewport`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. class:: Viewport

    .. attribute:: dxf.center

        Center point of the viewport located in the paper space layout in paper
        space units stored as 3D point. (Error in the DXF reference)

    .. attribute:: dxf.width

        Viewport width in paperspace units (float)

    .. attribute:: dxf.height

        Viewport height in paperspace units (float)

    .. attribute:: dxf.status

        Viewport status field (int)

        === =====================================
        -1  On, but is fully off screen, or is one of the viewports that is not active because the $MAXACTVP count is
            currently being exceeded.
        0   Off
        >0  On and active. The value indicates the order of stacking for the viewports,
            where 1 is the active viewport, 2 is the next, and so forth.
        === =====================================

    .. attribute:: dxf.id

        Viewport id (int)

    .. attribute:: dxf.view_center_point

        View center point in modelspace stored as 2D point, but represents a
        :ref:`WCS` point. (Error in the DXF reference)

    .. attribute:: dxf.snap_base_point

    .. attribute:: dxf.snap_spacing

    .. attribute:: dxf.snap_angle

    .. attribute:: dxf.grid_spacing

    .. attribute:: dxf.view_direction_vector

        View direction (3D vector in :ref:`WCS`).

    .. attribute:: dxf.view_target_point

        View target point (3D point in :ref:`WCS`).

    .. attribute:: dxf.perspective_lens_length

        Lens focal length in mm as 35mm film equivalent.

    .. attribute:: dxf.front_clip_plane_z_value

    .. attribute:: dxf.back_clip_plane_z_value

    .. attribute:: dxf.view_height

        View height in :ref:`WCS`.

    .. attribute:: dxf.view_twist_angle

    .. attribute:: dxf.circle_zoom

    .. attribute:: dxf.flags

        Viewport status bit-coded flags:

        =================== =============================== ==========================================
        Bit value           Constant in :mod:`ezdxf.const`  Description
        =================== =============================== ==========================================
        1 (0x1)             VSF_PERSPECTIVE_MODE            Enables perspective mode
        2 (0x2)             VSF_FRONT_CLIPPING              Enables front clipping
        4 (0x4)             VSF_BACK_CLIPPING               Enables back clipping
        8 (0x8)             VSF_USC_FOLLOW                  Enables UCS follow
        16 (0x10)           VSF_FRONT_CLIPPING_NOT_AT_EYE   Enables front clip not at eye
        32 (0x20)           VSF_UCS_ICON_VISIBILITY         Enables UCS icon visibility
        64 (0x40)           VSF_UCS_ICON_AT_ORIGIN          Enables UCS icon at origin
        128 (0x80)          VSF_FAST_ZOOM                   Enables fast zoom
        256 (0x100)         VSF_SNAP_MODE                   Enables snap mode
        512 (0x200)         VSF_GRID_MODE                   Enables grid mode
        1024 (0x400)        VSF_ISOMETRIC_SNAP_STYLE        Enables isometric snap style
        2048 (0x800)        VSF_HIDE_PLOT_MODE              Enables hide plot mode
        4096 (0x1000)       VSF_KISOPAIR_TOP                kIsoPairTop. If set and kIsoPairRight is not set, then isopair top is enabled. If both kIsoPairTop
                                                            and kIsoPairRight are set, then isopair left is enabled
        8192 (0x2000)       VSF_KISOPAIR_RIGHT              kIsoPairRight. If set and kIsoPairTop is not set, then isopair right is enabled
        16384 (0x4000)      VSF_LOCK_ZOOM                   Enables viewport zoom locking
        32768 (0x8000)      VSF_CURRENTLY_ALWAYS_ENABLED    Currently always enabled
        65536 (0x10000)     VSF_NON_RECTANGULAR_CLIPPING    Enables non-rectangular clipping
        131072 (0x20000)    VSF_TURN_VIEWPORT_OFF           Turns the viewport off
        262144 (0x40000)    VSF_NO_GRID_LIMITS              Enables the display of the grid beyond the drawing limits
        524288 (0x80000)    VSF_ADAPTIVE_GRID_DISPLAY       Enable adaptive grid display
        1048576 (0x100000)  VSF_SUBDIVIDE_GRID              Enables subdivision of the grid below the set grid spacing when the grid display is adaptive
        2097152 (0x200000)  VSF_GRID_FOLLOW_WORKPLANE       Enables grid follows workplane switching
        =================== =============================== ==========================================

        Use helper method :meth:`~DXFEntity.set_flag_state` to set and clear
        viewport flags, e.g. lock viewport::

            vp.set_flag_state(ezdxf.const.VSF_LOCK_ZOOM, True)

    .. attribute:: dxf.clipping_boundary_handle

    .. attribute:: dxf.plot_style_name

    .. attribute:: dxf.render_mode

        === ============================
        0   2D Optimized (classic 2D)
        1   Wireframe
        2   Hidden line
        3   Flat shaded
        4   Gouraud shaded
        5   Flat shaded with wireframe
        6   Gouraud shaded with wireframe
        === ============================

    .. attribute:: dxf.ucs_per_viewport

    .. attribute:: dxf.ucs_icon

    .. attribute:: dxf.ucs_origin

        UCS origin as 3D point.

    .. attribute:: dxf.ucs_x_axis

        UCS x-axis as 3D vector.

    .. attribute:: dxf.ucs_y_axis

        UCS y-axis as 3D vector.

    .. attribute:: dxf.ucs_handle

        Handle of :class:`UCSTable` if UCS is a named UCS. If not present, then UCS is unnamed.

    .. attribute:: dxf.ucs_ortho_type

        === ====================
        0   not orthographic
        1   Top
        2   Bottom
        3   Front
        4   Back
        5   Left
        6   Right
        === ====================

    .. attribute:: dxf.ucs_base_handle

        Handle of :class:`UCSTable` of base UCS if UCS is orthographic (:attr:`Viewport.dxf.ucs_ortho_type` is non-zero).
        If not present and :attr:`Viewport.dxf.ucs_ortho_type` is non-zero, then base UCS is taken to be WORLD.

    .. attribute:: dxf.elevation

    .. attribute:: dxf.shade_plot_mode

        (DXF R2004)

        === ============
        0   As Displayed
        1   Wireframe
        2   Hidden
        3   Rendered
        === ============

    .. attribute:: dxf.grid_frequency

        Frequency of major grid lines compared to minor grid lines. (DXF R2007)

    .. attribute:: dxf.background_handle

    .. attribute:: dxf.shade_plot_handle

    .. attribute:: dxf.visual_style_handle

    .. attribute:: dxf.default_lighting_flag

    .. attribute:: dxf.default_lighting_style

        === ==================
        0   One distant light
        1   Two distant lights
        === ==================

    .. attribute:: dxf.view_brightness

    .. attribute:: dxf.view_contrast

    .. attribute:: dxf.ambient_light_color_1

        as :ref:`ACI`

    .. attribute:: dxf.ambient_light_color_2

        as true color value

    .. attribute:: dxf.ambient_light_color_3

        as true color value

    .. attribute:: dxf.sun_handle

    .. attribute:: dxf.ref_vp_object_1

    .. attribute:: dxf.ref_vp_object_2

    .. attribute:: dxf.ref_vp_object_3

    .. attribute:: dxf.ref_vp_object_4

    .. autoattribute:: frozen_layers

    .. automethod:: is_frozen

    .. automethod:: freeze

    .. automethod:: thaw

    .. autoattribute:: has_extended_clipping_path

    .. automethod:: clipping_rect

    .. automethod:: clipping_rect_corners

    .. automethod:: get_aspect_ratio

    .. automethod:: get_modelspace_limits

    .. automethod:: get_scale

    .. automethod:: get_transformation_matrix


.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-2602B0FB-02E4-4B9A-B03C-B1D904753D34

--- End of file: dxfentities/viewport.rst ---



--- Start of file: dxfentities/wipeout.rst ---

Wipeout
=======

.. module:: ezdxf.entities
    :noindex:

The WIPEOUT entity (`DXF Reference`_) is a polygonal area that masks underlying
objects with the current background color. The WIPEOUT entity is based on the
IMAGE entity, but usage does not require any knowledge about the IMAGE entity.

The handles to the support entities :class:`ImageDef` and :class:`ImageDefReactor`
are always "0", both are not needed by the WIPEOUT entity.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.Image`
DXF type                 ``'WIPEOUT'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_wipeout`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. warning::

    Do not instantiate entity classes by yourself - always use the provided factory functions!

.. class:: Wipeout

    .. automethod:: set_masking_area

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-2229F9C4-3C80-4C67-9EDA-45ED684808DC

--- End of file: dxfentities/wipeout.rst ---



--- Start of file: dxfentities/xline.rst ---

XLine
=====

.. module:: ezdxf.entities
    :noindex:

The XLINE entity (`DXF Reference`_) is a construction line that extents to infinity in
both directions.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFGraphic`
DXF type                 ``'XLINE'``
Factory function         :meth:`ezdxf.layouts.BaseLayout.add_xline`
Inherited DXF attributes :ref:`Common graphical DXF attributes`
Required DXF version     DXF R2000 (``'AC1015'``)
======================== ==========================================

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-55080553-34B6-40AA-9EE2-3F3A3A2A5C0A

.. class:: XLine

    .. attribute:: dxf.start

    Location point of line as (3D Point in :ref:`WCS`)

    .. attribute:: dxf.unit_vector

    Unit direction vector as (3D Point in :ref:`WCS`)

    .. automethod:: transform

    .. automethod:: translate

--- End of file: dxfentities/xline.rst ---



--- Start of file: dxfinternals/block_management.rst ---

.. _Block Management Structures:

Block Management Structures
===========================

A BLOCK is a layout like the modelspace or a paperspace layout, with the
similarity that all these layouts are containers for graphical DXF entities.
This block definition can be referenced in other layouts by the INSERT entity.
By using block references, the same set of graphical entities can be located
multiple times at different layouts, this block references can be stretched and
rotated without modifying the original entities. A block is referenced only by
its name defined by the DXF tag :code:`(2, name)`, there is a second DXF tag
:code:`(3, name2)` for the block name, which is not further documented by
Autodesk, just ignore it.

The :code:`(10, base_point)` tag (in BLOCK defines a insertion point of the
block, by 'inserting' a block by the INSERT entity, this point of the block is
placed at the location defined by the :code:`(10, insert)` tag in
the INSERT entity, and it is also the base point for stretching and rotation.

A block definition can contain INSERT entities, and it is possible to create
cyclic block definitions (a BLOCK contains a INSERT of itself), but this should
be avoided, CAD applications will not load the DXF file at all or maybe just
crash. This is also the case for all other kinds of cyclic definitions like:
BLOCK "A" -> INSERT BLOCK "B" and BLOCK "B" -> INSERT BLOCK "A".


.. seealso::

    - ezdxf DXF Internals: :ref:`blocks_section_internals`
    - DXF Reference: `BLOCKS Section`_
    - DXF Reference: `BLOCK Entity`_
    - DXF Reference: `ENDBLK Entity`_
    - DXF Reference: `INSERT Entity`_

Block Names
-----------

Block names has to be unique and they are case insensitive ("Test" == "TEST").
If there are two or more block definitions with the same name, AutoCAD
merges these blocks into a single block with unpredictable properties
of all these blocks. In my test with two blocks, the final block has the name
of the first block and the base-point of the second block, and contains all
entities of both blocks.

Block Definitions in DXF R12
----------------------------

In DXF R12 the definition of a block is located in the BLOCKS section, no
additional structures are needed.
The definition starts with a BLOCK entity and ends with a ENDBLK entity.
All entities between this two entities are the content of the block, the block
is the owner of this entities like any layout.

As shown in the DXF file below (created by AutoCAD LT 2018), the BLOCK entity
has no handle, but ezdxf writes also handles for the BLOCK entity and AutoCAD
doesn't complain.

DXF R12 BLOCKS structure:

.. code-block:: none

    0           <<< start of a SECTION
    SECTION
    2           <<< start of BLOCKS section
    BLOCKS
    ...         <<< modelspace and paperspace block definitions not shown,
    ...         <<< see layout management
    ...
    0           <<< start of a BLOCK definition
    BLOCK
    8           <<< layer
    0
    2           <<< block name
    ArchTick
    70          <<< flags
    1
    10          <<< base point, x
    0.0
    20          <<< base point, y
    0.0
    30          <<< base point, z
    0.0
    3           <<< second BLOCK name, same as (2, name)
    ArchTick
    1           <<< xref name, if block is an external reference
                <<< empty string!
    0           <<< start of the first entity of the BLOCK
    LINE
    5
    28E
    8
    0
    62
    0
    10
    500.0
    20
    500.0
    30
    0.0
    11
    500.0
    21
    511.0
    31
    0.0
    0           <<< start of the second entity of the BLOCK
    LINE
    ...
    0.0
    0           <<< ENDBLK entity, marks the end of the BLOCK definition
    ENDBLK
    5           <<< ENDBLK gets a handle by AutoCAD, but BLOCK didn't
    2F2
    8           <<< as every entity, also ENDBLK requires a layer (same as BLOCK entity!)
    0
    0           <<< start of next BLOCK entity
    BLOCK
    ...
    0           <<< end BLOCK entity
    ENDBLK
    0           <<< end of BLOCKS section
    ENDSEC

Block Definitions in DXF R2000+
-------------------------------

The overall organization in the BLOCKS sections remains the same, but additional
tags in the BLOCK entity, have to be maintained.

Especially the concept of ownership is important. Since DXF R13 every graphic
entity is associated to a specific layout and a BLOCK definition is also a
layout. So all entities in the BLOCK definition, including the BLOCK and the
ENDBLK entities, have an owner tag :code:`(330, ...)`, which points to a
BLOCK_RECORD entry in the BLOCK_RECORD table. This BLOCK_RECORD is the main
management structure for all layouts and is the real owner of the layout
entities.

As you can see in the chapter about :ref:`Layout Management Structures`, this
concept is also valid for modelspace and paperspace layouts, because these
layouts are also BLOCKS, with the special difference, that the entities of the
modelspace and the `active` paperspace layout are stored in the ENTITIES section.

.. image:: gfx/block_definition.png
    :align: center

.. seealso::

    - :ref:`Tag Structure DXF R13 and later`
    - ezdxf DXF Internals: :ref:`tables_section_internals`
    - DXF Reference: `TABLES Section`_
    - DXF Reference: `BLOCK_RECORD Entity`_


DXF R13 BLOCKS structure:

.. code-block:: none

    0           <<< start of a SECTION
    SECTION
    2           <<< start of BLOCKS section
    BLOCKS
    ...         <<< modelspace and paperspace block definitions not shown,
    ...         <<< see layout management
    0           <<< start of BLOCK definition
    BLOCK
    5           <<< even BLOCK gets a handle now ;)
    23A
    330         <<< owner tag, the owner of a BLOCK is a BLOCK_RECORD in the
    ...         BLOCK_RECORD table
    238
    100         <<< subclass marker
    AcDbEntity
    8           <<< layer of the BLOCK definition
    0
    100         <<< subclass marker
    AcDbBlockBegin
    2           <<< BLOCK name
    ArchTick
    70          <<< flags
    0
    10          <<< base point, x
    0.0
    20          <<< base point, y
    0.0
    30          <<< base point, z
    0.0
    3           <<< second BLOCK name, same as (2, name)
    ArchTick
    1           <<< xref name, if block is an external reference
                <<< empty string!
    0           <<< start of the first entity of the BLOCK
    LWPOLYLINE
    5
    239
    330         <<< owner tag of LWPOLYLINE
    238         <<< handle of the BLOCK_RECORD!
    100
    AcDbEntity
    8
    0
    6
    ByBlock
    62
    0
    100
    AcDbPolyline
    90
    2
    70
    0
    43
    0.15
    10
    -0.5
    20
    -0.5
    10
    0.5
    20
    0.5
    0           <<< ENDBLK entity, marks the end of the BLOCK definition
    ENDBLK
    5           <<< handle
    23B
    330         <<< owner tag, same BLOCK_RECORD as for the BLOCK entity
    238
    100         <<< subclass marker
    AcDbEntity
    8           <<< ENDBLK requires the same layer as the BLOCK entity!
    0
    100         <<< subclass marker
    AcDbBlockEnd
    0           <<< start of the next BLOCK
    BLOCK
    ...
    0
    ENDBLK
    ...
    0           <<< end of the BLOCKS section
    ENDSEC


DXF R13 BLOCK_RECORD structure:

.. code-block:: none

    0           <<< start of a SECTION
    SECTION
    2           <<< start of TABLES section
    TABLES
    0           <<< start of a TABLE
    TABLE
    2           <<< start of the BLOCK_RECORD table
    BLOCK_RECORD
    5           <<< handle of the table
    1
    330         <<< owner tag of the table
    0           <<< is always #0
    100         <<< subclass marker
    AcDbSymbolTable
    70          <<< count of table entries, not reliable
    4
    0           <<< start of first BLOCK_RECORD entry
    BLOCK_RECORD
    5           <<< handle of BLOCK_RECORD, in ezdxf often referred to as "layout key"
    1F
    330         <<< owner of the BLOCK_RECORD is the BLOCK_RECORD table
    1
    100         <<< subclass marker
    AcDbSymbolTableRecord
    100         <<< subclass marker
    AcDbBlockTableRecord
    2           <<< name of the BLOCK or LAYOUT
    *Model_Space
    340         <<< pointer to the associated LAYOUT object
    4AF
    70          <<< AC1021 (R2007) block insertion units
    0
    280         <<< AC1021 (R2007) block explodability
    1
    281         <<< AC1021 (R2007) block scalability
    0

    ...         <<< paperspace not shown
    ...
    0           <<< next BLOCK_RECORD
    BLOCK_RECORD
    5           <<< handle of BLOCK_RECORD, in ezdxf often referred to as "layout key"
    238
    330         <<< owner of the BLOCK_RECORD is the BLOCK_RECORD table
    1
    100         <<< subclass marker
    AcDbSymbolTableRecord
    100         <<< subclass marker
    AcDbBlockTableRecord
    2           <<< name of the BLOCK
    ArchTick
    340         <<< pointer to the associated LAYOUT object
    0           <<< #0, because BLOCK doesn't have an associated LAYOUT object
    70          <<< AC1021 (R2007) block insertion units
    0
    280         <<< AC1021 (R2007) block explodability
    1
    281         <<< AC1021 (R2007) block scalability
    0
    0           <<< end of BLOCK_RECORD table
    ENDTAB
    0           <<< next TABLE
    TABLE
    ...
    0
    ENDTAB
    0           <<< end of TABLES section
    ENDESC

.. _BLOCKS Section: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-1D14A213-5E4D-4EA6-A6B5-8709EB925D01

.. _BLOCK Entity: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-66D32572-005A-4E23-8B8B-8726E8C14302

.. _ENDBLK Entity: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-27F7CC8A-E340-4C7F-A77F-5AF139AD502D

.. _INSERT Entity: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-28FA4CFB-9D5E-4880-9F11-36C97578252F

.. _TABLES Section: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A9FD9590-C97B-4E41-9F26-BD82C34A4F9F

.. _BLOCK_RECORD Entity: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A1FD1934-7EF5-4D35-A4B0-F8AE54A9A20A

--- End of file: dxfinternals/block_management.rst ---



--- Start of file: dxfinternals/datamodel.rst ---

.. _Data Model:

Data Model
==========

.. _Database Objects:

Database Objects
----------------

(from the DXF Reference)

AutoCAD drawings consist largely of structured containers for database objects. Database
objects each have the following features:

    - A handle whose value is unique to the drawing/DXF file, and is constant for the
      lifetime of the drawing. This format has existed since AutoCAD Release 10, and as
      of AutoCAD Release 13, handles are always enabled.
    - An optional XDATA table, as entities have had since AutoCAD Release 11.
    - An optional persistent reactor table.
    - An optional ownership pointer to an extension dictionary which, in turn, owns
      subobjects placed in it by an application.

Symbol tables and symbol table records are database objects and, thus, have a handle.
They can also have xdata and persistent reactors in their DXF records.

.. _DXF R12 Data Model:

DXF R12 Data Model
------------------

The DXF R12 data model is identical to the file structure:

    - HEADER section: common settings for the DXF drawing
    - TABLES section: definitions for LAYERS, LINETYPE, STYLES ....
    - BLOCKS section: block definitions and its content
    - ENTITIES section: modelspace and paperspace content

References are realized by simple names. The INSERT entity references the BLOCK definition
by the BLOCK name, a TEXT entity defines the associated STYLE and LAYER by its name and
so on, handles are not needed. Layout association of graphical entities in the ENTITIES
section by the paper_space tag :code:`(67, 0 or 1)`, 0 or missing tag means modelspace,
1 means paperspace. The content of BLOCK definitions is enclosed by the BLOCK and the
ENDBLK entity, no additional references are needed.

A clean and simple file structure and data model, which seems to be the reason why the
DXF R12 Reference (released 1992) is still a widely used file format and Autodesk/AutoCAD
supports the format by reading and writing DXF R12 files until today (DXF R13/R14 has no
writing support by AutoCAD!).

**TODO: list of available entities**

.. seealso::

    More information about the DXF :ref:`File Structure`

.. _DXF R13+ Data Model:

DXF R13+ Data Model
-------------------

With the DXF R13 file format, handles are mandatory and they are really used for organizing
the new data structures introduced with DXF R13.

The HEADER section is still the same with just more available settings.

The new CLASSES section contains AutoCAD specific data, has to be written like AutoCAD
it does, but must not be understood.

The TABLES section got a new BLOCK_RECORD table - see :ref:`Block Management Structures`
for more information.

The BLOCKS sections is mostly the same, but with handles, owner tags and new ENTITY types.
Not active paperspace layouts store their content also in the BLOCKS section - see
:ref:`Layout Management Structures` for more information.

The ENTITIES section is also mostly same, but with handles, owner tags and new ENTITY types.

**TODO: list of new available entities**

And the new OBJECTS section - now its getting complicated!

Most information about the OBJECTS section is just guessed or gathered by trail and error,
because the documentation of the OBJECTS section and its objects in the DXF reference
provided by Autodesk is very shallow.
This is also the reason why I started the DXF Internals section, may be it helps other
developers to start one or two steps above level zero.

The OBJECTS sections stores all the non-graphical entities of the DXF drawing.
Non-graphical entities from now on just called 'DXF objects' to differentiate them from
graphical entities, just called 'entities'. The OBJECTS section follows commonly the
ENTITIES section, but this is not mandatory.

DXF R13 introduces several new DXF objects, which resides exclusive in the OBJECTS
section, taken from the DXF R14 reference, because I have no access to the DXF R13
reference, the DXF R13 reference is a compiled .hlp file which can't be read on Windows 10
or later, this a perfect example for not using closed (proprietary) data formats ;):

    - DICTIONARY: a general structural entity as a <name: handle> container
    - ACDBDICTIONARYWDFLT: a DICTIONARY with a default value
    - DICTIONARYVAR: used by AutoCAD to store named values in the database
    - ACAD_PROXY_OBJECT: proxy object for entities created by other applications than AutoCAD
    - GROUP: groups graphical entities without the need of a BLOCK definition
    - IDBUFFER: just a list of references to objects
    - IMAGEDEF: IMAGE definition structure, required by the IMAGE entity
    - IMAGEDEF_REACTOR: also required by the IMAGE entity
    - LAYER_INDEX: container for LAYER names
    - MLINESTYLE
    - OBJECT_PTR
    - RASTERVARIABLES
    - SPATIAL_INDEX: is always written out empty to a DXF file. This object can be ignored.
    - SPATIAL_FILTER
    - SORTENTSTABLE: control for regeneration/redraw order of entities
    - XRECORD: used to store and manage arbitrary data. This object is similar in concept
      to XDATA but is not limited by size or order. Not supported by R13c0 through R13c3.

Still missing the LAYOUT object, which is mandatory in DXF R2000 to manage multiple
paperspace layouts. I don't know how DXF R13/R14 manages multiple layouts or if they
even support this feature, but I don't care much about DXF R13/R14, because AutoCAD has
no write support for this two formats anymore. Ezdxf tries to upgrade this two DXF
versions to DXF R2000 with the advantage of only two different data models to support:
DXF R12 and DXF R2000+

New objects introduced by DXF R2000:

    - LAYOUT: management object for modelspace and multiple paperspace layouts
    - ACDBPLACEHOLDER: surprise - just a place holder

New objects in DXF R2004:

    - DIMASSOC
    - LAYER_FILTER
    - MATERIAL
    - PLOTSETTINGS
    - VBA_PROJECT

New objects in DXF R2007:

    - DATATABLE
    - FIELD
    - LIGHTLIST
    - RENDER
    - RENDERENVIRONMENT
    - MENTALRAYRENDERSETTINGS
    - RENDERGLOBAL
    - SECTION
    - SUNSTUDY
    - TABLESTYLE
    - UNDERLAYDEFINITION
    - VISUALSTYLE
    - WIPEOUTVARIABLES

New objects in DXF R2013:

    - GEODATA

New objects in DXF R2018:

    - ACDBNAVISWORKSMODELDEF

Undocumented objects:

    - SCALE
    - ACDBSECTIONVIEWSTYLE
    - FIELDLIST

.. _Object Organisation:

Objects Organisation
--------------------

Many objects in the OBJECTS section are organized in a tree-like structure of DICTIONARY
objects.

Starting point for this data structure is the 'root' DICTIONARY with several entries to
other DICTIONARY objects.  The root DICTIONARY has to be the first object in the OBJECTS
section.  The management dicts for GROUP and LAYOUT objects are really important, but
IMHO most of the other management tables are optional and for the most use cases not
necessary.  Ezdxf creates only these entries in the root dict and most of them pointing
to an empty DICTIONARY:

    - ACAD_COLOR: points to an empty DICTIONARY
    - ACAD_GROUP: required
    - ACAD_LAYOUT: required
    - ACAD_MATERIAL: points to an empty DICTIONARY
    - ACAD_MLEADERSTYLE: points to an empty DICTIONARY
    - ACAD_MLINESTYLE: points to an empty DICTIONARY
    - ACAD_PLOTSETTINGS: points to an empty DICTIONARY
    - ACAD_PLOTSTYLENAME: required, points to ACDBDICTIONARYWDFLT with one entry: 'Normal'
    - ACAD_SCALELIST: points to an empty DICTIONARY
    - ACAD_TABLESTYLE: points to an empty DICTIONARY
    - ACAD_VISUALSTYLE: points to an empty DICTIONARY

.. _Root DICTIONARY:

Root DICTIONARY content for DXF R2018
-------------------------------------

.. code-block:: none

    0
    SECTION
    2       <<< start of the OBJECTS section
    OBJECTS
    0       <<< root DICTIONARY has to be the first object in the OBJECTS section
    DICTIONARY
    5       <<< handle
    C
    330     <<< owner tag
    0       <<< always #0, has no owner
    100
    AcDbDictionary
    281     <<< hard owner flag
    1
    3       <<< first entry
    ACAD_CIP_PREVIOUS_PRODUCT_INFO
    350     <<< handle to target (pointer)
    78B     <<< points to a XRECORD with product info about the creator application
    3       <<< entry with unknown meaning, if I should guess: something with about colors ...
    ACAD_COLOR
    350
    4FB     <<< points to a DICTIONARY
    3       <<< entry with unknown meaning
    ACAD_DETAILVIEWSTYLE
    350
    7ED     <<< points to a DICTIONARY
    3       <<< GROUP management, mandatory in all DXF versions
    ACAD_GROUP
    350
    4FC     <<< points to a DICTIONARY
    3       <<< LAYOUT management, mandatory if more than the *active* paperspace is used
    ACAD_LAYOUT
    350
    4FD     <<< points to a DICTIONARY
    3       <<< MATERIAL management
    ACAD_MATERIAL
    350
    4FE     <<< points to a DICTIONARY
    3       <<< MLEADERSTYLE management
    ACAD_MLEADERSTYLE
    350
    4FF     <<< points to a DICTIONARY
    3       <<< MLINESTYLE management
    ACAD_MLINESTYLE
    350
    500     <<< points to a DICTIONARY
    3       <<< PLOTSETTINGS management
    ACAD_PLOTSETTINGS
    350
    501     <<< points to a DICTIONARY
    3       <<< plot style name management
    ACAD_PLOTSTYLENAME
    350
    503     <<< points to a ACDBDICTIONARYWDFLT
    3       <<< SCALE management
    ACAD_SCALELIST
    350
    504     <<< points to a DICTIONARY
    3       <<< entry with unknown meaning
    ACAD_SECTIONVIEWSTYLE
    350
    7EB     <<< points to a DICTIONARY
    3       <<< TABLESTYLE management
    ACAD_TABLESTYLE
    350
    505     <<< points to a DICTIONARY
    3       <<< VISUALSTYLE management
    ACAD_VISUALSTYLE
    350
    506     <<< points to a DICTIONARY
    3       <<< entry with unknown meaning
    ACDB_RECOMPOSE_DATA
    350
    7F3
    3       <<< entry with unknown meaning
    AcDbVariableDictionary
    350
    7AE     <<< points to a DICTIONARY with handles to DICTIONARYVAR objects
    0
    DICTIONARY
    ...
    ...
    0
    ENDSEC


--- End of file: dxfinternals/datamodel.rst ---



--- Start of file: dxfinternals/dxftags.rst ---

.. _dxf_tags_internals:

DXF Tags
========

A Drawing Interchange File is simply an ASCII text file with a file
type of .dxf and special formatted text. The basic file structure
are DXF tags, a DXF tag consist of a DXF group code as an integer
value on its own line and a the DXF value on the following line.
In the ezdxf documentation DXF tags will be written as (group code, value).

With the introduction of extended symbol names in DXF R2000, the 255-character
limit for strings has been increased to 2049 single-byte characters not
including the newline at the end of the line.
Nonetheless its safer to use only strings with 255 and less characters, because
its not clear if this fact is true for ALL string group codes or only for symbols
like layer- or text style names and not all 3rd party libraries may handle
this fact correct. The MTEXT content and binary data is still divided into
chunks with less than 255 characters.

Group codes are indicating the value type:

============ ==================
Group Code   Value Type
============ ==================
0-9          String
10-39        Double precision 3D point value
40-59        Double-precision floating-point value
60-79        16-bit integer value
90-99        32-bit integer value
100          String
102          String
105          String representing hexadecimal (hex) handle value
110-119      Double precision floating-point value
120-129      Double precision floating-point value
130-139      Double precision floating-point value
140-149      Double precision scalar floating-point value
160-169      64-bit integer value
170-179      16-bit integer value
210-239      Double-precision floating-point value
270-279      16-bit integer value
280-289      16-bit integer value
290-299      Boolean flag value
300-309      Arbitrary text string
310-319      String representing hex value of binary chunk
320-329      Arbitrary pointer, hex object ID, not translated during INSERT and XREF operations
330-339      Soft-pointer, hex object ID, translated during INSERT and XREF operations
340-349      Hard-pointer, hex object ID, translated during INSERT and XREF operations
350-359      Soft-owner, hex object ID, translated during INSERT and XREF operations
360-369      Hard-owner, hex object ID, translated during INSERT and XREF operations
370-379      16-bit integer value
380-389      16-bit integer value
390-399      String representing hex handle value
400-409      16-bit integer value
410-419      String
420-429      32-bit integer value
430-439      String
440-449      32-bit integer value
450-459      Long
460-469      Double-precision floating-point value
470-479      String
480-481      Hard-pointer, hex object ID, translated during INSERT and XREF operations
999          Comment (string)
1000-1009    String
1010-1059    Double-precision floating-point value
1060-1070    16-bit integer value
1071         32-bit integer value
============ ==================

Explanation for some important group codes:

================= =======
Group Code        Meaning
================= =======
0                 DXF structure tag, entity start/end or table entries
1                 The primary text value for an entity
2                 A name: Attribute tag, Block name, and so on. Also used to
                  identify a DXF section or table name.
3-4               Other textual or name values
5                 Entity handle as hex string (fixed)
6                 Line type name (fixed)
7                 Text style name (fixed)
8                 Layer name (fixed)
9                 Variable name identifier (used only in HEADER section of the
                  DXF file)
10                Primary X coordinate (start point of a Line or Text entity,
                  center of a Circle, etc.)
11-18             Other X coordinates
20                Primary Y coordinate. 2n values always correspond to 1n values
                  and immediately follow them in the file (expected by ezdxf!)
21-28             Other Y coordinates
30                Primary Z coordinate. 3n values always correspond to 1n and
                  2n values and immediately follow them in the file (expected by ezdxf!)
31-38             Other Z coordinates
39                This entity's thickness if nonzero (fixed)
40-48             Float values (text height, scale factors, etc.)
49                Repeated value - multiple 49 groups may appear in one entity
                  for variable length tables (such as the dash lengths in the
                  LTYPE table). A 7x group always appears before the first 49
                  group to specify the table length
50-58             Angles in degree
62                Color number (fixed)
66                "Entities follow" flag (fixed), only in INSERT and POLYLINE entities
67                Identifies whether entity is in modelspace (0) or paperspace (1)
68                Identifies whether viewport is on but fully off screen, is not
                  active, or is off
69                Viewport identification number
70-78             Integer values such as repeat counts, flag bits, or modes
105               DIMSTYLE entity handle as hex string (fixed)
210, 220, 230     X, Y, and Z components of extrusion direction (fixed)
310               Proxy entity graphics as binary encoded data
330               Owner handle as hex string
347               MATERIAL handle as hex string
348               VISUALSTYLE  handle as hex string
370               Lineweight in mm times 100 (e.g. 0.13mm = 13).
390               PLOTSTYLE handle as hex string
420               True color value as 0x00RRGGBB 24-bit value
430               Color name as string
440               Transparency value 0x020000TT 0 = fully transparent / 255 = opaque
999               Comments
================= =======

For explanation of all group codes see: `DXF Group Codes in Numerical Order Reference`_
provided by Autodesk

.. _xdata_internals:

Extended Data
-------------

`DXF R2018 Reference <https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A2A628B0-3699-4740-A215-C560E7242F63>`_

Extended data (XDATA) is created by AutoLISP or ObjectARX applications but any
other application like *ezdxf* can also define XDATA. If an entity contains
extended data, it **follows** the entity's normal definition.

But extended group codes (>=1000) can appear **before** the XDATA section, an
example is the BLOCKBASEPOINTPARAMETER entity in AutoCAD Civil 3D or AutoCAD
Map 3D.

================= ==============================================================
Group Code        Description
================= ==============================================================
1000              Strings in extended data can be up to 255 bytes long (with the
                  256th byte reserved for the null character)
1001              (fixed) Registered application name (ASCII string up to 31 bytes
                  long) for XDATA
1002              (fixed) An extended data control string can be either ``'{'``
                  or ``'}'``. These braces enable applications to organize their
                  data by subdividing the data into lists. Lists can be nested.
1003              Name of the layer associated with the extended data
1004              Binary data is organized into variable-length chunks.
                  The maximum length of each chunk is 127 bytes. In ASCII DXF
                  files, binary data is represented as a string of hexadecimal
                  digits, two per binary byte
1005              Database Handle of entities in the drawing database, see also:
                  :ref:`About 1005 Group Codes`
1010, 1020, 1030  Three real values, in the order X, Y, Z. They can be used as a
                  point or vector record that will not be modified at any
                  transformation of the entity.
1011, 1021, 1031  a WCS point that is moved, scaled, rotated and mirrored
                  along with the entity
1012, 1012, 1022  a WCS displacement that is scaled, rotated and mirrored
                  along with the entity, but is not moved
1013, 1023, 1033  a WCS direction that is rotated and mirrored along with the
                  entity, but is not moved or scaled
1040              A real value
1041              Distance, a real value that is scaled along with the parent entity
1042              Scale Factor, also a real value that is scaled along with the parent.
                  The difference between a distance and a scale factor is application-defined
1070              A 16-bit integer (signed or unsigned)
1071              A 32-bit signed (long) integer
================= ==============================================================


The (1001, ...) tag indicates the beginning of extended data. In
contrast to normal entity data, with extended data the same group code can
appear multiple times, and **order is important**.

Extended data is grouped by registered application name. Each registered
application group begins with a (1001, APPID) tag, with the application
name as APPID string value. Registered application names correspond to APPID
symbol table entries.

An application can use as many APPID names as needed. APPID names are permanent,
although they can be purged if they aren't currently used in the drawing.
Each APPID name can have **no more than one data group** attached to each entity.
Within an application group, the sequence of extended data groups and their
meaning is defined by the application.

.. _String Value Encoding:

String value encoding
---------------------

String values stored in a DXF file is plain ASCII or UTF-8, AutoCAD also
supports CIF (Common Interchange Format) and MIF (Maker Interchange Format)
encoding. The UTF-8 format is only supported in DXF R2007 and later.

Ezdxf on import converts all strings into Python unicode strings without
encoding or decoding CIF/MIF.

String values containing Unicode characters are represented with control
character sequences ``\U+nnnn``.
(e.g. ``r'TEST\U+7F3A\U+4E4F\U+89E3\U+91CA\U+6B63THIS\U+56FE'``)

To support the DXF unicode encoding ezdxf registers an encoding codec
`dxf_backslash_replace`, defined in :func:`ezdxf.lldxf.encoding`.

String values can be stored with these dxf group codes:

- 0 - 9
- 100 - 101
- 300 - 309
- 410 - 419
- 430 - 439
- 470 - 479
- 999 - 1003

Multi tag text (MTEXT)
----------------------

If the text string is less than 250 characters, all characters appear in tag
(1, ...). If the text string is longer than 250 characters, the string
is divided into 250-character chunks, which appear in one or more
(3, ...) tags. If (3, ...) tags are used, the last group is a
(1, ...) tag and has fewer than 250 characters:

.. code-block:: none

    3
    ... TwoHundredAndFifty Characters ....
    3
    ... TwoHundredAndFifty Characters ....
    1
    less than TwoHundredAndFifty Characters

As far I know this is only supported by the MTEXT entity.

.. seealso::

    :ref:`DXF File Encoding`

.. _Tag Structure DXF R13 and later:

DXF R13 and later tag structure
-------------------------------

With the introduction of DXF R13 Autodesk added additional group codes and DXF
tag structures to the DXF Standard.

Subclass Markers
~~~~~~~~~~~~~~~~

Subclass markers (100, Subclass Name) divides DXF objects into several
sections. Group codes can be reused in different sections. A subclass ends with
the following subclass marker or at the beginning of xdata or the end of the
object. See `Subclass Marker Example`_ in the DXF Reference.

Quote about group codes from the DXF reference
----------------------------------------------

    Some group codes that define an entity always appear; others are optional
    and appear only if their values differ from the defaults.

    **Do not** write programs that **rely on the order given here**. The end of
    an entity is indicated by the next 0 group, which begins the next entity or
    indicates the end of the section.

    **Note:** Accommodating DXF files from future releases of AutoCAD will be
    easier if you write your DXF processing program in a table-driven way,
    ignore undefined group codes, and make no assumptions about the order of
    group codes in an entity. With each new AutoCAD release, new group codes
    will be added to entities to accommodate additional features.

Usage of group codes in subclasses twice
----------------------------------------

Some later entities entities contains the same group code twice for different
purposes, so order in the sense of which one comes first is important.
(e.g. ATTDEF group code 280)

Tag order is sometimes important especially for AutoCAD
-------------------------------------------------------

In LWPOLYLINE the order of tags is important, if the `count` tag is not the
first tag in the AcDbPolyline subclass, AutoCAD will not close the polyline
when the `close` flag is set, by the way other applications like BricsCAD
ignores the tag order and renders the polyline always correct.

.. _extension_dict_internals:

Extension Dictionary
~~~~~~~~~~~~~~~~~~~~

The extension dictionary is an optional sequence that stores the handle of a
DICTIONARY object that belongs to the current object, which in turn may contain
entries. This facility allows attachment of arbitrary database objects to any
database object. Any object or entity may have this section.

The extension dictionary tag sequence:

.. code-block:: none

  102
  {ACAD_XDICTIONARY
  360
  Hard-owner ID/handle to owner dictionary
  102
  }

.. _reactors_internals:

Persistent Reactors
~~~~~~~~~~~~~~~~~~~

Persistent reactors are an optional sequence that stores object handles of
objects registering themselves as reactors on the current object. Any object or
entity may have this section.

The persistent reactors tag sequence:

.. code-block:: none

  102
  {ACAD_REACTORS
  330
  first Soft-pointer ID/handle to owner dictionary
  330
  second Soft-pointer ID/handle to owner dictionary
  ...
  102
  }

.. _app_data_internals:

Application-Defined Codes
~~~~~~~~~~~~~~~~~~~~~~~~~

Starting at DXF R13, DXF objects can contain application-defined codes outside
of XDATA. This application-defined codes can contain any tag except
(0, ...) and (102, '{...'). "{YOURAPPID" means the APPID string
with an preceding "{". The application defined data tag sequence:

.. code-block:: none

    102
    {YOURAPPID
    ...
    102
    }

:code:`(102, 'YOURAPPID}')` is also a valid closing tag:

.. code-block:: none

    102
    {YOURAPPID
    ...
    102
    YOURAPPID}

All groups defined with a beginning (102, ...) appear in the DXF
reference before the first subclass marker, I don't know if these groups can
appear after the first or any subclass marker. Ezdxf accepts them at any position,
and by default ezdxf adds new app data in front of the first subclass marker to
the first tag section of an DXF object.

**Exception XRECORD:** Tags with group code 102 and a value string without a
preceding "{" or the scheme "YOURAPPID}", should be treated as usual group codes.

.. _embedded_objects_internals:

Embedded Objects
~~~~~~~~~~~~~~~~

The concept of embedded objects was introduced with AutoCAD 2018 (DXF version
AC1032) and this is the only information I found about it at the Autodesk
knowledge base: `Embedded and Encapsulated Objects`_

Quote from `Embedded and Encapsulated Objects`_:

    For DXF filing, the embedded object must be filed out and in after all the
    data of the encapsulating object has been filed out and in.

    A separator is needed between the encapsulating object's data and the
    subsequent embedded object's data. The separator must be similar in function
    to the group 0 or 100 in that it must cause the filer to stop reading data.
    The normal DXF group code 0 cannot be used because DXF proxies use it to
    determine when to stop reading data. The group code 100 could have been
    used, but it might have caused confusion when manually reading a DXF file,
    and there was a need to distinguish when an embedded object is about to be
    written out in order to do some internal bookkeeping. Therefore, the DXF
    group code 101 was introduced.

**Hard facts:**

- Only used in ATTRIB, ATTDEF (embedded MTEXT) and MTEXT (columns) in DXF R2018.
- Embedded object start with (101, "Embedded Object") tag
- Embedded object is appended to the encapsulated object
- Embedded object tags can contain any group code except the DXF structure tag (0, ...)

**Unconfirmed assumptions:**

- The embedded object is written before the `Extended Data`_. No examples for
  entities including embedded objects and XDATA at the same time.
- XDATA sections replaced by embedded objects, at least for the MTEXT entity
- The encapsulating object can contain more than one embedded object.
- Embedded objects separated by (101, "Embedded Object") tags
- every entity can contain embedded objects

Real world example from an AutoCAD 2018 file:

.. code-block:: none

  100       <<< start of encapsulating object
  AcDbMText
  10
  2762.148
  20
  2327.073
  30
  0.0
  40
  2.5
  41
  18.852
  46
  0.0
  71
  1
  72
  5
  1
  {\fArial|b0|i0|c162|p34;CHANGE;\P\P\PTEXT}
  73
  1
  44
  1.0
  101       <<< start of embedded object
  Embedded Object
  70
  1
  10
  1.0
  20
  0.0
  30
  0.0
  11
  2762.148
  21
  2327.073
  31
  0.0
  40
  18.852
  41
  0.0
  42
  15.428
  43
  15.043
  71
  2
  72
  1
  44
  18.852
  45
  12.5
  73
  0
  74
  0
  46
  0.0

.. include:: reflinks.inc


.. _DXF Group Codes in Numerical Order Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-3F0380A5-1C15-464D-BC66-2C5F094BCFB9

.. _Subclass Marker Example: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-CC5ACB1B-BBA3-463B-84A5-6CCD320C66E7

.. _Embedded and Encapsulated Objects: https://knowledge.autodesk.com/search-result/caas/CloudHelp/cloudhelp/2017/ENU/OARXMAC-DevGuide/files/GUID-C953866F-A335-4FFD-AE8C-256A76065552-htm.html

--- End of file: dxfinternals/dxftags.rst ---



--- Start of file: dxfinternals/entities/dimension_entity.rst ---

.. _DIMENSION Internals:

DIMENSION Internals
===================

.. seealso::

    - DXF Reference: `DIMENSION`_
    - DXFInternals: :ref:`dimstyle_table_internals`


.. image:: gfx/dimension_defpoints.svg
    :align: center
    :width: 800px


.. _DIMENSION: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-239A1BDD-7459-4BB9-8DD7-08EC79BF1EB0


--- End of file: dxfinternals/entities/dimension_entity.rst ---



--- Start of file: dxfinternals/entities/index.rst ---

DXF Entities
============

.. toctree::
    :maxdepth: 3

    dimension_entity
    mesh
    mleader
    mtext

--- End of file: dxfinternals/entities/index.rst ---



--- Start of file: dxfinternals/entities/mesh.rst ---

.. _MESH Internals:

MESH Internals
==============

The MESH entity is the compact version of the PolyFaceMesh implemented by the
:class:`~ezdxf.entities.Polyline` entity . The entity stores the vertices, edges
and faces in a single entity and was introduced in DXF version R13/R14.
For more information about the top level stuff go to the
:class:`~ezdxf.entities.Mesh` class.

.. seealso::

    - DXF Reference: `MESH`_
    - :class:`ezdxf.entities.Mesh` class

The following DXF code represents this cube with subdivision level of 0:

.. image:: gfx/mesh_cube_0.png

.. code-block:: Text

    0
    MESH            <<< DXF type
    5               <<< entity handle
    2F
    330             <<< block record handle of owner layout
    17
    100
    AcDbEntity
    8
    0               <<< layer
    62
    6               <<< color
    100
    AcDbSubDMesh    <<< subclass marker
    71
    2               <<< version
    72
    1               <<< blend crease, 1 is "on", 0 is "off"
    91
    0               <<< subdivision level is 0
    92
    8               <<< vertex count, 8 cube corners
    10              <<< 1. vertex, x-axis
    0.0
    20              <<< y-axis
    0.0
    30              <<< z-axis
    0.0
    10              <<< 2. vertex
    1.0
    20
    0.0
    30
    0.0
    10              <<< 3. vertex
    1.0
    20
    1.0
    30
    0.0
    10              <<< 4. vertex
    0.0
    20
    1.0
    30
    0.0
    10              <<< 5. vertex
    0.0
    20
    0.0
    30
    1.0
    10              <<< 6. vertex
    1.0
    20
    0.0
    30
    1.0
    10              <<< 7. vertex
    1.0
    20
    1.0
    30
    1.0
    10              <<< 8. vertex
    0.0
    20
    1.0
    30
    1.0
    93              <<< size of face list
    30              <<< size  = count of group code 90 tags = 6 x 5
    90              <<< vertex count of face 1
    4               <<< MESH supports ngons, count = 3, 4, 5, 6 ...
    90
    0       <<< face 1, index of 1. vertex
    90
    3       <<< face 1, index of 2. vertex
    90
    2       <<< face 1, index of 3. vertex
    90
    1       <<< face 1, index of 4. vertex
    90
    4               <<< vertex count of face 2
    90
    4       <<< face 2, index of 1. vertex
    90
    5       <<< face 2, index of 2. vertex
    90
    6       <<< face 2, index of 3. vertex
    90
    7       <<< face 2, index of 4. vertex
    90
    4               <<< vertex count of face 3
    90
    0       <<< face 3, index of 1. vertex
    90
    1       <<< face 3, index of 2. vertex
    90
    5       <<< face 3, index of 3. vertex
    90
    4       <<< face 3, index of 4. vertex
    90
    4               <<< vertex count of face 4
    90
    1       <<< face 4, index of 1. vertex
    90
    2       <<< face 4, index of 2. vertex
    90
    6       <<< face 4, index of 3. vertex
    90
    5       <<< face 4, index of 4. vertex
    90
    4               <<< vertex count of face 5
    90
    3       <<< face 5, index of 1. vertex
    90
    7       <<< face 5, index of 2. vertex
    90
    6       <<< face 5, index of 3. vertex
    90
    2       <<< face 5, index of 4. vertex
    90
    4               <<< vertex count of face 6
    90
    0       <<< face 6, index of 1. vertex
    90
    4       <<< face 6, index of 2. vertex
    90
    7       <<< face 6, index of 3. vertex
    90
    3       <<< face 6, index of 4. vertex
    94              <<< edge count, each edge has exact two group code 90 tags
    4               <<< the real edge count not the group code 90 tags!
    90
    0       <<< edge 1, vertex 1
    90
    1       <<< edge 1, vertex 1
    90
    1       <<< edge 2, vertex 1
    90
    2       <<< edge 2, vertex 2
    90
    2       <<< edge 3, vertex 1
    90
    3       <<< edge 3, vertex 2
    90
    3       <<< edge 4, vertex 1
    90
    0       <<< edge 4, vertex 2
    95              <<< edge crease count, has to match edge count!
    4
    140
    3.0     <<< crease value for edge 1
    140
    3.0     <<< crease value for edge 2
    140
    3.0     <<< crease value for edge 3
    140
    3.0     <<< crease value for edge 4
    90              <<< property overwrite???
    0

The edge and crease data have only a meaning if subdivision of the geometry will
be applied!
A crease value equal to the subdivision level prevents subdividing for the
edge completely, a value between 0.0 and the subdivision level applies
subdivision partially.

The cube with subdivision level of 3 and crease values of 3.0:

.. image:: gfx/mesh_cube_3.png

Front view for better details:

.. image:: gfx/mesh_cube_3_front.png

The cube with subdivision levels of 3 and crease values of 2.0:

.. image:: gfx/mesh_cube_2.png

The cube with subdivision level of 3 and crease values of 1.0:

.. image:: gfx/mesh_cube_1.png

The property overriding protocol is not documented in the DXF reference
and currently I have no access to a CAD application which can created
property overriding.

.. _MESH: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-4B9ADA67-87C8-4673-A579-6E4C76FF7025

--- End of file: dxfinternals/entities/mesh.rst ---



--- Start of file: dxfinternals/entities/mleader.rst ---

.. _MLEADER Internals:

MULTILEADER Internals
=====================

The MULTILEADER leader is a very complex entity and has also some weird and
unique properties.

1. MULTILEADER has the alias name MLEADER which is accepted by any
   :term:`reliable CAD application`, but all of them create the entity as
   MULTILEADER
2. uses :term:`raw-color` values to define colors
3. creates a complex context data structures beyond simple tags inside the
   subclass ``AcDbMLeader``

.. seealso::

    - :class:`ezdxf.entities.MultiLeader`
    - :class:`ezdxf.entities.MLeaderStyle`
    - :class:`ezdxf.render.MultiLeaderBuilder`
    - :ref:`tut_mleader`
    - DXF Reference: `MLEADER`_

Example for :class:`ezdxf.entities.MLeaderContext` created by BricsCAD:

.. code-block::

    300 <str> CONTEXT_DATA{
    40 <float> 1.0    <<< content scale
    10 <point> (x, y, z)      <<< content base point
    41 <float> 4.0    <<< text height
    140 <float> 4.0   <<< arrowhead size
    145 <float> 2.0   <<< landing gap size
    174 <int> 1       <<< doc missing
    175 <int> 1       <<< doc missing
    176 <int> 0       <<< doc missing
    177 <int> 0       <<< doc missing
    290 <int> 1       <<< has_mtext_content
    <<< START MText Content tags:
    304 <str> MTEXT content string
    11 <point> (0.0, 0.0, 1.0)    <<< extrusion vector
    340 <hex> #A0                 <<< text style as handle
    12 <point> (x, y, z)          <<< text location
    13 <point> (1.0, 0.0, 0.0)    <<< text direction
    42 <float> 0.0        <<< text rotation
    43 <float> 0.0        <<< text width
    44 <float> 0.0        <<< text height
    45 <float> 1.0        <<< text line space factor
    170 <int> 1           <<< text line space style
    90 <int> -1056964608  <<< text color (raw value)
    171 <int> 1           <<< text attachment
    172 <int> 1           <<< text flow direction
    91 <int> -939524096   <<< text background color (raw value)
    141 <float> 1.5       <<< text background scale factor
    92 <int> 0            <<< text background transparency
    291 <int> 0           <<< has_text_bg_color
    292 <int> 0           <<< has_text_bg_fill
    173 <int> 0           <<< text column type
    293 <int> 0           <<< use text auto height
    142 <float> 0.0       <<< text column width
    143 <float> 0.0       <<< text column gutter width
    294 <int> 0           <<< text column flow reversed
    144 <float> missing   <<< text column height (optional?)
    295 <int> 0           <<< text use word break
    <<< END MText Content tags:
    296 <int> 0       <<< has_block_content
    <<< START Block content tags
    <<< END Block content tags
    110 <point> (0.0, 0.0, 0.0)       <<< MLEADER plane origin point
    111 <point> (1.0, 0.0, 0.0)       <<< MLEADER plane x-axis direction
    112 <point> (0.0, 1.0, 0.0)       <<< MLEADER plane y-axis direction
    297 <int> 0                       <<< MLEADER normal reversed
    302 <str> LEADER{
    ...
    303 <str> }
    302 <str> LEADER{
    ...
    303 <str> }
    272 <int> 9       <<< doc missing
    273 <int> 9       <<< doc missing
    301 <str> }
    <<< BricsCAD example for block content:
    300 <str> CONTEXT_DATA{
    40 <float> 1.0
    10 <point> (x, y, z)
    41 <float> 4.0
    140 <float> 4.0
    145 <float> 2.0
    174 <int> 1
    175 <int> 1
    176 <int> 0
    177 <int> 0
    290 <int> 0       <<< has_mtext_content
    296 <int> 1       <<< has_block_content
    <<< START Block content tags
    341 <hex> #94                 <<< dxf.block_record_handle
    14 <point> (0.0, 0.0, 1.0)    <<< Block extrusion vector
    15 <point> (x, y, z)          <<< Block location
    16 <point> (1.0, 1.0, 1.0)    <<< Block scale vector, the x-, y- and z-axis scaling factors
    46 <float> 0.0                <<< Block rotation in radians!
    93 <int> -1056964608          <<< Block color (raw value)
    47 <float> 1.0                <<< start of transformation matrix (16x47)
    47 <float> 0.0
    47 <float> 0.0
    47 <float> 18.427396871473
    47 <float> 0.0
    47 <float> 1.0
    47 <float> 0.0
    47 <float> 0.702618780008
    47 <float> 0.0
    47 <float> 0.0
    47 <float> 1.0
    47 <float> 0.0
    47 <float> 0.0
    47 <float> 0.0
    47 <float> 0.0
    47 <float> 1.0                <<< end of transformation matrix
    <<< END Block content tags
    110 <point> (0.0, 0.0, 0.0)       <<< MLEADER plane origin point
    111 <point> (1.0, 0.0, 0.0)       <<< MLEADER plane x-axis direction
    112 <point> (0.0, 1.0, 0.0)       <<< MLEADER plane y-axis direction
    297 <int> 0                       <<< MLEADER normal reversed
    302 <str> LEADER{
    ...
    303 <str> }
    272 <int> 9
    273 <int> 9
    301 <str> }
    <<< Attribute content and other redundant block data is stored in the AcDbMLeader
    <<< subclass:
    100 <ctrl> AcDbMLeader
    270 <int> 2                   <<< dxf.version
    300 <str> CONTEXT_DATA{       <<< start context data
    ...
    301 <str> }                   <<< end context data
    340 <hex> #6D                 <<< dxf.style_handle
    90 <int> 6816768              <<< dxf.property_override_flags
    ...                           <<< property overrides
    292 <int> 0                   <<< dxf.has_frame_text
    <<< mostly redundant block data:
    344 <hex> #94                 <<< dxf.block_record_handle
    93 <int> -1056964608          <<< dxf.block_color (raw value)
    10 <point> (1.0, 1.0, 1.0)    <<< dxf.block_scale_vector
    43 <float> 0.0                <<< dxf.block_rotation in radians!
    176 <int> 0                   <<< dxf.block_connection_type
    293 <int> 0                   <<< dxf.is_annotative
    <<< REPEAT: (optional)
    94 <int>                      <<< arrow head index?
    345 <hex>                     <<< arrow head handle
    <<< REPEAT: (optional)
    330 <hex> #A3                 <<< ATTDEF handle
    177 <int> 1                   <<< ATTDEF index
    44 <float> 0.0                <<< ATTDEF width
    302 <str> B                   <<< ATTDEF text (reused group code)
    ...  common group codes 294, 178, 179, ...

.. _MLEADER: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-72D20B8C-0F5E-4993-BEB7-0FCF94F32BE0

--- End of file: dxfinternals/entities/mleader.rst ---



--- Start of file: dxfinternals/entities/mtext.rst ---

.. _MTEXT Internals:

MTEXT Internals
===============

The MTEXT entity stores multiline text in a single entity and was introduced
in DXF version R13/R14. For more information about the top level stuff go to
the :class:`~ezdxf.entities.MText` class.

.. seealso::

    - DXF Reference: `MTEXT`_
    - :class:`ezdxf.entities.MText` class

Orientation
-----------

The MTEXT entity does not establish an OCS. The entity has a :attr:`text_direction`
attribute, which defines the local x-axis, the :attr:`extrusion` attribute defines
the normal vector and the y-axis = extrusion cross x-axis.

The MTEXT entity can have also a :attr:`rotation` attribute (in degrees), the x-axis
attribute has higher priority than the :attr:`rotation` attribute, but it is not clear
how to convert the :attr:`rotation` attribute into a :attr:`text_direction` vector,
but for most common cases, where only the :attr:`rotation` attribute is present,
the :attr:`extrusion` is most likely the WCS z-axis and the :attr:`rotation` is
the direction in the xy-plane.

Text Content
------------

The content text is divided across multiple tags of group code 3 and 1, the last
line has the group code 1, each line can have a maximum line length of 255 bytes,
but BricsCAD (and AutoCAD?) store only 249 bytes in single line and one byte is
not always one char.


Inline Code Specials
--------------------

The text formatting is done by inline codes, see the
:class:`~ezdxf.entities.MText` class.

Information gathered by implementing the :class:`MTextEditor` and the
:class:`MTextParser` classes:

- caret encoded characters:
    - "^I" tabulator
    - "^J" (LF) is a valid line break like "\\P"
    - "^M" (CR) is ignored
    - other characters render as empty square ""
    - a space " " after the caret renders the caret glyph: "1^ 2" renders "1^2"

- special encoded characters:
    - "%%c" and "%%C" renders "" (alt-0216)
    - "%%d" and "%%D" renders "" (alt-0176)
    - "%%p" and "%%P" renders "" (alt-0177)

- Alignment command "\\A": argument "0", "1" or "2" is expected
    - the terminator symbol ";" is optional
    - the arguments "3", "4", "5", "6", "7", "8", "9" and "-" default to 0
    - other characters terminate the command and will be printed: "\\AX", renders "X"

- ACI color command "\\C": int argument is expected
    - the terminator symbol ";" is optional
    - a leading "-" or "+" terminates the command, "\\C+5" renders "\\C+5"
    - arguments > 255, are ignored but consumed "\\C1000" renders nothing, not
      even a "0"
    - a trailing ";" after integers is always consumed, even for much to big
      values, "\\C10000;" renders nothing

- RGB color command "\\c": int argument is expected
    - the terminator symbol ";" is optional
    - a leading "-" or "+" terminates the command, "\\c+255" renders "\\c+255"
    - arguments >= 16777216 are masked by: value & 0xFFFFFF
    - a trailing ";" after integers is always consumed, even for much to big
      values, "\\c9999999999;" renders nothing and switches the color to
      yellow (255, 227, 11)

- Height command "\\H" and "\\H...x": float argument is expected
    - the terminator symbol ";" is optional
    - a leading "-" is valid, but negative values are ignored
    - a leading "+" is valid
    - a leading "." is valid like "\\H.5x" for height factor 0.5
    - exponential format is valid like "\\H1e2" for height factor 100 and
      "\\H1e-2" for 0.01
    - an invalid floating point value terminates the command,
      "\\H1..5" renders "\\H1..5"

- Other commands with floating point arguments like the height command:
    - Width commands "\\W" and "\\W...x"
    - Character tracking commands "\\T" and "\\T...x", negative values are used
    - Slanting (oblique) command "\\Q"

- Stacking command "\\S":
    - build fractions: "numerator (upr)" + "stacking type char (t)" + "denominator (lwr)" + ";"
    - divider chars: "^", "/" or "#"
    - a space " " after the divider char "^" is mandatory to avoid caret
      decoding: "\\S1^ 2;"
    - the terminator symbol ";" is mandatory to end the command, all
      chars beyond the "\\S" until the next ";" or the end of the string
      are part of the fraction
    - backslash escape "\\;" to render the terminator char
    - a space " " after the divider chars "/" and "#" is rendered as space " "
      in front of the denominator
    - the numerator and denominator can contain spaces
    - backslashes "\\" inside the stacking command are ignored (except "\\;")
      "\\S\\N^ \\P" render "N" over "P", therefore property changes (color, text
      height, ...) are not possible inside the stacking command
    - grouping chars "{" and "}" render as simple curly braces
    - caret encoded chars are decoded "^I", "^J", "^M", but render as a simple
      space " " or as the replacement char "" plus a space
    - a divider char after the first divider char, renders as the char itself:
      "\\S1/2/3" renders the horizontal fraction "1" / "2/3"

- Font command "\\f" and "\\F": export only "\\f", parse both, "\\F" ignores some arguments
    - the terminator symbol ";" is mandatory to end the command, all
      chars beyond the "\\f" until the next ";" or the end of the string
      are part of the command
    - the command arguments are separated by the pipe char "|"
    - arguments: "font family name" | "bold" | "italic" | "codepage" | "pitch";
      example "\\fArial|b0|i0|c0|p0;"
    - only the "font family name" argument is required, fonts which are not
      available on the system are replaced by the "TXT.SHX" shape font
    - the "font family name" is the font name shown in font selection widgets in
      desktop applications
    - "b1" to use the bold font style, any other second char is interpreted as "non bold"
    - "i1" to use an italic font style, any other second char is interpreted as "non italic"
    - "c???" change codepage, "c0" use the default codepage, because of the age
      of unicode no further investigations, also seems to be ignored by AutoCAD
      and BricsCAD
    - "p???" change pitch size, "p0" means don't change, ignored by AutoCAD and
      BricsCAD, to change the text height use the "\\H" command
    - the order is not important, but export always in the shown order:
      "\\fArial|b0|i0;" the arguments "c0" and "p0" are not required

- Paragraph properties command "\\p"
    - the terminator symbol ";" is mandatory to end the command, all
      chars beyond the "\\p" until the next ";" or the end of the string
      are part of the command
    - the command arguments are separated by commas ","
    - all values are factors for the initial char height of the MTEXT entity,
      example: char height = 2.5, "\\pl1;" set the left paragraph indentation
      to 1 x 2.5 = 2.5 drawing units.
    - all values are floating point values, see height command
    - arguments are "i", "l", "r", "q", "t"
    - a "\*" as argument value, resets the argument to the initial value: "i0",
      "l0", "r0", the "q" argument most likely depends on the text direction;
      I haven't seen "t\*". The sequence used by BricsCAD to reset all values
      is ``"\pi*,l*,r*,q*,t;"``
    - "i" indentation of the first line relative to the "l" argument as floating
      point value, "\\pi1.5"
    - "l" left paragraph indentation as floating point value, "\\pl1.5"
    - "r" right paragraph indentation as floating point value, "\\pr1.5"
    - "x" is required if a "q" or a "t" argument is present, the placement of
      the "x" has no obvious rules
    - "q" paragraph alignment

        - "ql" left paragraph alignment
        - "qr" right paragraph alignment
        - "qc" center paragraph alignment
        - "qj" justified paragraph alignment
        - "qd" distributed paragraph alignment

    - "t" tabulator stops as comma separated list, the default tabulator stops
      are located at 4, 8, 12, ..., by defining at least one tabulator stop,
      the default tabulator stops will be ignored.
      There 3 kind of tabulator stops: left, right and center adjusted stops,
      e.g. "\pxt1,r5,c8":

        - a left adjusted stop has no leading char, two left adjusted stops "\\pxt1,2;"
        - a right adjusted stop has a preceding "r" char, "\\pxtr1,r2;"
        - a center adjusted stop has a preceding "c" char, "\\pxtc1,c2;"

      complex example to create a numbered list with two items:
      ``"pxi-3,l4t4;1.^Ifirst item\P2.^Isecond item"``
    - a parser should be very flexible, I have seen several different orders of
      the arguments and placing the sometimes required "x" has no obvious rules.
    - exporting seems to be safe to follow these three rules:

        1. the command starts with "\\px", the "x" does no harm, if not required
        2. argument order "i", "l", "r", "q", "t", any of the arguments can be left off
        3. terminate the command with a ";"

Height Calculation
------------------

There is no reliable way to calculate the MTEXT height from the existing DXF
attributes. The :attr:`rect_height` (group code 43) attribute is not required
and seldom present.
DXF R2007 introduced the :attr:`defined_height` attribute to store the defined
column height of the MTEXT entity but only in column mode. MTEXT entities without
columns, except MTEXT entities created with column type "No Columns",
store always 0.0 as defined column height. Which seems to mean: defined by the
rendered text content.

The only way to calculate the MTEXT height is to replicate the rendering
results of AutoCAD/BricsCAD by implementing a rendering engine for MTEXT.

In column mode the MTEXT height is stored for every column for DXF version
before R2018. In DXF R2018+ the column heights are only stored if
:attr:`MTextColumns.auto_height` is ``False``. If :attr:`MTextColumns.auto_height`
is ``True``. But DXF R2018+ stores the MTEXT total width and height
in explicit attributes.

Width Calculation
-----------------

The situation for width calculation is better than for the height calculation,
but the attributes :attr:`width` and :attr:`rect_width` are not mandatory.

There is a difference between MTEXT entities with and without columns:

Without columns the attribute :attr:`width` (reference column width) contains
the true entity width if present. A long word can overshoot this width!
The :attr:`rect_width` attribute is seldom present.

For MTEXT with columns, the :attr:`width` attribute is maybe wrong, the correct
width for a column is stored in the :attr:`column_width` attribute and the
:attr:`total_width` attribute stores the total width of the MTEXT entity
overall columns, see also following section "Column Support".

Background Filling
------------------

The background fill support is available for DXF R2007+.
The group code 90 defines the kind of background fill:

=== ================================
0   off
1   color defined by group code 63, 421 or 431
2   drawing window color
3   background (canvas) color
16  bit-flag text frame, see Open Design Alliance Specification 20.4.46
=== ================================

Group codes to define background fill attributes:

=== ===============================
45  scaling factor for the border around the text, the value should be in the
    range of [1, 5], where 1 fits exact the MText entity
63  set the background color by :term:`ACI`.
421 set the background color as :term:`true-color` value.
431 set the background color by color name - no idea how this works
441 set the transparency of the background fill, not supported by AutoCAD or BricsCAD.
=== ===============================

Group codes 45, 90 and 63 are required together if one of them is used.
The group code 421 and 431 also requires the group code 63, even this value
is ignored.

.. code-block:: Text

    ... <snip>
    1 <str> eu feugiat nulla facilisis at vero eros et accumsan et iusto ...
    73 <int> 1
    44 <float> 1.0
    90 <int> 1, b00000001   <<< use a color
    63 <int> 1              <<< ACI color (red)
    45 <float> 1.5          <<< bg scaling factor, relative to the char height
    441 <int> 0             <<< ignored (optional)
    ... <snip>

.. image:: gfx/mtext_bg_color_red.png
    :align: center
    :width: 800px

The background scaling does not alter the :attr:`width`, :attr:`column_width`
or :attr:`total_width` attributes. The background acquires additional space
around the MTEXT entity.

Columns with background color:

.. image:: gfx/mtext_cols_bg.png
    :align: center
    :width: 800px

Text Frame
----------

The MTEXT entity can have a text frame only, without a background filling,
group code 90 has value 16. In this case all other background related tags
are removed (45, 63, 421, 431, 441) and the scaling factor is 1.5 by default.

XDATA for Text Frame
++++++++++++++++++++

This XDATA exist only if the text frame flag in group code 90 is set and for
DXF version < R2018!

.. code-block:: Text

    ...  <snip>
    1001 <ctrl> ACAD
    1000 <str> ACAD_MTEXT_TEXT_BORDERS_BEGIN
    1070 <int> 80       <<< group code for repeated flags
    1070 <int> 16       <<< repeated group code 90?
    1070 <int> 46       <<< group code for scaling factor, which is fixed?
    1040 <float> 1.5    <<< scaling factor
    1070 <int> 81       <<< group code for repeated flow direction?
    1070 <int> 1        <<< flow direction?
    1070 <int> 5        <<< group code for a handle, multiple entries possible
    1005 <hex> #A8      <<< handle to the LWPOLYLINE text frame
    1070 <int> 5        <<< group code for next handle
    1005 <hex> #A9      <<< next handle
    ...
    1000 <str> ACAD_MTEXT_TEXT_BORDERS_END

Extra LWPOLYLINE Entity as Text Frame
+++++++++++++++++++++++++++++++++++++

The newer versions of AutoCAD and BricsCAD get all the information they need
from the MTEXT entity, but it seems that older versions could not handle the
text frame property correct. Therefore AutoCAD and BricsCAD create a separated
LWPOLYLINE entity for the text frame for DXF versions < R2018.
The handle to this text frame entity is stored in the XDATA as group code 1005,
see section above.

Because this LWPOLYLINE is not required *ezdxf* does **not** create such a text
frame entity nor the associated XDATA and *ezdxf* also **removes** this data
from loaded DXF files at the second loading stage.

Column Support
--------------

CAD applications build multiple columns by linking 2 or more MTEXT entities
together. In this case each column is a self-sufficient entity in DXF version
R13 until R2013. The additional columns specifications are stored in the XDATA
if the MTEXT which represents the first column.

DXF R2018 changed the implementation into a single MTEXT entity which contains
all the content text at once and stores the column specification in an
embedded object.

.. hint::

    The :attr:`width` attribute for the linked MTEXT entities could be wrong.
    Always use the :attr:`column_width` and the :attr:`total_width`
    attributes in column mode.

There are two column types, the **static** type has the same column height for
all columns, the **dynamic** type can have the same (auto) height or an
individual height for each column.

Common facts about columns for all column types:

    - all columns have the same column width
    - all columns have the same gutter width
    - the top of the column are at the same height

Column Type
+++++++++++

The column type defines how a CAD application should create the columns, this
is not important for the file format, because the result of this calculation,
the column count and the column height, is stored the DXF file.

======================= ========================================================
Column Type in BricsCAD Description
======================= ========================================================
Static                  All columns have the same height. The "auto height" flag
                        is 0.
Dynamic (auto height)   Same as the static type, all columns have the same
                        height. The "auto height" flag is 1. The difference to
                        the static type is only important for interactive CAD
                        applications.
Dynamic (manual height) same as the dynamic (auto height) type, but each column
                        can have an individual height.
No column               A regular MTEXT with "defined column height" attribute?
======================= ========================================================

=============== =============== =========== ===============
Column Type     Defined Height  Auto Height Column Heights
=============== =============== =========== ===============
Static          stored          False       not stored
Dynamic auto    stored          True        not stored
Dynamic manual  not stored      False       stored (last=0)
=============== =============== =========== ===============

Column Count
++++++++++++

For DXF versions < R2018 the column count is always given by the count of linked
MTEXT columns. Caution: the column count stored in the XDATA section by group
code 76 may not match the count of linked MTEXT entities and AutoCAD is OK with
that!
In DXF R2018+ this property is not available, because there are
no linked MTEXT entities anymore.

R2018+: For the column types "static" and "dynamic manual" the correct column
count is stored as group code 72. For the column type "dynamic auto" the stored
*column count is 0*. It is possible to calculate the column count
from the total width and the column width if the total width is correct like in
AutoCAD and BricsCAD.

Static Columns R2000
++++++++++++++++++++

Example for a **static** column specification:

    - Column Type: Static
    - Number of Columns: 3
    - Height: 150.0, manual entered value and all columns have the same height
    - Width: 50.0
    - Gutter Width: 12.5

.. image:: gfx/mtext_cols_static.png
    :align: center
    :width: 800px

The column height is stored as the "defined column height" in XDATA (46) or the
embedded object (41).

DXF R2000 example with a static column specification stored in XDATA:

.. code-block:: Text

    0
    MTEXT
    5           <<< entity handle
    9D
    102
    {ACAD_XDICTIONARY
    360
    9F
    102
    }
    330         <<< block record handle of owner layout
    1F
    100
    AcDbEntity
    8           <<< layer
    0
    100         <<< begin of MTEXT specific data
    AcDbMText
    10          <<< (10, 20, 30) insert location in WCS
    285.917876152751
    20
    276.101821192053
    30
    0.0
    40          <<< character height in drawing units
    2.5
    41          <<< reference column width, if not in column mode
    62.694...   <<< in column mode: the real column is defined in XDATA (48)
    71          <<< attachment point
    1
    72          <<< text flow direction
    1
    3           <<< begin of text
    Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam ...
    3
    kimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit ...
    3
    ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ...
    3
    At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd ...
    3
    ore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio ...
    1           <<< last text line and end of text
    euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.
    73          <<< line spacing style
    1
    44          <<< line spacing factor
    1.0
    1001
    AcadAnnotative
    1000
    AnnotativeData
    1002
    {
    1070
    1
    1070
    0
    1002
    }
    1001        <<< AppID "ACAD" contains the column specification
    ACAD
    1000
    ACAD_MTEXT_COLUMN_INFO_BEGIN
    1070
    75          <<< group code column type
    1070
    1           <<< column type: 0=no column; 1=static columns; 2=dynamic columns
    1070
    79          <<< group code column auto height
    1070
    0           <<< flag column auto height
    1070
    76          <<< group code column count
    1070
    3           <<< column count
    1070
    78          <<< group code column flow reversed
    1070
    0           <<< flag column flow reversed
    1070
    48          <<< group code column width
    1040
    50.0        <<< column width in column mode
    1070
    49          <<< group code column gutter
    1040
    12.5        <<< column gutter width
    1000
    ACAD_MTEXT_COLUMN_INFO_END
    1000        <<< linked MTEXT entities specification
    ACAD_MTEXT_COLUMNS_BEGIN
    1070
    47          <<< group code for column count, incl. the 1st column - this entity
    1070
    3           <<< column count
    1005
    1B4         <<< handle to 2nd column as MTEXT entity
    1005
    1B5         <<< handle to 3rd column as MTEXT entity
    1000
    ACAD_MTEXT_COLUMNS_END
    1000
    ACAD_MTEXT_DEFINED_HEIGHT_BEGIN
    1070
    46          <<< group code for defined column height
    1040
    150.0       <<< defined column height
    1000
    ACAD_MTEXT_DEFINED_HEIGHT_END

The linked column MTEXT ``#1B4`` in a compressed representation:

.. code-block:: Text

    0 <ctrl> MTEXT
    ... <snip>
    100 <ctrl> AcDbMText
    10 <point> (348.417876152751, 276.101821192053, 0.0)
    40 <float> 2.5
    41 <float> 175.0        <<< invalid reference column width
    ... <snip>
    1001 <ctrl> ACAD
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_BEGIN
    1070 <int> 46           <<< defined column height
    1040 <float> 150.0
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_END

The linked MTEXT has no column specification except the "defined column height"
in the XDATA.
The reference column :attr:`width` is not the real value of 50.0, see XDATA group
code 48 in the main MTEXT ``#9D``, instead the total width of 175.0 is stored
at group code 41. This is problem if a renderer try to render this MTEXT as a
standalone entity. The renderer has to fit the content into the column width
by itself and without the correct column width, this will produce an incorrect
result.

There exist no back link to the main MTEXT  ``#9D``. The linked MTEXT entities
appear after the main MTEXT in the layout space, but there can be other entities
located between these linked MTEXT entities.

The linked column MTEXT ``#1B5``:

.. code-block:: Text

    0 <ctrl> MTEXT
    5 <hex> #1B5
    ... <snip>
    100 <ctrl> AcDbMText
    10 <point> (410.917876152751, 276.101821192053, 0.0)
    40 <float> 2.5
    41 <float> 175.0        <<< invalid reference column width
    ... <snip>
    1001 <ctrl> ACAD
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_BEGIN
    1070 <int> 46           <<< defined column height
    1040 <float> 150.0
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_END

Static Columns R2018
++++++++++++++++++++

The MTEXT entity in DXF R2018 contains all column information in a single
entity. The text content of all three columns are stored in a continuous text
string, the separation into columns has to be done by the renderer. The manual
column break ``\N`` is **not** used to indicate automatic column breaks.
The MTEXT renderer has to replicate the AutoCAD/BricsCAD rendering as exact as
possible to achieve the same results, which is very hard without rendering
guidelines or specifications.

The example from above in DXF R2018 with a static column specification stored
in an embedded object:

.. code-block:: Text

    0
    MTEXT
    5           <<< entity handle
    9D
    102
    {ACAD_XDICTIONARY
    360
    9F
    102
    }
    330         <<< block record handle of owner layout
    1F
    100
    AcDbEntity
    8           <<< layer
    0
    100
    AcDbMText
    10          <<< (10, 20, 30) insert location in WCS
    285.917876152751
    20
    276.101821192053
    30
    0.0
    40          <<< character height in drawing units
    2.5
    41          <<< reference column width, if not in column mode
    62.694536423841
    46          <<< defined column height
    150.0
    71          <<< attachment point
    1
    72          <<< text flow direction
    1
    3           <<< text content of all three columns
    Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam n...
    3
    imata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit...
    3
    a rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lor...
    3
    vero eos et accusam et justo duo dolores et ea rebum. Stet clita ka...
    3
    eu feugiat nulla facilisis at vero eros et accumsan et iusto odio s...
    3
    od tincidunt ut laoreet dolore magna aliquam erat volutpat.   \P\PU...
    3
    e velit esse molestie consequat, vel illum dolore eu feugiat nulla ...
    3
    obis eleifend option congue nihil imperdiet doming id quod mazim pl...
    3
    m ad minim veniam, quis nostrud exerci tation ullamcorper suscipit ...
    3
    lisis.   \P\PAt vero eos et accusam et justo duo dolores et ea rebu...
    3
    t labore et dolore magna aliquyam erat, sed diam voluptua. At vero ...
    3
    litr, At accusam aliquyam diam diam dolore dolores duo eirmod eos e...
    1
    ipsum dolor sit amet, consetetur
    73          <<< line spacing style
    1
    44          <<< line spacing factor
    1.0
    101         <<< column specification as embedded object
    Embedded Object
    70          <<< ???
    1
    10          <<< (10, 20, 30) text direction vector (local x-axis)
    1.0
    20
    0.0
    30
    0.0
    11          <<< (11, 21, 31) repeated insert location of AcDbMText
    285.917876152751
    21
    276.101821192053
    31
    0.0
    40          <<< repeated reference column width
    62.694536423841
    41          <<< repeated defined column height
    150.0
    42          <<< extents (total) width
    175.0
    43          <<< extents (total) height, max. height if different column heights
    150.0
    71          <<< column type: 0=no column; 1=static columns; 2=dynamic columns
    1
    72          <<< column height count
    3
    44          <<< column width
    50.0
    45          <<< column gutter width
    12.5
    73          <<< flag column auto height
    0
    74          <<< flag reversed column flow
    0
    1001
    AcadAnnotative
    1000
    AnnotativeData
    1002
    {
    1070
    1
    1070
    0
    1002
    }

Dynamic (auto height) Columns R2000
+++++++++++++++++++++++++++++++++++

Example for a **dynamic** column specification:

- Column Type: Dynamic
- Number of Columns: 3
- Height: 158.189... adjusted by widget and all columns have the same height
- Width: 50.0
- Gutter Width: 12.5

.. code-block:: Text

    0 <ctrl> MTEXT
    5 <hex> #A2                 <<< entity handle
    ... <snip>
    330 <hex> #1F               <<< block record handle of owner layout
    100 <ctrl> AcDbEntity
    8 <str> 0                   <<< layer
    100 <ctrl> AcDbMText
    10 <point> (-133.714579865783, 276.101821192053, 0.0)   <<< insert location in WCS
    40 <float> 2.5              <<< character height in drawing units
    41 <float> 62.694536423841  <<< reference column width, if not in column mode
    71 <int> 1                  <<< attachment point
    72 <int> 1                  <<< flag text flow direction
    3 <str> Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed dia...
    ... <snip>
    73 <int> 1                  <<< line spacing style
    44 <float> 1.0              <<< line spacing factor
    1001 <ctrl> AcadAnnotative
    ... <snip>
    1001 <ctrl> ACAD
    1000 <str> ACAD_MTEXT_COLUMN_INFO_BEGIN
    1070 <int> 75               <<< column type: 2=dynamic columns
    1070 <int> 2
    1070 <int> 79               <<< flag column auto height
    1070 <int> 1
    1070 <int> 76               <<< column count
    1070 <int> 3
    1070 <int> 78               <<< flag column flow reversed
    1070 <int> 0
    1070 <int> 48               <<< column width in column mode
    1040 <float> 50.0
    1070 <int> 49               <<< column gutter width
    1040 <float> 12.5
    1000 <str> ACAD_MTEXT_COLUMN_INFO_END
    1000 <str> ACAD_MTEXT_COLUMNS_BEGIN
    1070 <int> 47               <<< column count
    1070 <int> 3
    1005 <hex> #1B6             <<< handle to 2. column as MTEXT entity
    1005 <hex> #1B7             <<< handle to 3. column as MTEXT entity
    1000 <str> ACAD_MTEXT_COLUMNS_END
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_BEGIN
    1070 <int> 46               <<< defined column height
    1040 <float> 158.189308131867
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_END

The linked column MTEXT ``#1B6``:

.. code-block:: Text

    0 <ctrl> MTEXT
    ... <snip>
    100 <ctrl> AcDbMText
    10 <point> (-71.214579865783, 276.101821192053, 0.0)
    40 <float> 2.5
    41 <float> 175.0    <<< invalid column width
    ... <snip>
    1001 <ctrl> ACAD
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_BEGIN
    1070 <int> 46       <<< defined column height
    1040 <float> 158.189308131867
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_END

The linked column MTEXT ``#1B7``:

.. code-block:: Text

    0 <ctrl> MTEXT
    ... <snip>
    100 <ctrl> AcDbMText
    10 <point> (-8.714579865783, 276.101821192053, 0.0)
    40 <float> 2.5
    41 <float> 175.0    <<< invalid column width
    ... <snip>
    1001 <ctrl> ACAD
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_BEGIN
    1070 <int> 46       <<< defined column height
    1040 <float> 158.189308131867
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_END

Dynamic (auto height) Columns R2018
+++++++++++++++++++++++++++++++++++

.. code-block:: Text

    0 <ctrl> MTEXT
    5 <hex> #A2                     <<< entity handle
    102 <ctrl> {ACAD_XDICTIONARY
    360 <hex> #A3
    102 <ctrl> }
    330 <hex> #1F                   <<< block record handle of owner layout
    100 <ctrl> AcDbEntity
    8 <str> 0                       <<< layer
    100 <ctrl> AcDbMText
    10 <point> (-133.714579865783, 276.101821192053, 0.0)   <<< insert location in WCS
    40 <float> 2.5                  <<< character height in drawing units
    41 <float> 62.694536423841      <<< reference column width, if not in column mode
    46 <float> 158.189308131867     <<< defined column height
    71 <int> 1                      <<< attachment point
    72 <int> 1                      <<< text flow direction
    3 <str> Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam...
    ... <snip> text content of all three columns
    73 <int> 1                      <<< line spacing style
    44 <float> 1.0                  <<< line spacing factor
    101 <ctrl> Embedded Object
    70 <int> 1, b00000001           <<< ???
    10 <point> (1.0, 0.0, 0.0)      <<< text direction vector (local x-axis)
    11 <point> (-133.714579865783, 276.101821192053, 0.0)   <<< repeated insert location
    40 <float> 62.694536423841      <<< repeated reference column width
    41 <float> 158.189308131867     <<< repeated defined column height
    42 <float> 175.0                <<< extents (total) width
    43 <float> 158.189308131867     <<< extents (total) height, max. height if different column heights
    71 <int> 2                      <<< column type: 2=dynamic columns
    72 <int> 0                      <<< column height count
    44 <float> 50.0                 <<< column width
    45 <float> 12.5                 <<< column gutter width
    73 <int> 1                      <<< flag column auto height
    74 <int> 0                      <<< flag reversed column flow
    1001 <ctrl> AcadAnnotative
    1000 <str> AnnotativeData
    1002 <str> {
    1070 <int> 1
    1070 <int> 0
    1002 <str> }

Dynamic (manual height) Columns R2000
+++++++++++++++++++++++++++++++++++++

Example for a **dynamic** column specification with manual height definition
for three columns with different column heights. None of the (linked) MTEXT
entities does contain XDATA for the defined column height.

.. hint::

    If "content type" is 2 and flag "column auto height" is 0,
    no defined height in XDATA.

- Column Type: Dynamic
- Number of Columns: 3
- Height: 164.802450331126, max. column height
- Width: 50.0
- Gutter Width: 12.5

.. image:: gfx/mtext_cols_dynamic_manual.png
    :align: center
    :width: 800px

.. code-block:: Text

    0 <ctrl> MTEXT
    5 <hex> #9C                     <<< entity handle
    330 <hex> #1F                   <<< block record handle of owner layout
    100 <ctrl> AcDbEntity
    8 <str> 0                       <<< layer
    100 <ctrl> AcDbMText
    10 <point> (69.806121185863, 276.101821192053, 0.0)     <<< insert location in WCS
    40 <float> 2.5                  <<< character height in drawing units
    41 <float> 62.694536423841      <<< reference column width, if not in column mode
    71 <int> 1                      <<< attachment point
    72 <int> 1                      <<< flag text flow direction
    3 <str> Lorem ipsum dolor sit amet, consetetur sadipscing elitr, ...
    ... <snip>
    73 <int> 1                      <<< line spacing style
    44 <float> 1.0                  <<< line spacing factor
    1001 <ctrl> ACAD
    1000 <str> ACAD_MTEXT_COLUMN_INFO_BEGIN
    1070 <int> 75                   <<< column type: 2=dynamic columns
    1070 <int> 2
    1070 <int> 79                   <<< flag column auto height
    1070 <int> 0
    1070 <int> 76                   <<< column count
    1070 <int> 3
    1070 <int> 78                   <<< flag column flow reversed
    1070 <int> 0
    1070 <int> 48                   <<< column width in column mode
    1040 <float> 50.0
    1070 <int> 49                   <<< column gutter width
    1040 <float> 12.5
    1070 <int> 50                   <<< column height count
    1070 <int> 3
    1040 <float> 164.802450331126   <<< column height 1. column
    1040 <float> 154.311699779249   <<< column height 2. column
    1040 <float> 0.0                <<< column height 3. column, takes the rest?
    1000 <str> ACAD_MTEXT_COLUMN_INFO_END
    1000 <str> ACAD_MTEXT_COLUMNS_BEGIN
    1070 <int> 47                   <<< column count
    1070 <int> 3
    1005 <hex> #1B2                 <<< handle to 2. column as MTEXT entity
    1005 <hex> #1B3                 <<< handle to 3. column as MTEXT entity
    1000 <str> ACAD_MTEXT_COLUMNS_END

The linked column MTEXT ``#1B2``:

.. code-block:: Text

    0 <ctrl> MTEXT
    ... <snip>
    100 <ctrl> AcDbMText
    10 <point> (132.306121185863, 276.101821192053, 0.0)
    40 <float> 2.5
    41 <float> 175.0            <<< invalid reference column width
    ... <snip>
    73 <int> 1
    44 <float> 1.0

The linked column MTEXT ``#1B3``:

.. code-block:: Text

    0 <ctrl> MTEXT
    ... <snip>
    100 <ctrl> AcDbMText
    10 <point> (194.806121185863, 276.101821192053, 0.0)
    40 <float> 2.5
    41 <float> 175.0            <<< invalid reference column width
    ... <snip>
    73 <int> 1
    44 <float> 1.0


Dynamic (manual height) Columns R2018
+++++++++++++++++++++++++++++++++++++

.. hint::

    If "content type" is 2 and flag "column auto height" is 0,
    the "defined column height" is 0.0.

.. code-block:: Text

    0 <ctrl> MTEXT
    5 <hex> #9C                     <<< entity handle
    330 <hex> #1F
    100 <ctrl> AcDbEntity
    8 <str> 0                       <<< block record handle of owner layout
    100 <ctrl> AcDbMText
    10 <point> (69.806121185863, 276.101821192053, 0.0)     <<< insert location in WCS
    40 <float> 2.5                  <<< character height in drawing units
    41 <float> 62.694536423841      <<< reference column width, if not in column mode
    46 <float> 0.0                  <<< defined column height
    71 <int> 1                      <<< attachment point
    72 <int> 1                      <<< text flow direction
    3 <str> Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam...
    ... <snip> text content of all three columns
    73 <int> 1                      <<< line spacing style
    44 <float> 1.0                  <<< line spacing factor
    101 <ctrl> Embedded Object
    70 <int> 1, b00000001           <<< ???
    10 <point> (1.0, 0.0, 0.0)      <<< text direction vector (local x-axis)
    11 <point> (69.806121185863, 276.101821192053, 0.0)     <<< repeated insert location
    40 <float> 62.694536423841      <<< repeated reference column width
    41 <float> 0.0                  <<< repeated defined column height
    42 <float> 175.0                <<< extents (total) width
    43 <float> 164.802450331126     <<< extents (total) height, max. height if different column heights
    71 <int> 2                      <<< column type: 2=dynamic columns
    72 <int> 3                      <<< column height count
    44 <float> 50.0                 <<< column width
    45 <float> 12.5                 <<< column gutter width
    73 <int> 0                      <<< flag column auto height
    74 <int> 0                      <<< flag reversed column flow
    46 <float> 164.802450331126     <<< column height 1. column
    46 <float> 154.311699779249     <<< column height 2. column
    46 <float> 0.0                  <<< column height 3. column, takes the rest?

No Columns R2000
++++++++++++++++

I have no idea why this column type exist, but at least provides a reliable
value for the MTEXT height by the "defined column height" attribute.
The column type is not stored in the MTEXT entity and is therefore not
detectable!

- Column Type: No columns
- Number of Columns: 1
- Height: 158.189308131867, defined column height
- Width: 175.0, reference column width

.. code-block:: Text

    0 <ctrl> MTEXT
    ... <snip>
    100 <ctrl> AcDbMText
    10 <point> (-344.497343455795, 276.101821192053, 0.0)   <<< insert location in WCS
    40 <float> 2.5          <<< character height in drawing units
    41 <float> 175.0        <<< reference column width
    71 <int> 1              <<< attachment point
    72 <int> 1              <<< flag text flow direction
    3 <str> Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam...
    ... <snip> text content of all three columns
    73 <int> 1              <<< line spacing style
    44 <float> 1.0          <<< line spacing factor
    ... <snip>
    1001 <ctrl> ACAD
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_BEGIN
    1070 <int> 46           <<< defined column height
    1040 <float> 158.189308131867
    1000 <str> ACAD_MTEXT_DEFINED_HEIGHT_END

No Columns R2018
++++++++++++++++

Does not contain an embedded object.

.. code-block:: Text

    0 <ctrl> MTEXT
    ... <snip>
    100 <ctrl> AcDbMText
    10 <point> (-334.691900433414, 276.101821192053, 0.0)   <<< insert location in WCS
    40 <float> 2.5                  <<< character height in drawing units
    41 <float> 175.0                <<< reference column width
    46 <float> 158.189308131867     <<< defined column height
    71 <int> 1                      <<< attachment point
    72 <int> 1                      <<< flag text flow direction
    3 <str> Lorem ipsum dolor sit amet, consetetur sadipscing elitr, ...
    ... <snip>
    73 <int> 1                      <<< line spacing style
    44 <float> 1.0                  <<< line spacing factor
    1001 <ctrl> AcadAnnotative
    ... <snip>

.. _MTEXT: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-5E5DB93B-F8D3-4433-ADF7-E92E250D2BAB

--- End of file: dxfinternals/entities/mtext.rst ---



--- Start of file: dxfinternals/fileencoding.rst ---

.. _DXF File Encoding:

DXF File Encoding
=================

DXF R2004 and prior
-------------------

Drawing files of DXF R2004 (AC1018) and prior are saved as ASCII files with the encoding set by the header
variable $DWGCODEPAGE, which is ``ANSI_1252`` by default if $DWGCODEPAGE is not set.

Characters used in the drawing which do not exist in the chosen ASCII encoding are encoded as unicode characters with
the schema ``\U+nnnn``. see `Unicode table`_

Known $DWGCODEPAGE encodings
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

========= ====== ================
DXF       Python Name
========= ====== ================
ANSI_874  cp874  Thai
ANSI_932  cp932  Japanese
ANSI_936  gbk    UnifiedChinese
ANSI_949  cp949  Korean
ANSI_950  cp950  TradChinese
ANSI_1250 cp1250 CentralEurope
ANSI_1251 cp1251 Cyrillic
ANSI_1252 cp1252 WesternEurope
ANSI_1253 cp1253 Greek
ANSI_1254 cp1254 Turkish
ANSI_1255 cp1255 Hebrew
ANSI_1256 cp1256 Arabic
ANSI_1257 cp1257 Baltic
ANSI_1258 cp1258 Vietnam
========= ====== ================

DXF R2007 and later
-------------------

Starting with DXF R2007 (AC1021) the drawing file is UTF-8 encoded, the header variable
$DWGCODEPAGE is still in use, but I don't know, if the setting still has any meaning.

Encoding characters in the unicode schema ``\U+nnnn`` is still functional.

.. seealso::

    :ref:`String Value Encoding`

.. _Unicode Table: https://symbl.cc/en/


--- End of file: dxfinternals/fileencoding.rst ---



--- Start of file: dxfinternals/filestructure.rst ---

.. _File Structure:

DXF File Structure
------------------

A DXF File is simply an ASCII text file with a file type of .dxf and special formatted text. The basic file structure
are DXF tags, a DXF tag consist of a DXF group code as an integer value on its own line and a the DXF value on the
following line. In the ezdxf documentation DXF tags will be written as :code:`(group code, value)`. There exist
a binary DXF format, but it seems that it is not often used and for reducing file size, zipping is much more efficient.
`ezdxf` does support reading binary encoded DXF files.

.. seealso::

    For more information about DXF tags see: :ref:`dxf_tags_internals`


A usual DXF file is organized in sections, starting with the DXF tag
(0, 'SECTION') and ending with the DXF tag (0, 'ENDSEC'). The (0, 'EOF')
tag signals the end of file.


1. **HEADER:** General information about the drawing is found in this section of the DXF file.
   Each parameter has a variable name starting with '$' and an associated value. Has to be the first section.

2. **CLASSES:** Holds the information for application defined classes. (DXF R13 and later)

3. **TABLES:**: Contains several tables for style and property definitions.

   * Linetype table (LTYPE)
   * Layer table (LAYER)
   * Text Style table (STYLE)
   * View table (VIEW): (IMHO) layout of the CAD working space, only interesting for interactive CAD applications
   * Viewport configuration table (VPORT): The VPORT table is unique in that it may contain several entries
     with the same name (indicating a multiple-viewport configuration). The entries corresponding to the
     active viewport configuration all have the name \*ACTIVE. The first such entry describes the current
     viewport.

   * Dimension Style table (DIMSTYLE)
   * User Coordinate System table (UCS) (IMHO) only interesting for interactive CAD applications
   * Application Identification table (APPID): Table of names for all applications registered with a drawing.
   * Block Record table (BLOCK_RECORD) (DXF R13 and Later)

4. **BLOCKS:** Contains all block definitions. The block name \*Model_Space or \*MODEL_SPACE is reserved for the
   drawing modelspace and the block name \*Paper_Space or \*PAPER_SPACE is reserved for the *active* paperspace layout.
   Both block definitions are empty, the content of the modelspace and the *active* paperspace is stored in the
   ENTITIES section. The entities of other layouts are stored in special block definitions called \*Paper_Spacennn,
   nnn is an arbitrary but unique number.

5. **ENTITIES:** Contains all graphical entities of the modelspace and the *active* paperspace layout. Entities of
   other layouts are stored in the BLOCKS sections.

6. **OBJECTS:** Contains all non-graphical objects of the drawing (DXF R13 and later)

7. **THUMBNAILIMAGE:** Contains a preview image of the DXF file, it is optional and can usually be ignored.
   (DXF R13 and later)

8. **ACDSDATA:** (DXF R2013 and later) No information in the DXF reference about this section

9. **END OF FILE**

For further information read the original `DXF Reference`_.

Structure of a usual DXF R12 file:

.. code-block:: none

    0           <<< Begin HEADER section, has to be the first section
    SECTION
    2
    HEADER
                <<< Header variable items go here
    0           <<< End HEADER section
    ENDSEC
    0           <<< Begin TABLES section
    SECTION
    2
    TABLES
    0
    TABLE
    2
    VPORT
    70          <<< viewport table maximum item count
                <<< viewport table items go here
    0
    ENDTAB
    0
    TABLE
    2
    APPID, DIMSTYLE, LTYPE, LAYER, STYLE, UCS, VIEW, or VPORT
    70          <<< Table maximum item count, a not reliable value and ignored by AutoCAD
                <<< Table items go here
    0
    ENDTAB
    0           <<< End TABLES section
    ENDSEC
    0           <<< Begin BLOCKS section
    SECTION
    2
    BLOCKS
                <<< Block definition entities go here
    0           <<< End BLOCKS section
    ENDSEC
    0           <<< Begin ENTITIES section
    SECTION
    2
    ENTITIES
                <<< Drawing entities go here
    0           <<< End ENTITIES section
    ENDSEC
    0           <<< End of file marker (required)
    EOF

Minimal DXF Content
-------------------

DXF R12
=======

Contrary to the previous chapter, the DXF R12 format (AC1009) and prior requires just the ENTITIES section:

.. code-block:: none

    0
    SECTION
    2
    ENTITIES
    0
    ENDSEC
    0
    EOF

DXF R13/R14 and later
=====================

DXF version R13/14 and later needs much more DXF content than DXF R12.

Required sections: HEADER, CLASSES, TABLES, ENTITIES, OBJECTS

The HEADER section requires two entries:

- $ACADVER
- $HANDSEED

The CLASSES section can be empty, but some DXF entities requires class definitions to work in AutoCAD.

The TABLES section requires following tables:

- VPORT entry \*ACTIVE is not required! Empty table is ok for AutoCAD.
- LTYPE with at least the following line types defined:

  - BYBLOCK
  - BYLAYER
  - CONTINUOUS

- LAYER with at least an entry for layer '0'
- STYLE with at least an entry for style STANDARD
- VIEW can be empty
- UCS can be empty
- APPID with at least an entry for ACAD
- DIMSTYLE with at least an entry for style STANDARD
- BLOCK_RECORDS with two entries:

  - \*MODEL_SPACE
  - \*PAPER_SPACE

The BLOCKS section requires two BLOCKS:

- \*MODEL_SPACE
- \*PAPER_SPACE

The ENTITIES section can be empty.

The OBJECTS section requires following entities:

- DICTIONARY - the root dict
  - one entry named ACAD_GROUP

- DICTIONARY ACAD_GROUP can be empty

Minimal DXF to download: https://github.com/mozman/ezdxf/tree/master/examples_dxf

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-235B22E0-A567-4CF6-92D3-38A2306D73F3


--- End of file: dxfinternals/filestructure.rst ---



--- Start of file: dxfinternals/handles.rst ---

.. _Handles:

Handles
=======

A handle is an arbitrary but in your DXF file unique hex value as string like '10FF'.
It is common to to use uppercase letters for hex numbers. Handle can have up to 16
hexadecimal digits (8 bytes).

For DXF R10 until R12 the usage of handles was optional. The header variable $HANDLING
set to 1 indicate the usage of handles, else $HANDLING is 0 or missing.

For DXF R13 and later the usage of handles is mandatory and the header variable $HANDLING
was removed.

The $HANDSEED variable in the header section should be greater than the biggest handle
used in the DXF file, so a CAD application can assign handle values starting with the
$HANDSEED value. But as always, don't rely on the header variable it could be wrong,
AutoCAD ignores this value.

Handle Definition
-----------------

Entity handle definition is always the :code:`(5, ...)`, except for entities of the
DIMSTYLE table :code:`(105, ...)`, because the DIMSTYLE entity has also a group
code 5 tag for DIMBLK.

Handle Pointer
--------------

A pointer is a reference to a DXF object in the same DXF file. There are four types of
pointers:

- Soft-pointer handle
- Hard-pointer handle
- Soft-owner handle
- Hard-owner handle

Also, a group code range for "arbitrary" handles is defined to allow convenient storage
of handle values that are unchanged at any operation (AutoCAD).

Pointer and Ownership
---------------------

A pointer is a reference that indicates usage, but not possession or responsibility, for
another object. A pointer reference means that the object uses the other object in some
way, and shares access to it. An ownership reference means that an owner object is
responsible for the objects for which it has an owner handle.  An object can have any
number of pointer references associated with it, but it can have only one owner.

Hard and Soft References
------------------------

Hard references, whether they are pointer or owner, protect an object from being purged.
Soft references do not.

In AutoCAD, block definitions and complex entities are hard owners of their elements.
A symbol table and dictionaries are soft owners of their elements. Polyline entities are
hard owners of their vertex and seqend entities. Insert entities are hard owners of
their attrib and seqend entities.

When establishing a reference to another object, it is recommended that you think about
whether the reference should protect an object from the PURGE command.

A hard- and soft pointers will be translated during INSERT and XREF operations.

Arbitrary Handles
-----------------

Arbitrary handles are distinct in that they are not translated to session-persistent
identifiers internally, or to entity names in AutoLISP, and so on. They are stored as
handles. When handle values are translated in drawing-merge operations, arbitrary handles
are ignored.

In all environments, arbitrary handles can be exchanged for entity names of the current
drawing by means of the handent functions. A common usage of arbitrary handles is to
refer to objects in external DXF and DWG files.

.. _About 1005 Group Codes:

About 1005 Group Codes
----------------------

:code:`(1005, ...)` xdata have the same behavior and semantics as soft pointers, which
means that they are translated whenever the host object is merged into a different
drawing. However, 1005 items are not translated to session-persistent identifiers or
internal entity names in AutoLISP and ObjectARX. They are stored as handles.

When a drawing with handles and extended data handles is imported into another
drawing using INSERT, INSERT *, XREF Bind, XBIND, or partial OPEN, the extended
data handles are **translated** in the same manner as their corresponding entity
handles, thus maintaining their binding. This is also done in the EXPLODE
block operation or for any other AutoCAD operation. When AUDIT detects an
extended data handle that doesn't match the handle of an entity in the drawing
file, it is considered an error. If AUDIT is fixing entities, it sets the
handle to "0"


--- End of file: dxfinternals/handles.rst ---



--- Start of file: dxfinternals/index.rst ---

DXF Internals
=============

- `DXF Reference`_ provided by Autodesk.
- `DXF Developer Documentation`_ provided by Autodesk.

Basic DXF Structures
--------------------

.. toctree::
    :maxdepth: 1

    fileencoding
    dxftags
    handles
    filestructure
    datamodel

DXF Structures
--------------

.. toctree::
    :maxdepth: 1

    sections/index
    tables/index
    entities/index
    objects/index

Management Structures
---------------------

.. toctree::
    :maxdepth: 1

    block_management
    layout_management

Miscellaneous
-------------

.. toctree::
    :maxdepth: 1

    rendering_of_dxf_content

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-235B22E0-A567-4CF6-92D3-38A2306D73F3

.. _DXF Developer Documentation: http://help.autodesk.com/view/OARX/2018/ENU/


--- End of file: dxfinternals/index.rst ---



--- Start of file: dxfinternals/layout_management.rst ---

.. _Layout Management Structures:

Layout Management Structures
============================

Layouts are separated entity spaces, there are three different Layout types:

    1. modelspace contains the 'real' world representation of the drawing
       subjects in real world units.
    2. paperspace layouts are used to create different drawing sheets of the
       modelspace subjects for printing or PDF export
    3. Blocks are reusable sets of graphical entities, inserted/referenced
       by the INSERT entity.

All layouts have at least a BLOCK definition in the BLOCKS section and since
DXF R13 exist the BLOCK_RECORD table with an entry for every BLOCK in the
BLOCKS section.

.. seealso::

    Information about :ref:`Block Management Structures`


The name of the modelspace BLOCK is "\*Model_Space" (DXF R12: "$MODEL_SPACE")
and the name of the `active` paperspace BLOCK is "\*Paper_Space"
(DXF R12: "$PAPER_SPACE"), the entities of these two layouts are
stored in the ENTITIES section, DXF R12 supports just one paperspace layout.

DXF R13+ supports multiple paperspace layouts, the `active` layout is still
called "\*Paper_Space", the additional `inactive` paperspace layouts are named
by the scheme "\*Paper_Spacennnn", where the first inactive paper space is
called "\*Paper_Space0", the second "\*Paper_Space1" and so on.
A none consecutive numbering is tolerated by AutoCAD. The content of the
inactive paperspace layouts are stored as BLOCK content in the BLOCKS section.
These names are just the DXF internal layout names, each layout has an
additional layout name which is displayed to the user by the CAD application.

A BLOCK definition and a BLOCK_RECORD is not enough for a proper layout setup,
an LAYOUT entity in the OBJECTS section is also required. All LAYOUT entities
are managed by a DICTIONARY entity, which is referenced as "ACAD_LAYOUT"
entity in the root DICTIONARY of the DXF file.

.. note::

    All floating point values are rounded to 2 decimal places for better
    readability.


LAYOUT Entity
-------------

Since DXF R2000 modelspace and paperspace layouts require the DXF
`LAYOUT <http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-433D25BF-655D-4697-834E-C666EDFD956D>`_ entity.

.. code-block:: none

    0
    LAYOUT
    5       <<< handle
    59
    102     <<< extension dictionary (ignore)
    {ACAD_XDICTIONARY
    360
    1C3
    102
    }
    102     <<< reactor (required?)
    {ACAD_REACTORS
    330
    1A      <<< pointer to "ACAD_LAYOUT" DICTIONARY (layout management table)
    102
    }
    330     <<< owner handle
    1A      <<< pointer to "ACAD_LAYOUT" DICTIONARY (same as reactor pointer)
    100     <<< PLOTSETTINGS
    AcDbPlotSettings
    1       <<< page setup name

    2       <<< name of system printer or plot configuration file
    none_device
    4       <<< paper size, part in braces should follow the schema
    ...     (width_x_height_unit) unit is 'Inches' or 'MM'
    ...     Letter\_(8.50_x_11.00_Inches)  the part in front of the braces is
    ...     ignored by AutoCAD
    6       <<< plot view name

    40      <<< size of unprintable margin on left side of paper in millimeters,
    ...     defines also the plot origin-x
    6.35
    41      <<< size of unprintable margin on bottom of paper in millimeters,
    ...     defines also the plot origin-y
    6.35
    42      <<< size of unprintable margin on right side of paper in millimeters
    6.35
    43      <<< size of unprintable margin on top of paper in millimeters
    6.35
    44      <<< plot paper size: physical paper width in millimeters
    215.90
    45      <<< plot paper size: physical paper height in millimeters
    279.40
    46      <<< X value of plot origin offset in millimeters, moves the plot origin-x
    0.0
    47      <<< Y value of plot origin offset in millimeters, moves the plot origin-y
    0.0
    48      <<< plot window area: X value of lower-left window corner
    0.0
    49      <<< plot window area: Y value of lower-left window corner
    0.0
    140     <<< plot window area: X value of upper-right window corner
    0.0
    141     <<< plot window area: Y value of upper-right window corner
    0.0
    142     <<< numerator of custom print scale: real world (paper) units, 1.0
    ...     for scale 1:50
    1.0
    143     <<< denominator of custom print scale: drawing units, 50.0
    ...     for scale 1:50
    1.0
    70      <<< plot layout flags, bit-coded (... too many options)
    688     <<< b1010110000 = UseStandardScale(16)/PlotPlotStyle(32)
    ...     PrintLineweights(128)/DrawViewportsFirst(512)
    72      <<< plot paper units (0/1/2 for inches/millimeters/pixels), are
    ...     pixels really supported?
    0
    73      <<< plot rotation (0/1/2/3 for 0deg/90deg counter-cw/upside-down/90deg cw)
    1       <<< 90deg clockwise
    74      <<< plot type 0-5 (... too many options)
    5       <<< 5 = layout information
    7       <<< current plot style name, e.g. 'acad.ctb' or 'acadlt.ctb'

    75      <<< standard scale type 0-31 (... too many options)
    16      <<< 16 = 1:1, also 16 if user scale type is used
    147     <<< unit conversion factor
    1.0     <<< for plot paper units in mm, else  0.03937... (1/25.4) for inches
    ...     as plot paper units
    76      <<< shade plot mode (0/1/2/3 for as displayed/wireframe/hidden/rendered)
    0       <<< as displayed
    77      <<< shade plot resolution level 1-5 (... too many options)
    2       <<< normal
    78      <<< shade plot custom DPI: 100-32767, Only applied when shade plot
    ...     resolution level is set to 5 (Custom)
    300
    148     <<< paper image origin: X value
    0.0
    149     <<< paper image origin: Y value
    0.0
    100     <<< LAYOUT settings
    AcDbLayout
    1       <<< layout name
    Layout1
    70      <<< flags bit-coded
    1       <<< 1 = Indicates the PSLTSCALE value for this layout when this
    ...     layout is current
    71      <<< Tab order ("Model" tab always appears as the first tab
    ...     regardless of its tab order)
    1
    10      <<< minimum limits for this layout (defined by LIMMIN while this
    ...     layout is current)
    -0.25   <<<     x value, distance of the left paper margin from the plot
    ...     origin-x, in plot paper units and by scale (e.g. x50 for 1:50)
    20      <<<     group code for y value
    -0.25   <<<     y value, distance of the bottom paper margin from the plot
    ...     origin-y, in plot paper units and by scale (e.g. x50 for 1:50)
    11      <<< maximum limits for this layout (defined by LIMMAX while this
    ...     layout is current)
    10.75   <<<     x value, distance of the right paper margin from the plot
    ...     origin-x, in plot paper units and by scale (e.g. x50 for 1:50)
    21      <<<     group code for y value
    8.25    <<<     y value, distance of the top paper margin from the plot
    ...     origin-y, in plot paper units and by scale (e.g. x50 for 1:50)
    12      <<< insertion base point for this layout (defined by INSBASE while
    ...     this layout is current)
    0.0     <<<     x value
    22      <<<     group code for y value
    0.0     <<<     y value
    32      <<<     group code for z value
    0.0     <<<     z value
    14      <<< minimum extents for this layout (defined by EXTMIN while this
    ...     layout is current), AutoCAD default is (1e20, 1e20, 1e20)
    1.05    <<<     x value
    24      <<<     group code for y value
    0.80    <<<     y value
    34      <<<     group code for z value
    0.0     <<<     z value
    15      <<< maximum extents for this layout (defined by EXTMAX while this
    ...     layout is current), AutoCAD default is (-1e20, -1e20, -1e20)
    9.45    <<<     x value
    25      <<<     group code for y value
    7.20    <<<     y value
    35      <<<     group code for z value
    0.0     <<<     z value
    146     <<< elevation ???
    0.0
    13      <<< UCS origin (3D Point)
    0.0     <<<     x value
    23      <<<     group code for y value
    0.0     <<<     y value
    33      <<<     group code for z value
    0.0     <<<     z value
    16      <<< UCS X-axis (3D vector)
    1.0     <<<     x value
    26      <<<     group code for y value
    0.0     <<<     y value
    36      <<<     group code for z value
    0.0     <<<     z value
    17      <<< UCS Y-axis (3D vector)
    0.0     <<<     x value
    27      <<<     group code for y value
    1.0     <<<     y value
    37      <<<     group code for z value
    0.0     <<<     z value
    76      <<< orthographic type of UCS 0-6 (... too many options)
    0       <<< 0 = UCS is not orthographic ???
    330     <<< ID/handle of required block table record
    58
    331     <<< ID/handle to the viewport that was last active in this layout
    ...     when the layout was current
    1B9
    1001    <<< extended data (ignore)
    ...

And as it seems this is also not enough for a well defined LAYOUT, at least a
"main" VIEWPORT entity with ID=1 is required for paperspace layouts, located in
the entity space of the layout.

The modelspace layout requires (?) a VPORT entity in the VPORT table (group code
331 in the AcDbLayout subclass).

Main VIEWPORT Entity for LAYOUT
-------------------------------

The "main" viewport for layout "Layout1" shown above. This viewport is located
in the associated BLOCK definition called "\*Paper_Space0". Group code 330 in
subclass AcDbLayout points to the BLOCK_RECORD of "\*Paper_Space0".

Remember: the entities of the `active` paperspace layout are located in the
ENTITIES section, therefore "Layout1" is not the active paperspace layout.

The "main" VIEWPORT describes, how the application shows the paperspace layout
on the screen, and I guess only AutoCAD needs this values.

.. image:: gfx/main_viewport.jpg
    :align: center

.. code-block:: none

    0
    VIEWPORT
    5       <<< handle
    1B4
    102     <<< extension dictionary (ignore)
    {ACAD_XDICTIONARY
    360
    1B5
    102
    }
    330     <<< owner handle
    58      <<< points to BLOCK_RECORD (same as group code 330 in AcDbLayout of
    ...     "Layout1")
    100
    AcDbEntity
    67      <<< paperspace flag
    1       <<< 0 = modelspace; 1 = paperspace
    8       <<< layer,
    0
    100
    AcDbViewport
    10      <<< Center point (in WCS)
    5.25    <<<     x value
    20      <<<     group code for y value
    4.00    <<<     y value
    30      <<<     group code for z value
    0.0     <<<     z value
    40      <<< width in paperspace units
    23.55   <<< VIEW size in AutoCAD, depends on the workstation configuration
    41      <<< height in paperspace units
    9.00    <<< VIEW size in AutoCAD, depends on the workstation configuration
    68      <<< viewport status field -1/0/n
    2       <<< >0  On and active. The value indicates the order of stacking for
    ...     the viewports, where 1 is the active viewport, 2 is the next, and so forth
    69      <<< viewport ID
    1       <<< "main" viewport has always ID=1
    12      <<< view center point in Drawing Coordinate System (DCS), defines
    ...     the center point of the VIEW in relation to the LAYOUT origin
    5.25    <<<     x value
    22      <<<     group code for y value
    4.00    <<<     y value
    13      <<< snap base point in modelspace
    0.0     <<<     x value
    23      <<<     group code for y value
    0.0     <<<     y value
    14      <<< snap spacing in modelspace units
    0.5     <<<     x value
    24      <<<     group code for y value
    0.5     <<<     y value
    15      <<< grid spacing in modelspace units
    0.5     <<<     x value
    25      <<<     group code for y value
    0.5     <<<     y value
    16      <<< view direction vector from target (in WCS)
    0.0     <<<     x value
    26      <<<     group code for y value
    0.0     <<<     y value
    36      <<<     group code for z value
    1.0     <<<     z value
    17      <<< view target point
    0.0     <<<     x value
    27      <<<     group code for y value
    0.0     <<<     y value
    37      <<<     group code for z value
    0.0     <<<     z value
    42      <<<     perspective lens length, focal length?
    50.0    <<<     50mm
    43      <<<     front clip plane z value
    0.0     <<<     z value
    44      <<<     back clip plane z value
    0.0     <<<     z value
    45      <<<     view height (in modelspace units)
    9.00
    50      <<< snap angle
    0.0
    51      <<< view twist angle
    0.0
    72      <<< circle zoom percent
    1000
    90      <<< Viewport status bit-coded flags (... too many options)
    819232  <<< b11001000000000100000
    1       <<< plot style sheet name assigned to this viewport

    281     <<< render mode (... too many options)
    0       <<< 0 = 2D optimized (classic 2D)
    71      <<< UCS per viewport flag
    1       <<< 1 = This viewport stores its own UCS which will become the
    ...     current UCS whenever the viewport is activated
    74      <<< Display UCS icon at UCS origin flag
    0       <<< this field is currently being ignored and the icon always
    ...     represents the viewport UCS
    110     <<< UCS origin (3D point)
    0.0     <<<     x value
    120     <<<     group code for y value
    0.0     <<<     y value
    130     <<<     group code for z value
    0.0     <<<     z value
    111     <<< UCS X-axis (3D vector)
    1.0     <<<     x value
    121     <<<     group code for y value
    0.0     <<<     y value
    131     <<<     group code for z value
    0.0     <<<     z value
    112     <<< UCS Y-axis (3D vector)
    0.0     <<<     x value
    122     <<<     group code for y value
    1.0     <<<     y value
    132     <<<     group code for z value
    0.0     <<<     z value
    79      <<< Orthographic type of UCS (... too many options)
    0       <<< 0 = UCS is not orthographic
    146     <<< elevation
    0.0
    170     <<< shade plot mode (0/1/2/3 for as displayed/wireframe/hidden/rendered)
    0       <<< as displayed
    61      <<< frequency of major grid lines compared to minor grid lines
    5       <<< major grid subdivided by 5
    348     <<< visual style ID/handle (optional)
    9F
    292     <<< default lighting flag, on when no user lights are specified.
    1
    282     <<< Default lighting type (0/1 = one distant light/two distant lights)
    1       <<< one distant light
    141     <<< view brightness
    0.0
    142     <<< view contrast
    0.0
    63      <<< ambient light color (ACI), write only if not black color
    250
    421     <<< ambient light color (RGB), write only if not black color
    3355443


--- End of file: dxfinternals/layout_management.rst ---



--- Start of file: dxfinternals/objects/index.rst ---

DXF Objects
===========

.. toctree::
   :maxdepth: 1

TODO

--- End of file: dxfinternals/objects/index.rst ---



--- Start of file: dxfinternals/rendering_of_dxf_content.rst ---

.. _notes_on_rendering_dxf_content:

Notes on Rendering DXF Content
==============================

A collection of AutoCAD behaviors determined experimentally. There may be mistakes 
and misunderstandings of the inner workings of the algorithms. Not all edge cases 
may have been considered.

Colors
------

- Most entities are colored contextually, based on the layer or block that they
  reside in.
- Usually entity colors are stored as AutoCAD Color Indices (ACI) as an index
  into a lookup table. Different CAD applications may use different color 
  palettes making consistent coloring difficult.
- If a block insert is placed on layer 'A', and the block contains an entity on
  layer 'B' with BYLAYER color: the entity will be drawn with the color of layer 'B'.
- If a block insert is placed on layer 'A', and the block contains an entity on
  layer '0' with BYLAYER color: the entity will be drawn with the color of layer 'A', 
  it seems that layer '0' is the only special case for this.
- Ff an entity has BYBLOCK color set, and it exists outside a block: it will
  take on the layout default color which is white in the modelspace and black in 
  the paperspace.

Layers and Draw Order
---------------------

- Layer names are case-insensitive, the document layer table keys are stored in
  lowercase, and in original style in all other use cases (e.g. `entity.dxf.layer`).
- Layers do not play a role in entity draw order, only whether they appear at
  all based on the visibility of the layer.
- It appears that Insert entities have a single element in terms of draw order

    - Entities inside a block can overlap each other and so have a draw order
      inside the block, but two Insert entities cannot interleave the contents 
      of their blocks. One is completely drawn on top of the other.

- For entities inside a block, the visibility of the layer that the block is
  inserted does not affect the visibility of the entity *unless* the entity was 
  created on layer 0 in which case the reverse is true:
  
    - scenario: block created containing entity A (layer 0) and entity B 
      (layer 1). The block is inserted into layer 2
    - entity B visible if and only if layer 1 is visible
    - entity A visible if and only if layer 2 is visible 

    
TEXT
----

- The anchor of single line TEXT entities (and ATTRIB entities) is *always* the
  left-baseline regardless of what alignment parameters are stored in the DXF. 
  Those are for re-adjusting the anchor when the text is edited.
- Attrib entities can have formatting commands in them

MTEXT
-----

- The `char_height` in DXF corresponds to the cap-height of the font.
- The default line spacing is 5/3 * cap-height between the previous baseline and
  the next baseline. The `line_space_factor` is a factor applied directly to
  this value, so a factor of 3/5 results in 0 space between lines, because
  each baseline is 1 * cap-height apart.
- The middle (vertical) justification of MTEXT entities seems to be midpoint
  between the x-height of the first line to the baseline of the last line.
- MTEXT word wrapping seems to only break on spaces, not underscores or dashes.
- MTEXT word wrapping seems to treat multiple spaces between lines as if they
  were a single space.
- Alignment seems to ignore extra spaces at the start or end of lines except for
  the first line, where spaces at the beginning of the string have an effect.
  Whitespace at the beginning of the text can trigger word wrapping, which creates
  a single blank line at the start
- If a line ends with an explicit newline character and is shorter than the
  column width, only one newline is inserted.
- If a line is a single word wider than the column width, it will not be broken
  but will instead spill outside the text box. Placing a space before this word
  will create an empty line and push the word onto the next line.

POINT
-----

- All POINT entities have the same style defined by the HEADER variable $PDMODE.
- POINT entities can be drawn relative to the view scale or in absolute units.

--- End of file: dxfinternals/rendering_of_dxf_content.rst ---



--- Start of file: dxfinternals/sections/blocks_section.rst ---

.. _blocks_section_internals:

BLOCKS Section
==============

The BLOCKS section contains all BLOCK definitions, beside the `normal` reusable
BLOCKS used by the INSERT entity, all layouts, as there are the modelspace and
all paperspace layouts, have at least a corresponding BLOCK definition in the
BLOCKS section. The name of the modelspace BLOCK is "\*Model_Space" (DXF R12:
"$MODEL_SPACE") and the name of the `active` paperspace BLOCK is "\*Paper_Space"
(DXF R12: "$PAPER_SPACE"), the entities of these two layouts are stored
in the ENTITIES section, the `inactive` paperspace layouts are named by the
scheme "\*Paper_Spacennnn", and the content of the inactive paperspace layouts
are stored in their BLOCK definition in the BLOCKS section.

The content entities of blocks are stored between the BLOCK and the ENDBLK
entity.

BLOCKS section structure:

.. code-block:: none

    0           <<< start of a SECTION
    SECTION
    2           <<< start of BLOCKS section
    BLOCKS
    0           <<< start of 1. BLOCK definition
    BLOCK
    ...         <<< Block content
    ...
    0           <<< end of 1. Block definition
    ENDBLK
    0           <<< start of 2. BLOCK definition
    BLOCK
    ...         <<< Block content
    ...
    0           <<< end of 2. Block definition
    ENDBLK
    0           <<< end of BLOCKS section
    ENDSEC

.. seealso::

    :ref:`Block Management Structures`
    :ref:`Layout Management Structures`



--- End of file: dxfinternals/sections/blocks_section.rst ---



--- Start of file: dxfinternals/sections/classes_section.rst ---

.. _classes_section_internals:

CLASSES Section
===============

The CLASSES section contains CLASS definitions which are only important for Autodesk
products, some DXF entities require a class definition or AutoCAD will not open the DXF
file.

The CLASSES sections was introduced with DXF AC1015 (AutoCAD Release R13).

.. seealso::

    DXF Reference: `About the DXF CLASSES Section`_

    Documentation of `ezdxf` :class:`~ezdxf.sections.classes.ClassesSection` class.

The CLASSES section in DXF files holds the information for application-defined classes
whose instances appear in the BLOCKS, ENTITIES, and OBJECTS sections of the database.
It is assumed that a class definition is permanently fixed in the class hierarchy.
All fields are required.

**Update 2019-03-03:**

Class names are not unique, Autodesk Architectural Desktop 2007 uses the same name, but
with different CPP class names in the CLASS section, so storing classes in a dictionary
by name as key caused loss of class entries in ezdxf, using a tuple of
(name, cpp_class_name) as storage key solved the problem.

CLASS Entities
--------------

.. seealso::

    DXF Reference: `Group Codes for the CLASS entity`_


CLASS entities have no handle and therefore ezdxf does not store the CLASS entity in
the drawing entities database!

.. code-block:: none

    0
    SECTION
    2           <<< begin CLASSES section
    CLASSES
    0           <<< first CLASS entity
    CLASS
    1           <<< class DXF entity name; THIS ENTRY IS MAYBE NOT UNIQUE
    ACDBDICTIONARYWDFLT
    2           <<< C++ class name; always unique
    AcDbDictionaryWithDefault
    3           <<< application name
    ObjectDBX Classes
    90          <<< proxy capabilities flags
    0
    91          <<< instance counter for custom class, since DXF version AC1018 (R2004)
    0           <<< no problem if the counter is wrong, AutoCAD doesn't care about
    280         <<< was-a-proxy flag: 1= class was not loaded when this DXF file was created
    0           <<< 0= otherwise
    281         <<< is-an-entity flag: 1= instances reside in the BLOCKS or ENTITIES section
    0           <<< 0= instances may appear only in the OBJECTS section
    0           <<< next CLASS entity
    CLASS
    ...
    0           <<< end of CLASSES section
    ENDSEC


.. _About the DXF CLASSES Section: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-6160F1F1-2805-4C69-8077-CA1AEB6B1005

.. _Group Codes for the CLASS entity: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-DBD5351C-E408-4CED-9336-3BD489179EF5

--- End of file: dxfinternals/sections/classes_section.rst ---



--- Start of file: dxfinternals/sections/entities_section.rst ---

.. _entities_section_internals:

ENTITIES Section
================

TODO


--- End of file: dxfinternals/sections/entities_section.rst ---



--- Start of file: dxfinternals/sections/header_section.rst ---

.. _header_section_internals:

HEADER Section
==============

In DXF R12 and prior the HEADER section was optional, but since DXF R13 the HEADER section is mandatory. The overall
structure is:

.. code-block:: none

    0           <<< Begin HEADER section
    SECTION
    2
    HEADER
    9
    $ACADVER    <<< Header variable items go here
    1
    AC1009
    ...
    0
    ENDSEC      <<< End HEADER section

A header variable has a name defined by a :code:`(9, Name)` tag and following value tags.


.. seealso::

    Documentation of `ezdxf` :class:`~ezdxf.sections.header.HeaderSection` class.

    DXF Reference: `Header Variables`_


.. _Header Variables: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A85E8E67-27CD-4C59-BE61-4DC9FADBE74A

--- End of file: dxfinternals/sections/header_section.rst ---



--- Start of file: dxfinternals/sections/index.rst ---

DXF Sections
============

.. toctree::
    :maxdepth: 1

    header_section
    classes_section
    tables_section
    blocks_section
    entities_section
    objects_section


--- End of file: dxfinternals/sections/index.rst ---



--- Start of file: dxfinternals/sections/objects_section.rst ---

.. _objects_section_internals:

OBJECTS Section
===============

Objects in the OBJECTS section are organized in a hierarchical tree order, starting with the
`named objects dictionary` as the first entity in the OBJECTS section (:attr:`Drawing.rootdict`).

Not all entities in the OBJECTS section are included in this tree, :ref:`extension_dict_internals` and XRECORD data of
graphical entities are also stored in the OBJECTS section.


--- End of file: dxfinternals/sections/objects_section.rst ---



--- Start of file: dxfinternals/sections/tables_section.rst ---

.. _tables_section_internals:

TABLES Section
==============

The TABLES section contains the resource tables of a DXF document.

.. toctree::
    :maxdepth: 1

    ../tables/appid_table
    ../tables/block_record_table
    ../tables/dimstyle_table
    ../tables/layer_table
    ../tables/linetype_table
    ../tables/style_table
    ../tables/ucs_table
    ../tables/view_table
    ../tables/vport_table


The TABLES section of DXF R13 and later looks like this:

.. code-block:: none

    0
    SECTION
    2           <<< begin TABLES section
    TABLES
    0           <<< first TABLE
    TABLE
    2           <<< name of table "LTYPE"
    LTYPE
    5           <<< handle of the TABLE
    8
    330         <<< owner handle is always "0"
    0
    100         <<< subclass marker
    AcDbSymbolTable
    70          <<< count of table entries
    4           <<< do not rely on this value!
    0           <<< first table entry
    LTYPE
    ...
    0           <<< second table entry
    LTYPE
    ...
    0           <<< end of TABLE
    ENDTAB
    0           <<< next TABLE
    TABLE
    2           <<< name of table "LAYER"
    LAYER
    5           <<< handle of the TABLE
    2
    330         <<< owner handle is always "0"
    0
    100         <<< subclass marker
    AcDbSymbolTable
    70          <<< count of table entries
    1
    0           <<< first table entry
    LAYER
    ...
    0           <<< end of TABLE
    ENDTAB
    0           <<< end of SECTION
    ENDSEC

The TABLES section of DXF R12 and prior is a bit simpler and does not contain the
BLOCK_RECORD table. The handles in DXF R12 and prior are optional and only present if
the HEADER variable $HANDLING is 1.

.. code-block:: none

    0
    SECTION
    2           <<< begin TABLES section
    TABLES
    0           <<< first TABLE
    TABLE
    2           <<< name of table "LTYPE"
    LTYPE
    5           <<< optional handle of the TABLE
    8
    70          <<< count of table entries
    4
    0           <<< first table entry
    LTYPE
    ...
    0           <<< second table entry
    LTYPE
    ...
    0           <<< end of TABLE
    ENDTAB
    0           <<< next TABLE
    TABLE
    2           <<< name of table "LAYER"
    LAYER
    5           <<< optional handle of the TABLE
    2
    70          <<< count of table entries
    1
    0           <<< first table entry
    LAYER
    ...
    0           <<< end of TABLE
    ENDTAB
    0           <<< end of SECTION
    ENDSEC


--- End of file: dxfinternals/sections/tables_section.rst ---



--- Start of file: dxfinternals/tables/appid_table.rst ---

.. _appid_table_internals:

APPID Table
===========

The `APPID`_ table stores unique application identifiers. These identifiers are used to
mark sub-sections in the XDATA section of DXF entities. AutoCAD will not load DXF files
which uses AppIDs without an entry in the AppIDs table and the "ACAD" entry must always
exist.

Some known AppIDs:

=========================== =========== ===
APPID                       Used by     Description
=========================== =========== ===
ACAD                        Autodesk    various use cases
AcAecLayerStandard          Autodesk    layer description
AcCmTransparency            Autodesk    layer transparency
HATCHBACKGROUNDCOLOR        Autodesk    background color for pattern fillings
EZDXF                       ezdxf       meta data
=========================== =========== ===

.. seealso::

    - DXF Reference: `TABLES Section`_
    - DXF Reference: `APPID`_ Table
    - :class:`~ezdxf.entities.AppID` class

Table Structure DXF R12
-----------------------

.. code-block:: none

    0           <<< start of table
    TABLE
    2           <<< table type
    APPID
    70          <<< count of table entries, AutoCAD ignores this value
    3
    0           <<< 1. table entry
    APPID
    2           <<< unique application identifier
    ACAD
    70          <<< flags, see `APPID`_ reference
    0           <<< in common cases always 0
    0           <<< next table entry
    APPID
    ...
    0           <<< end of APPID table
    ENDTAB

Table Structure DXF R2000+
--------------------------

.. code-block:: none

    0           <<< start of table
    TABLE
    2           <<< table type
    APPID
    5           <<< table handle
    3
    330         <<< owner tag, tables have no owner
    0
    100         <<< subclass marker
    AcDbSymbolTable
    70          <<< count of table entries, AutoCAD ignores this value
    3
    0           <<< first table entry
    APPID
    5           <<< handle of appid
    2A
    330         <<< owner handle, handle of APPID table
    3
    100         <<< subclass marker
    AcDbSymbolTableRecord
    100         <<< subclass marker
    AcDbRegAppTableRecord
    2           <<< unique application identifier
    ACAD
    70          <<< flags, see `APPID`_ reference
    0           <<< in common cases always 0
    0           <<< next table entry
    APPID
    ...
    0           <<< end of APPID table
    ENDTAB

Name References
---------------

APPID table entries are referenced by name:

    - XDATA section of DXF entities



.. _APPID: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-6E3140E9-E560-4C77-904E-480382F0553E

.. _TABLES Section: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A9FD9590-C97B-4E41-9F26-BD82C34A4F9F

--- End of file: dxfinternals/tables/appid_table.rst ---



--- Start of file: dxfinternals/tables/block_record_table.rst ---

.. _block_record_table_internals:

BLOCK_RECORD Table
==================

Block records are essential elements for the entities management, each layout (modelspace
and paperspace) and every block definition has a block record entry. This block record
is the hard `owner` of the entities of layouts, each entity has an owner handle which
points to a block record of the layout.


--- End of file: dxfinternals/tables/block_record_table.rst ---



--- Start of file: dxfinternals/tables/dimstyle_table.rst ---

.. _dimstyle_table_internals:

DIMSTYLE Table
==============

The `DIMSTYLE`_ table stores all dimension style definitions of a DXF drawing.

You have access to the dimension styles table by the attribute :attr:`Drawing.dimstyles`.


.. seealso::

    - DXF Reference: `TABLES Section`_
    - DXF Reference: `DIMSTYLE`_ Table

Table Structure DXF R12
-----------------------

.. code-block:: none

    0           <<< start of table
    TABLE
    2           <<< set table type
    DIMSTYLE
    70          <<< count of line types defined in this table, AutoCAD ignores this value
    9
    0           <<< 1. DIMSTYLE table entry
    DIMSTYLE
                <<< DIMSTYLE data tags
    0           <<< 2. DIMSTYLE table entry
    DIMSTYLE
                <<< DIMSTYLE data tags and so on
    0           <<< end of DIMSTYLE table
    ENDTAB


DIMSTYLE Entry DXF R12
----------------------

DIMSTYLE Variables DXF R12
--------------------------

Source: `CADDManager Blog`_

.. image:: gfx/dimvars1.svg
    :align: center
    :width: 800px

.. image:: gfx/dimvars2.svg
    :align: center
    :width: 800px

=================== ======= ==============================================================================================
DIMVAR              Code     Description
=================== ======= ==============================================================================================
DIMALT              170     Controls the display of alternate units in dimensions.

DIMALTD             171     Controls the number of decimal places in alternate units. If DIMALT is turned on, DIMALTD sets
                            the number of digits displayed to the right of the decimal point in the alternate measurement.

DIMALTF             143     Controls the multiplier for alternate units. If DIMALT is turned on, DIMALTF multiplies linear
                            dimensions by a factor to produce a value in an alternate system of measurement. The initial
                            value represents the number of millimeters in an inch.

DIMAPOST            4       Specifies a text prefix or suffix (or both) to the alternate dimension measurement for all
                            types of dimensions except angular. For instance, if the current units are Architectural,
                            DIMALT is on, DIMALTF is 25.4 (the number of millimeters per inch), DIMALTD is 2, and DIMPOST
                            is set to "mm", a distance of 10 units would be displayed as 10"[254.00mm].

DIMASZ              41      Controls the size of dimension line and leader line arrowheads. Also controls the size of hook
                            lines. Multiples of the arrowhead size determine whether dimension lines and text should fit
                            between the extension lines. DIMASZ is also used to scale arrowhead blocks if set by DIMBLK.
                            DIMASZ has no effect when DIMTSZ is other than zero.

DIMBLK              5       Sets the arrowhead block displayed at the ends of dimension lines.

DIMBLK1             6       Sets the arrowhead for the first end of the dimension line when DIMSAH is 1.

DIMBLK2             7       Sets the arrowhead for the second end of the dimension line when DIMSAH is 1.

DIMCEN              141     Controls drawing of circle or arc center marks and centerlines by the DIMCENTER, DIMDIAMETER,
                            and DIMRADIUS commands.  For DIMDIAMETER and DIMRADIUS, the center mark is drawn only if you
                            place the dimension line outside the circle or arc.

                            - 0 =  No center marks or lines are drawn
                            - <0 = Centerlines are drawn
                            - >0 = Center marks are drawn

DIMCLRD             176     Assigns colors to dimension lines, arrowheads, and dimension leader lines.

                            - 0 =  BYBLOCK
                            - 1-255 = ACI AutoCAD Color Index
                            - 256 =  BYLAYER

DIMCLRE             177     Assigns colors to dimension extension lines, values like DIMCLRD

DIMCLRT             178     Assigns colors to dimension text, values like DIMCLRD

DIMDLE              46      Sets the distance the dimension line extends beyond the extension line when oblique strokes
                            are drawn instead of arrowheads.

DIMDLI              43      Controls the spacing of the dimension lines in baseline dimensions. Each dimension line is
                            offset from the previous one by this amount, if necessary, to avoid drawing over it. Changes
                            made with DIMDLI are not applied to existing dimensions.

DIMEXE              44      Specifies how far to extend the extension line beyond the dimension line.

DIMEXO              42      Specifies how far extension lines are offset from origin points. With fixed-length extension
                            lines, this value determines the minimum offset.

DIMGAP              147     Sets the distance around the dimension text when the dimension line breaks to accommodate
                            dimension text. Also sets the gap between annotation and a hook line created with the LEADER
                            command. If you enter a negative value, DIMGAP places a box around the dimension text.

                            DIMGAP is also used as the minimum length for pieces of the dimension line. When the default
                            position for the dimension text is calculated, text is positioned inside the extension lines
                            only if doing so breaks the dimension lines into two segments at least as long as DIMGAP.
                            Text placed above or below the dimension line is moved inside only if there is room for the
                            arrowheads, dimension text, and a margin between them at least as large as
                            DIMGAP: 2 * (DIMASZ + DIMGAP).

DIMLFAC             144     Sets a scale factor for linear dimension measurements. All linear dimension distances,
                            including radii, diameters, and coordinates, are multiplied by DIMLFAC before being
                            converted to dimension text. Positive values of DIMLFAC are applied to dimensions in both
                            modelspace and paperspace; negative values are applied to paperspace only.

                            DIMLFAC applies primarily to nonassociative dimensions (DIMASSOC set 0 or 1). For
                            nonassociative dimensions in paperspace, DIMLFAC must be set individually for each layout
                            viewport to accommodate viewport scaling.

                            DIMLFAC has no effect on angular dimensions, and is not applied to the values held in
                            DIMRND, DIMTM, or DIMTP.

DIMLIM              72      Generates dimension limits as the default text. Setting DIMLIM to On turns DIMTOL off.

                            - 0 = Dimension limits are not generated as default text
                            - 1 = Dimension limits are generated as default text

DIMPOST             3       Specifies a text prefix or suffix (or both) to the dimension measurement.

                            For example, to establish a suffix for millimeters, set DIMPOST to mm; a distance of 19.2
                            units would be displayed as 19.2 mm. If tolerances are turned on, the suffix is applied to
                            the tolerances as well as to the main dimension.

                            Use "<>" to indicate placement of the text in relation to the dimension value. For example,
                            enter "<>mm" to display a 5.0 millimeter radial dimension as "5.0mm". If you entered mm
                            "<>", the dimension would be displayed as "mm 5.0".

DIMRND              45      Rounds all dimensioning distances to the specified value.

                            For instance, if DIMRND is set to 0.25, all distances round to the nearest 0.25 unit. If you
                            set DIMRND to 1.0, all distances round to the nearest integer. Note that the number of
                            digits edited after the decimal point depends on the precision set by DIMDEC. DIMRND does
                            not apply to angular dimensions.

DIMSAH              173     Controls the display of dimension line arrowhead blocks.

                            - 0 = Use arrowhead blocks set by DIMBLK
                            - 1 = Use arrowhead blocks set by DIMBLK1 and DIMBLK2

DIMSCALE            40      Sets the overall scale factor applied to dimensioning variables that specify sizes,
                            distances, or offsets. Also affects the leader objects with the LEADER command.

                            Use MLEADERSCALE to scale multileader objects created with the MLEADER command.

                            * 0.0 = A reasonable default value is computed based on the scaling between the current model
                              space viewport and paperspace. If you are in paperspace or modelspace and not using the
                              paperspace feature, the scale factor is 1.0.
                            * >0 = A scale factor is computed that leads text sizes, arrowhead sizes, and other scaled
                              distances to plot at their face values.

                            DIMSCALE does not affect measured lengths, coordinates, or angles.

                            Use DIMSCALE to control the overall scale of dimensions. However, if the current dimension
                            style is annotative, DIMSCALE is automatically set to zero and the dimension scale is
                            controlled by the CANNOSCALE system variable. DIMSCALE cannot be set to a non-zero value
                            when using annotative dimensions.

DIMSE1              75      Suppresses display of the first extension line.

                            - 0 = Extension line is not suppressed
                            - 1 = Extension line is suppressed

DIMSE2              76      Suppresses display of the second extension line.

                            - 0 = Extension line is not suppressed
                            - 1 = Extension line is suppressed

DIMSOXD             175     Suppresses arrowheads if not enough space is available inside the extension lines.

                            - 0 = Arrowheads are not suppressed
                            - 1 = Arrowheads are suppressed

                            If not enough space is available inside the extension lines and DIMTIX is on, setting
                            DIMSOXD to On suppresses the arrowheads. If DIMTIX is off, DIMSOXD has no effect.

DIMTAD              77      Controls the vertical position of text in relation to the dimension line.

                            - 0 = Centers the dimension text between the extension lines.
                            - 1 = Places the dimension text above the dimension line except when the dimension line is not
                              horizontal and text inside the extension lines is forced horizontal (DIMTIH = 1). The
                              distance from the dimension line to the baseline of the lowest line of text is the current
                              DIMGAP value.
                            - 2 = Places the dimension text on the side of the dimension line farthest away from the
                              defining points.
                            - 3 = Places the dimension text to conform to Japanese Industrial Standards (JIS).
                            - 4 = Places the dimension text below the dimension line.

DIMTFAC             146     Specifies a scale factor for the text height of fractions and tolerance values relative to
                            the dimension text height, as set by DIMTXT.

                            For example, if DIMTFAC is set to 1.0, the text height of fractions and tolerances is the
                            same height as the dimension text. If DIMTFAC is set to 0.7500, the text height of fractions
                            and tolerances is three-quarters the size of dimension text.

DIMTIH              73      Controls the position of dimension text inside the extension lines for all dimension types
                            except Ordinate.

                            - 0 = Aligns text with the dimension line
                            - 1 = Draws text horizontally

DIMTIX              174     Draws text between extension lines.

                            - 0 = Varies with the type of dimension. For linear and angular dimensions, text is placed
                              inside the extension lines if there is sufficient room. For radius and diameter dimensions
                              hat dont fit inside the circle or arc, DIMTIX has no effect and always forces the text
                              outside the circle or arc.
                            - 1 = Draws dimension text between the extension lines even if it would ordinarily be placed
                              outside those lines

DIMTM               48      Sets the minimum (or lower) tolerance limit for dimension text when DIMTOL or DIMLIM is on.
                            DIMTM accepts signed values. If DIMTOL is on and DIMTP and DIMTM are set to the same value,
                            a tolerance value is drawn. If DIMTM and DIMTP values differ, the upper tolerance is drawn
                            above the lower, and a plus sign is added to the DIMTP value if it is positive. For DIMTM,
                            the program uses the negative of the value you enter (adding a minus sign if you specify a
                            positive number and a plus sign if you specify a negative number).

DIMTOFL             172     Controls whether a dimension line is drawn between the extension lines even when the text
                            is placed outside. For radius and diameter dimensions (when DIMTIX is off), draws a
                            dimension line inside the circle or arc and places the text, arrowheads, and leader outside.

                            - 0 = Does not draw dimension lines between the measured points when arrowheads are placed
                              outside the measured points
                            - 1 = Draws dimension lines between the measured points even when arrowheads are placed
                              outside the measured points

DIMTOH              74      Controls the position of dimension text outside the extension lines.

                            - 0 = Aligns text with the dimension line
                            - 1 = Draws text horizontally

DIMTOL              71      Appends tolerances to dimension text. Setting DIMTOL to on turns DIMLIM off.

DIMTP               47      Sets the maximum (or upper) tolerance limit for dimension text when DIMTOL or DIMLIM is on.
                            DIMTP accepts signed values. If DIMTOL is on and DIMTP and DIMTM are set to the same value,
                            a tolerance value is drawn. If DIMTM and DIMTP values differ, the upper tolerance is drawn
                            above the lower and a plus sign is added to the DIMTP value if it is positive.

DIMTSZ              142     Specifies the size of oblique strokes drawn instead of arrowheads for linear, radius, and
                            diameter dimensioning.

                            - 0 = Draws arrowheads.
                            - >0 = Draws oblique strokes instead of arrowheads. The size of the oblique strokes is
                              determined by this value multiplied by the DIMSCALE value

DIMTVP              145     Controls the vertical position of dimension text above or below the dimension line. The
                            DIMTVP value is used when DIMTAD = 0. The magnitude of the vertical offset of text is
                            the product of the text height and DIMTVP. Setting DIMTVP to 1.0 is equivalent to setting
                            DIMTAD = 1. The dimension line splits to accommodate the text only if the absolute value
                            of DIMTVP is less than 0.7.

DIMTXT              140     Specifies the height of dimension text, unless the current text style has a fixed height.

DIMZIN              78      Controls the suppression of zeros in the primary unit value. Values 0-3 affect
                            feet-and-inch dimensions only:

                            - 0 = Suppresses zero feet and precisely zero inches
                            - 1 = Includes zero feet and precisely zero inches
                            - 2 = Includes zero feet and suppresses zero inches
                            - 3 = Includes zero inches and suppresses zero feet
                            - 4 (Bit 3) = Suppresses leading zeros in decimal dimensions (for example, 0.5000 becomes .5000)
                            - 8 (Bit 4) = Suppresses trailing zeros in decimal dimensions (for example, 12.5000 becomes 12.5)
                            - 12 (Bit 3+4) = Suppresses both leading and trailing zeros (for example, 0.5000 becomes .5)
=================== ======= ==============================================================================================

Table Structure DXF R2000+
--------------------------

.. code-block:: none

    0           <<< start of table
    TABLE
    2           <<< set table type
    DIMSTYLE
    5           <<< DIMSTYLE table handle
    5F
    330         <<< owner tag, tables has no owner
    0
    100         <<< subclass marker
    AcDbSymbolTable
    70          <<< count of dimension styles defined in this table, AutoCAD ignores this value
    9
    0           <<< 1. DIMSTYLE table entry
    DIMSTYLE
                <<< DIMSTYLE data tags
    0           <<< 2. DIMSTYLE table entry
    DIMSTYLE
                <<< DIMSTYLE data tags and so on
    0           <<< end of DIMSTYLE table
    ENDTAB


Additional DIMSTYLE Variables DXF R13/14
----------------------------------------

Source: `CADDManager Blog`_

=================== ======= ==============================================================================================
DIMVAR              code    Description
=================== ======= ==============================================================================================
DIMADEC             179     Controls the number of precision places displayed in angular dimensions.

DIMALTTD            274     Sets the number of decimal places for the tolerance values in the alternate units of a
                            dimension.

DIMALTTZ            286     Controls suppression of zeros in tolerance values.

DIMALTU             273     Sets the units format for alternate units of all dimension substyles except Angular.

DIMALTZ             285     Controls the suppression of zeros for alternate unit dimension values. DIMALTZ values 0-3
                            affect feet-and-inch dimensions only.

DIMAUNIT            275     Sets the units format for angular dimensions.

                            - 0 = Decimal degrees
                            - 1 = Degrees/minutes/seconds
                            - 2 = Grad
                            - 3 = Radians

DIMBLK_HANDLE       342     defines DIMBLK as handle to the BLOCK RECORD entry

DIMBLK1_HANDLE      343     defines DIMBLK1 as handle to the BLOCK RECORD entry

DIMBLK2_HANDLE      344     defines DIMBLK2 as handle to the BLOCK RECORD entry

DIMDEC              271     Sets the number of decimal places displayed for the primary units of a dimension. The
                            precision is based on the units or angle format you have selected.

DIMDSEP             278     Specifies a single-character decimal separator to use when creating dimensions whose unit
                            format is decimal. When prompted, enter a single character at the Command prompt. If
                            dimension units is set to Decimal, the DIMDSEP character is used instead of the default
                            decimal point. If DIMDSEP is set to NULL (default value, reset by entering a period), the
                            decimal point is used as the dimension separator.

DIMJUST             280     Controls the horizontal positioning of dimension text.

                            - 0 = Positions the text above the dimension line and center-justifies it between the extension lines
                            - 1 = Positions the text next to the first extension line
                            - 2 = Positions the text next to the second extension line
                            - 3 = Positions the text above and aligned with the first extension line
                            - 4 =  =Positions the text above and aligned with the second extension line

DIMSD1              281     Controls suppression of the first dimension line and arrowhead. When turned on, suppresses
                            the display of the dimension line and arrowhead between the first extension line and the
                            text.

                            - 0 = First dimension line is not suppressed
                            - 1 = First dimension line is suppressed

DIMSD2              282     Controls suppression of the second dimension line and arrowhead. When turned on, suppresses
                            the display of the dimension line and arrowhead between the second extension line and the text.

                            - 0 = Second dimension line is not suppressed
                            - 1 = Second dimension line is suppressed

DIMTDEC             272     Sets the number of decimal places to display in tolerance values for the primary units in a
                            dimension. This system variable has no effect unless DIMTOL is set to On. The default for
                            DIMTOL is Off.

DIMTOLJ             283     Sets the vertical justification for tolerance values relative to the nominal dimension text.
                            This system variable has no effect unless DIMTOL is set to On. The default for DIMTOL is Off.

                            - 0 = Bottom
                            - 1 = Middle
                            - 2 = Top

DIMTXSTY_HANDLE     340     Specifies the text style of the dimension as handle to STYLE table entry

DIMTZIN             284     Controls the suppression of zeros in tolerance values.

                            Values 0-3 affect feet-and-inch dimensions only.

                            - 0 = Suppresses zero feet and precisely zero inches
                            - 1 = Includes zero feet and precisely zero inches
                            - 2 = Includes zero feet and suppresses zero inches
                            - 3 = Includes zero inches and suppresses zero feet
                            - 4 = Suppresses leading zeros in decimal dimensions (for example, 0.5000 becomes .5000)
                            - 8 = Suppresses trailing zeros in decimal dimensions (for example, 12.5000 becomes 12.5)
                            - 12 = Suppresses both leading and trailing zeros (for example, 0.5000 becomes .5)

DIMUPT              288     Controls options for user-positioned text.

                            - 0 = Cursor controls only the dimension line location
                            - 1 = Cursor controls both the text position and the dimension line location
=================== ======= ==============================================================================================

Additional DIMSTYLE Variables DXF R2000
---------------------------------------

Source: `CADDManager Blog`_

=================== ======= ==============================================================================================
DIMVAR              Code    Description
=================== ======= ==============================================================================================
DIMALTRND           148     Rounds off the alternate dimension units.

DIMATFIT            289     Determines how dimension text and arrows are arranged when space is not sufficient to place
                            both within the extension lines.

                            - 0 = Places both text and arrows outside extension lines
                            - 1 = Moves arrows first, then text
                            - 2 = Moves text first, then arrows
                            - 3 = Moves either text or arrows, whichever fits best

                            A leader is added to moved dimension text when DIMTMOVE is set to 1.

DIMAZIN             79      Suppresses zeros for angular dimensions.

                            - 0 = Displays all leading and trailing zeros
                            - 1 = Suppresses leading zeros in decimal dimensions (for example, 0.5000 becomes .5000)
                            - 2 = Suppresses trailing zeros in decimal dimensions (for example, 12.5000 becomes 12.5)
                            - 3 = Suppresses leading and trailing zeros (for example, 0.5000 becomes .5)

DIMFRAC             276     Sets the fraction format when DIMLUNIT is set to 4 (Architectural) or 5 (Fractional).

                            - 0 = Horizontal stacking
                            - 1 = Diagonal stacking
                            - 2 = Not stacked (for example, 1/2)

DIMLDRBLK_HANDLE    341     Specifies the arrow type for leaders. Handle to BLOCK RECORD

DIMLUNIT            277     Sets units for all dimension types except Angular.

                            - 1 = Scientific
                            - 2 = Decimal
                            - 3 = Engineering
                            - 4 = Architectural (always displayed stacked)
                            - 5 = Fractional (always displayed stacked)
                            - 6 = Microsoft Windows Desktop (decimal format using Control Panel settings for decimal
                              separator and number grouping symbols)

DIMLWD              371     Assigns lineweight to dimension lines.

                            * -3 = Default (the LWDEFAULT value)
                            * -2 = BYBLOCK
                            * -1 = BYLAYER

DIMLWE              372     Assigns lineweight to extension lines.

                            * -3 = Default (the LWDEFAULT value)
                            * -2 = BYBLOCK
                            * -1 = BYLAYER

DIMTMOVE            279     Sets dimension text movement rules.

                            - 0 = Moves the dimension line with dimension text
                            - 1 = Adds a leader when dimension text is moved
                            - 2 = Allows text to be moved freely without a leader
=================== ======= ==============================================================================================

Text Location
-------------

This image shows the default text locations created by `BricsCAD`_ for dimension variables ``dimtad`` and ``dimjust``:

.. image:: gfx/dimtad-dimjust.svg
    :align: center
    :width: 800px


Unofficial DIMSTYLE Variables for DXF R2007 and later
-----------------------------------------------------

The following DIMVARS are **not documented** in the `DXF Reference`_ by Autodesk.

=================== ======= ============================================================================================
DIMVAR              Code    Description
=================== ======= ============================================================================================
DIMTFILL            69      Text fill 0=off; 1=background color; 2=custom color (see DIMTFILLCLR)
DIMTFILLCLR         70      Text fill custom color as color index
DIMFXLON            290     Extension line has fixed length if set to 1
DIMFXL              49      Length of extension line below dimension line if fixed (DIMFXLON is 1), DIMEXE defines the
                            the length above the dimension line
DIMJOGANG           50      Angle of oblique dimension line segment in jogged radius dimension
DIMLTYPE_HANDLE     345     Specifies the LINETYPE of the dimension line. Handle to LTYPE table entry
DIMLTEX1_HANDLE     346     Specifies the LINETYPE of the extension line 1. Handle to LTYPE table entry
DIMLTEX2_HANDLE     347     Specifies the LINETYPE of the extension line 2. Handle to LTYPE table entry
=================== ======= ============================================================================================

Extended Settings as Special XDATA Groups
-----------------------------------------

Prior to DXF R2007, some extended settings for the dimension and the extension lines are stored in the XDATA section by
following entries, this is not documented by `Autodesk`_:

.. code-block:: none

    1001
    ACAD_DSTYLE_DIM_LINETYPE        <<< linetype for dimension line
    1070
    380                             <<< group code, which differs from R2007 DIMDLTYPE
    1005
    FFFF                            <<< handle to LTYPE entry
    1001
    ACAD_DSTYLE_DIM_EXT1_LINETYPE   <<< linetype for extension line 1
    1070
    381                             <<< group code, which differs from R2007 DIMLTEX1
    1005
    FFFF                            <<< handle to LTYPE entry
    1001
    ACAD_DSTYLE_DIM_EXT2_LINETYPE   <<< linetype for extension line 1
    1070
    382                             <<< group code, which differs from R2007 DIMLTEX2
    1005
    FFFF                            <<< handle to LTYPE entry
    1001
    ACAD_DSTYLE_DIMEXT_ENABLED      <<< extension line fixed
    1070
    383                             <<< group code, which differs from R2007 DIMEXFIX
    1070
    1                               <<< fixed if 1 else 0
    1001
    ACAD_DSTYLE_DIMEXT_LENGTH       <<< extension line fixed length
    1070
    378                             <<< group code, which differs from R2007 DIMEXLEN
    1040
    1.33                            <<< length of extension line below dimension line

This XDATA groups requires also an appropriate APPID entry in the APPID table. This feature is not supported by `ezdxf`.

.. _DIMSTYLE: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-F2FAD36F-0CE3-4943-9DAD-A9BCD2AE81DA

.. _TABLES Section: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A9FD9590-C97B-4E41-9F26-BD82C34A4F9F

.. _CADDManager Blog: http://www.caddmanager.com/CMB/2009/09/cad-standards-autocad-dimension-variables/


.. include:: ../reflinks.inc


--- End of file: dxfinternals/tables/dimstyle_table.rst ---



--- Start of file: dxfinternals/tables/index.rst ---

DXF Tables
==========

.. toctree::
    :maxdepth: 1

    appid_table
    block_record_table
    dimstyle_table
    layer_table
    linetype_table
    style_table
    ucs_table
    view_table
    vport_table



--- End of file: dxfinternals/tables/index.rst ---



--- Start of file: dxfinternals/tables/layer_table.rst ---

.. _layer_table_internals:

LAYER Table
===========

TODO

.. seealso::

    - DXF Reference: `TABLES Section`_
    - DXF Reference: `LAYER`_ Table
    - :class:`~ezdxf.entities.Layer` class

Table Structure DXF R2000+
--------------------------

.. code-block:: none

    0           <<< start of table
    TABLE
    2           <<< name of table "LAYER"
    LAYER
    5           <<< handle of the TABLE
    2
    330         <<< owner tag is always "0"
    0
    100         <<< subclass marker
    AcDbSymbolTable
    70          <<< count of layers defined in this table, AutoCAD ignores this value
    5
    0           <<< 1. LAYER table entry
    LAYER
    ...         <<< LAYER entity tags
    0           <<< 2. LAYER table entry
    LAYER
    ...         <<< LAYER entity tags
    0           <<< end of TABLE
    ENDTAB

Layer Entity Tags DXF R2000+
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are some quirks:

    - the frozen/thawed state is stored in flags (group code 70)
    - the locked/unlocked state is stored in flags (group code 70)
    - the off state is stored as negative color value (group code 6)
    - the layer description is stored in the XDATA section
    - the transparency value is stored in the XDATA section

.. code-block:: none

    0           <<< LAYER table entry
    LAYER
    5           <<< handle of LAYER
    10
    330         <<< owner handle, handle of LAYER table
    2
    100         <<< subclass marker
    AcDbSymbolTableRecord
    100         <<< subclass marker
    AcDbLayerTableRecord
    2           <<< layer name
    0           <<< layer "0"
    70          <<< flags
    0
    62          <<< color
    7           <<< a negative value switches the layer off
    420         <<< optional true color value
    0
    6           <<< linetype
    Continuous
    290         <<< optional plot flag
    1
    370         <<< lineweight
    -3
    390         <<< handle to plot style
    F
    347         <<< material handle
    47
    348         <<< unknown1
    0
    1001        <<< XDATA section, APPID
    AcAecLayerStandard
    1000        <<< unknown first value, here an empty string

    1000        <<< layer description
    This layer has a description
    1001        <<< APPID
    AcCmTransparency
    1071        <<< layer transparency value
    0

Layer Viewport Overrides
~~~~~~~~~~~~~~~~~~~~~~~~

Some layer attributes can be overridden individually for any VIEWPORT
entity. This overrides are stored as extension dictionary entries of
the LAYER entity pointing to XRECORD entities in the objects section:

.. code-block:: none

    0
    LAYER
    5
    9F
    102         <<< APP data, extension dictionary
    {ACAD_XDICTIONARY
    360         <<< handle to the xdict in the objects section
    B3
    102
    }
    330
    2
    100
    AcDbSymbolTableRecord
    100
    AcDbLayerTableRecord
    2
    LayerA
    ...

The extension DICTIONARY entity:

.. code-block:: none

    0           <<< entity type
    DICTIONARY
    5           <<< handle
    B3
    330         <<< owner handle
    9F          <<< the layer owns this dictionary
    100         <<< subclass marker
    AcDbDictionary
    280         <<< hard owned flag
    1
    281         <<< cloning type
    1           <<< keep existing
    3           <<< transparency override
    ADSK_XREC_LAYER_ALPHA_OVR
    360         <<< handle to XRECORD
    E5
    3           <<< color override
    ADSK_XREC_LAYER_COLOR_OVR
    360         <<< handle to XRECORD
    B4
    3           <<< linetype override
    ADSK_XREC_LAYER_LINETYPE_OVR
    360         <<< handle to XRECORD
    DD
    3           <<< lineweight override
    ADSK_XREC_LAYER_LINEWT_OVR
    360         <<< handle to XRECORD
    E2

Transparency override XRECORD:

.. code-block:: none

    0           <<< entity type
    XRECORD
    5           <<< handle
    E5
    102         <<< reactors app data
    {ACAD_REACTORS
    330
    B3          <<< extension dictionary
    102
    }
    330         <<< owner tag
    B3          <<< extension dictionary
    100         <<< subclass marker
    AcDbXrecord
    280         <<< cloning flag
    1           <<< keep existing
    102         <<< for each overridden VIEWPORT one entry
    {ADSK_LYR_ALPHA_OVERRIDE
    335         <<< handle to VIEWPORT
    AC
    440         <<< transparency override
    33554661
    102
    }

Color override XRECORD:

.. code-block:: none

    0
    XRECORD
    ...         <<< like transparency XRECORD
    102         <<< for each overridden VIEWPORT one entry
    {ADSK_LYR_COLOR_OVERRIDE
    335         <<< handle to VIEWPORT
    AF
    420         <<< color override
    -1023409925 <<< raw color value
    102
    }

Linetype override XRECORD:

.. code-block:: none

    0
    XRECORD
    ...         <<< like transparency XRECORD
    102         <<< for each overridden VIEWPORT one entry
    {ADSK_LYR_LINETYPE_OVERRIDE
    335         <<< handle to VIEWPORT
    AC
    343         <<< linetype override
    DC          <<< handle to LINETYPE table entry
    102
    }

Lineweight override XRECORD:

.. code-block:: none

    0
    XRECORD
    ...         <<< like transparency XRECORD
    102         <<< for each overridden VIEWPORT one entry
    {ADSK_LYR_LINEWT_OVERRIDE
    335         <<< handle to VIEWPORT
    AC
    91          <<< lineweight override
    13          <<< lineweight value
    102
    }

Name References
---------------

LAYER table entries are referenced by name:

    - all graphical DXF entities
    - VIEWPORT entity, frozen layers
    - LAYER_FILTER
    - LAYER_INDEX

.. _LAYER: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-D94802B0-8BE8-4AC9-8054-17197688AFDB

.. _TABLES Section: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A9FD9590-C97B-4E41-9F26-BD82C34A4F9F

--- End of file: dxfinternals/tables/layer_table.rst ---



--- Start of file: dxfinternals/tables/linetype_table.rst ---

.. _ltype_table_internals:

LTYPE Table
===========

The `LTYPE`_ table stores all line type definitions of a DXF drawing. Every line type
used in the drawing has to have a table entry, or the DXF drawing is invalid for AutoCAD.

DXF R12 supports just simple line types, DXF R2000+ supports also complex line types with
text or shapes included.

You have access to the line types table by the attribute :attr:`Drawing.linetypes`.
The line type table itself is not stored in the entity database, but the table entries
are stored in entity database, and can be accessed by its handle.


.. seealso::

    - DXF Reference: `TABLES Section`_
    - DXF Reference: `LTYPE`_ Table
    - :class:`~ezdxf.entities.Linetype` class

Table Structure DXF R12
-----------------------

.. code-block:: none

    0           <<< start of table
    TABLE
    2           <<< table type
    LTYPE
    70          <<< count of table entries, AutoCAD ignores this value
    9
    0           <<< 1. LTYPE table entry
    LTYPE
                <<< LTYPE data tags
    0           <<< 2. LTYPE table entry
    LTYPE
                <<< LTYPE data tags and so on
    0           <<< end of LTYPE table
    ENDTAB


Table Structure DXF R2000+
--------------------------

.. code-block:: none

    0           <<< start of table
    TABLE
    2           <<< table type
    LTYPE
    5           <<< table handle
    5F
    330         <<< owner tag, tables have no owner
    0
    100         <<< subclass marker
    AcDbSymbolTable
    70          <<< count of table entiries, AutoCAD ignores this value
    9
    0           <<< 1. LTYPE table entry
    LTYPE
                <<< LTYPE data tags
    0           <<< 2. LTYPE table entry
    LTYPE
                <<< LTYPE data tags and so on
    0           <<< end of LTYPE table
    ENDTAB


Simple Line Type
----------------

`ezdxf` setup for line type "CENTER":

.. code-block:: python

    dwg.linetypes.add("CENTER",
        description="Center ____ _ ____ _ ____ _ ____ _ ____ _ ____",
        pattern=[2.0, 1.25, -0.25, 0.25, -0.25],
    )


Simple Line Type Tag Structure DXF R2000+
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: none

    0           <<< line type table entry
    LTYPE
    5           <<< handle of line type
    1B1
    330         <<< owner handle, handle of LTYPE table
    5F
    100         <<< subclass marker
    AcDbSymbolTableRecord
    100         <<< subclass marker
    AcDbLinetypeTableRecord
    2           <<< line type name
    CENTER
    70          <<< flags
    0
    3
    Center ____ _ ____ _ ____ _ ____ _ ____ _ ____
    72          <<< signature tag
    65          <<< ascii code for "A"
    73          <<< count of pattern groups starting with a code 49 tag
    4           <<< 4 pattern groups
    40          <<< overall pattern length in drawing units
    2.0
    49          <<< 1. pattern group
    1.25        <<< >0 line, <0 gap, =0 point
    74          <<< type marker
    0           <<< 0 for line group
    49          <<< 2. pattern group
    -0.25
    74
    0
    49          <<< 3. pattern group
    0.25
    74
    0
    49          <<< 4. pattern group
    -0.25
    74
    0

Complex Line Type TEXT
----------------------

`ezdxf` setup for line type "GASLEITUNG":

.. code-block:: python

    dwg.linetypes.add("GASLEITUNG",
        description="Gasleitung2 ----GAS----GAS----GAS----GAS----GAS----GAS--",
        length=1,
        pattern='A,.5,-.2,["GAS",STANDARD,S=.1,U=0.0,X=-0.1,Y=-.05],-.25',
    )

TEXT Tag Structure
~~~~~~~~~~~~~~~~~~

.. code-block:: none

    0
    LTYPE
    5
    614
    330
    5F
    100         <<< subclass marker
    AcDbSymbolTableRecord
    100         <<< subclass marker
    AcDbLinetypeTableRecord
    2
    GASLEITUNG
    70
    0
    3
    Gasleitung2 ----GAS----GAS----GAS----GAS----GAS----GAS--
    72          <<< signature tag
    65          <<< ascii code for "A"
    73          <<< count of pattern groups starting with a code 49 tag
    3           <<< 3 pattern groups
    40          <<< overall pattern length in drawing units
    1
    49          <<< 1. pattern group
    0.5         <<< >0 line, <0 gap, =0 point
    74          <<< type marker
    0           <<< 0 for line group
    49          <<< 2. pattern group
    -0.2
    74          <<< type marker
    2           <<< 2 for text group
    75          <<< shape number in shape-file
    0           <<< always 0 for text group
    340         <<< handle to text style "STANDARD"
    11
    46          <<< scaling factor: "s" in pattern definition
    0.1
    50          <<< rotation angle: "r" and "u" in pattern definition
    0.0
    44          <<< shift x units: "x" in pattern definition = parallel to line direction
    -0.1
    45          <<< shift y units: "y" in pattern definition = normal to line direction
    -0.05
    9           <<< text
    GAS
    49          <<< 3. pattern group
    -0.25
    74
    0

Complex Line Type SHAPE
-----------------------

ezdxf setup for line type 'GRENZE2'::

    dwg.linetypes.new('GRENZE2', dxfattribs={
        'description': 'Grenze eckig ----[]-----[]----[]-----[]----[]--',
        'length': 1.45,
        'pattern': 'A,.25,-.1,[132,ltypeshp.shx,x=-.1,s=.1],-.1,1',
    })

SHAPE Tag Structure
~~~~~~~~~~~~~~~~~~~

.. code-block:: none

    0
    LTYPE
    5
    615
    330
    5F
    100         <<< subclass marker
    AcDbSymbolTableRecord
    100         <<< subclass marker
    AcDbLinetypeTableRecord
    2
    GRENZE2
    70
    0
    3
    Grenze eckig ----[]-----[]----[]-----[]----[]--
    72          <<< signature tag
    65          <<< ascii code for "A"
    73          <<< count of pattern groups starting with a code 49 tag
    4           <<< 4 pattern groups
    40          <<< overall pattern length in drawing units
    1.45
    49          <<< 1. pattern group
    0.25        <<< >0 line, <0 gap, =0 point
    74          <<< type marker
    0           <<< 0 for line group
    49          <<< 2. pattern group
    -0.1
    74          <<< type marker
    4           <<< 4 for shape group
    75          <<< shape number in shape-file
    132
    340         <<< handle to shape-file entry "ltypeshp.shx"
    616
    46          <<< scaling factor: "s" in pattern definition
    0.1
    50          <<< rotation angle: "r" and "u" in pattern definition
    0.0
    44          <<< shift x units: "x" in pattern definition = parallel to line direction
    -0.1
    45          <<< shift y units: "y" in pattern definition = normal to line direction
    0.0
    49          <<< 3. pattern group
    -0.1
    74
    0
    49          <<< 4. pattern group
    1.0
    74
    0

Name References
---------------

LTYPE table entries are referenced by name:

    - all graphical DXF entities
    - LAYER table entry
    - DIMSTYLE table entry
    - DIMSTYLE override
    - MLINESTYLE

.. _LTYPE: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-F57A316C-94A2-416C-8280-191E34B182AC

.. _TABLES Section: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A9FD9590-C97B-4E41-9F26-BD82C34A4F9F

--- End of file: dxfinternals/tables/linetype_table.rst ---



--- Start of file: dxfinternals/tables/style_table.rst ---

.. _style_table_internals:

STYLE Table
===========

The `STYLE`_ table stores all text styles and shape-file definitions. The "STANDARD"
entry must always exist.

Shape-files are also defined by a STYLE table entry, the bit 0 of the flags-tag is
set to 1 and the name-tag is an empty string, the only important data is the font-tag
with group code 3 which stores the associated SHX font file.

.. seealso::

    - DXF Reference: `TABLES Section`_
    - DXF Reference: `STYLE`_ Table
    - :class:`~ezdxf.entities.Textstyle` class


Table Structure DXF R12
-----------------------

.. code-block:: none

    0           <<< start of table
    TABLE
    2           <<< table type
    STYLE
    70           <<< count of table entries, AutoCAD ignores this value
    1
    0           <<< first table entry
    STYLE
    2           <<< text style name
    Standard
    70          <<< flags, see `STYLE`_ reference
    0
    40          <<< fixed text height; 0 if not fixed
    0.0
    41          <<< width factor
    1.0
    50          <<< oblique angle
    0.0
    71          <<< text generation flags; 2=backwards (mirror-x), 4=upside down (mirror-y)
    0
    42          <<< last height used
    2.5
    3           <<< font file name; SHX or TTF file name
    txt
    4           <<< big font name; SHX file with unicode symbols; empty if none

    0           <<< next text style
    STYLE
    ...
    0           <<< end of STYLE table
    ENDTAB


Table Structure DXF R2000+
--------------------------

.. code-block:: none

    0           <<< start of table
    TABLE
    2           <<< table type
    STYLE
    5           <<< table handle
    5
    330         <<< owner tag, tables have no owner
    0
    100         <<< subclass marker
    AcDbSymbolTable
    70           <<< count of table entries, AutoCAD ignores this value
    1
    0           <<< first table entry
    STYLE
    5           <<< handle of text style
    29
    330         <<< owner handle, handle of STYLE table
    5
    100         <<< subclass marker
    AcDbSymbolTableRecord
    100         <<< subclass marker
    AcDbTextStyleTableRecord
    2           <<< text style name
    Standard
    70          <<< flags, see `STYLE`_ reference
    0
    40          <<< fixed text height; 0 if not fixed
    0.0
    41          <<< width factor
    1.0
    50          <<< oblique angle
    0.0
    71          <<< text generation flags; 2=backwards (mirror-x), 4=upside down (mirror-y)
    0
    42          <<< last height used
    2.5
    3           <<< font file name; SHX or TTF file name
    txt
    4           <<< big font name; SHX file with unicode symbols; empty if none

    0           <<< next text style
    STYLE
    ...
    0           <<< end of STYLE table
    ENDTAB

Extended Font Data
------------------

Additional information of the font-family, italic and bold style flags are stored in the
XDATA section of the STYLE entity by the APPID "ACAD":

.. code-block:: none

    0
    STYLE
    ...
    3
    Arial.ttf
    4

    1001        <<< start of the XDATA section
    ACAD        <<< APPID
    1000        <<< font family name
    Arial
    1071        <<< style flags, see table below
    50331682

======= =========== =========
Flag    dec         hex
======= =========== =========
ITALIC  16777216    0x1000000
BOLD    33554432    0x2000000
======= =========== =========

Name References
---------------

STYLE table entries are referenced by name:

    - TEXT entity
    - MTEXT entity
    - DIMSTYLE table entry
    - DIMSTYLE override



.. _STYLE: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-EF68AF7C-13EF-45A1-8175-ED6CE66C8FC9

.. _TABLES Section: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A9FD9590-C97B-4E41-9F26-BD82C34A4F9F

--- End of file: dxfinternals/tables/style_table.rst ---



--- Start of file: dxfinternals/tables/ucs_table.rst ---

.. _ucs_table_internals:

UCS Table
=========

TODO


--- End of file: dxfinternals/tables/ucs_table.rst ---



--- Start of file: dxfinternals/tables/view_table.rst ---

.. _view_table_internals:

VIEW Table
==========

The `VIEW`_ entry stores a named view of the model or a paperspace layout. This stored views makes parts of the
drawing or some view points of the model in a CAD applications more accessible. This views have no influence to the
drawing content or to the generated output by exporting PDFs or plotting on paper sheets, they are just for the
convenience of CAD application users.

Using *ezdxf* you have access to the views table by the attribute :attr:`Drawing.views`. The views table itself is
not stored in the entity database, but the table entries are stored in entity database, and can be accessed by its
handle.

DXF R12
-------

.. code-block:: none

    0
    VIEW
    2       <<< name of view
    VIEWNAME
    70      <<< flags bit-coded: 1st bit -> (0/1 = modelspace/paperspace)
    0       <<< modelspace
    40      <<< view width in Display Coordinate System (DCS)
    20.01
    10      <<< view center point in DCS
    40.36   <<<     x value
    20      <<<     group code for y value
    15.86   <<<     y value
    41      <<< view height in DCS
    17.91
    11      <<< view direction from target point, 3D vector
    0.0     <<<     x value
    21      <<<     group code for y value
    0.0     <<<     y value
    31      <<<     group code for z value
    1.0     <<<     z value
    12      <<< target point in WCS
    0.0     <<<     x value
    22      <<<     group code for y value
    0.0     <<<     y value
    32      <<<     group code for z value
    0.0     <<<     z value
    42      <<< lens (focal) length
    50.0    <<< 50mm
    43      <<< front clipping plane, offset from target
    0.0
    44      <<< back clipping plane, offset from target
    0.0
    50      <<< twist angle
    0.0
    71      <<< view mode
    0

.. seealso::

    :ref:`Coordinate Systems`

DXF R2000+
----------

Mostly the same structure as DXF R12, but with handle, owner tag and subclass markers.

.. code-block:: none

    0       <<< adding the VIEW table head, just for information
    TABLE
    2       <<< table name
    VIEW
    5       <<< handle of table, see owner tag of VIEW table entry
    37C
    330     <<< owner tag of table, always #0
    0
    100     <<< subclass marker
    AcDbSymbolTable
    70      <<< VIEW table (max.) count, not reliable (ignore)
    9
    0       <<< first VIEW table entry
    VIEW
    5       <<< handle
    3EA
    330     <<< owner, the VIEW table is the owner of the VIEW entry
    37C     <<< handle of the VIEW table
    100     <<< subclass marker
    AcDbSymbolTableRecord
    100     <<< subclass marker
    AcDbViewTableRecord
    2       <<< view name, from here all the same as DXF R12
    VIEWNAME
    70
    0
    40
    20.01
    10
    40.36
    20
    15.86
    41
    17.91
    11
    0.0
    21
    0.0
    31
    1.0
    12
    0.0
    22
    0.0
    32
    0.0
    42
    50.0
    43
    0.0
    44
    0.0
    50
    0.0
    71
    0
    281     <<< render mode 0-6 (... too much options)
    0       <<< 0= 2D optimized (classic 2D)
    72      <<< UCS associated (0/1 = no/yes)
    0       <<< 0 = no

DXF R2000+ supports additional features in the VIEW entry, see the `VIEW`_ table reference provided by Autodesk.

.. _VIEW: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-CF3094AB-ECA9-43C1-8075-7791AC84F97C


--- End of file: dxfinternals/tables/view_table.rst ---



--- Start of file: dxfinternals/tables/vport_table.rst ---

.. _vport_table_internals:

VPORT Configuration Table
=========================

The `VPORT`_ table stores the modelspace viewport configurations. A viewport configuration
is a tiled view of multiple viewports or just one viewport.

.. image:: gfx/tiled_view.png
    :align: center

In contrast to other tables the VPORT table can have multiple entries with the same name,
because all VPORT entries of a multi-viewport configuration are having the same name -
the viewport configuration name. The name of the actual displayed viewport configuration
is ``'*ACTIVE'``, as always table entry names are case insensitive
(:code:`'*ACTIVE' == '*Active'`).

The available display area in AutoCAD has normalized coordinates, the lower-left corner
is (0, 0) and the upper-right corner is (1, 1) regardless of the true aspect ratio and
available display area in pixels.  A single viewport configuration has one VPORT entry
``'*ACTIVE'`` with the lower-left corner (0, 0) and the upper-right corner (1, 1).

The following statements refer to a 2D plan view: the view-target-point defines the
origin of the DCS (Display Coordinate system), the view-direction vector defines the
z-axis of the :ref:`DCS`, the view-center-point (in DCS) defines the point in modelspace
translated to the center point of the viewport, the view height and the aspect-ratio
defines how much of the modelspace is displayed. AutoCAD tries to fit the modelspace
area into the available viewport space e.g. view height is 15 units and aspect-ratio is
2.0 the modelspace to display is 30 units wide and 15 units high, if the viewport has an
aspect ratio of 1.0, AutoCAD displays 30x30 units of the modelspace in the viewport.
If the modelspace aspect-ratio is 1.0 the modelspace to display is 15x15 units and fits
properly into the viewport area.

But tests show that the translation of the view-center-point to the middle of the
viewport not always work as I expected. (still digging...)

.. note::

    All floating point values are rounded to 2 decimal places for better readability.

DXF R12
-------

Multi-viewport configuration with three viewports.

.. code-block:: none

    0       <<< table start
    TABLE
    2       <<< table type
    VPORT
    70      <<< VPORT table (max.) count, not reliable (ignore)
    3
    0       <<< first VPORT entry
    VPORT
    2       <<< VPORT (configuration) name
    *ACTIVE
    70      <<< standard flags, bit-coded
    0
    10      <<< lower-left corner of viewport
    0.45    <<<     x value, virtual coordinates in range [0 - 1]
    20      <<<     group code for y value
    0.0     <<<     y value, virtual coordinates in range [0 - 1]
    11      <<< upper-right corner of viewport
    1.0     <<<     x value, virtual coordinates in range [0 - 1]
    21      <<<     group code for y value
    1.0     <<<     y value, virtual coordinates in range [0 - 1]
    12      <<< view center point (in DCS), ???
    13.71   <<<     x value
    22      <<<     group code for y value
    0.02    <<<     y value
    13      <<< snap base point (in DCS)
    0.0     <<<     x value
    23      <<<     group code for y value
    0.0     <<<     y value
    14      <<< snap spacing X and Y
    1.0     <<<     x value
    24      <<<     group code for y value
    1.0     <<<     y value
    15      <<< grid spacing X and Y
    0.0     <<<     x value
    25      <<<     group code for y value
    0.0     <<<     y value
    16      <<< view direction from target point (in WCS), defines the z-axis of the DCS
    1.0     <<<     x value
    26      <<<     group code for y value
    -1.0    <<<     y value
    36      <<<     group code for z value
    1.0     <<<     z value
    17      <<< view target point (in WCS), defines the origin of the DCS
    0.0     <<<     x value
    27      <<<     group code for y value
    0.0     <<<     y value
    37      <<<     group code for z value
    0.0     <<<     z value
    40      <<< view height
    35.22
    41      <<< viewport aspect ratio
    0.99
    42      <<< lens (focal) length
    50.0    <<< 50mm
    43      <<< front clipping planes, offsets from target point
    0.0
    44      <<< back clipping planes, offsets from target point
    0.0
    50      <<< snap rotation angle
    0.0
    51      <<< view twist angle
    0.0
    71      <<< view mode
    0
    72      <<< circle zoom percent
    1000
    73      <<< fast zoom setting
    1
    74      <<< UCSICON setting
    3
    75      <<< snap on/off
    0
    76      <<< grid on/off
    0
    77      <<< snap style
    0
    78      <<< snap isopair
    0
    0       <<< next VPORT entry
    VPORT
    2       <<< VPORT (configuration) name
    *ACTIVE <<< same as first VPORT entry
    70
    0
    10
    0.0
    20
    0.5
    11
    0.45
    21
    1.0
    12
    8.21
    22
    9.41
    ...
    ...
    0       <<< next VPORT entry
    VPORT
    2       <<< VPORT (configuration) name
    *ACTIVE <<< same as first VPORT entry
    70
    0
    10
    0.0
    20
    0.0
    11
    0.45
    21
    0.5
    12
    2.01
    22
    -9.33
    ...
    ...
    0
    ENDTAB

DXF R2000+
----------

Mostly the same structure as DXF R12, but with handle, owner tag and subclass markers.

.. code-block:: none

    0       <<< table start
    TABLE
    2       <<< table type
    VPORT
    5       <<< table handle
    151F
    330     <<< owner, table has no owner - always #0
    0
    100     <<< subclass marker
    AcDbSymbolTable
    70      <<< VPORT table (max.) count, not reliable (ignore)
    3
    0       <<< first VPORT entry
    VPORT
    5       <<< entry handle
    158B
    330     <<< owner, VPORT table is owner of VPORT entry
    151F
    100     <<< subclass marker
    AcDbSymbolTableRecord
    100     <<< subclass marker
    AcDbViewportTableRecord
    2       <<< VPORT (configuration) name
    *ACTIVE
    70      <<< standard flags, bit-coded
    0
    10      <<< lower-left corner of viewport
    0.45    <<<     x value, virtual coordinates in range [0 - 1]
    20      <<<     group code for y value
    0.0     <<<     y value, virtual coordinates in range [0 - 1]
    11      <<< upper-right corner of viewport
    1.0     <<<     x value, virtual coordinates in range [0 - 1]
    21      <<<     group code for y value
    1.0     <<<     y value, virtual coordinates in range [0 - 1]
    12      <<< view center point (in DCS)
    13.71   <<<     x value
    22      <<<     group code for y value
    0.38    <<<     y value
    13      <<< snap base point (in DCS)
    0.0     <<<     x value
    23      <<<     group code for y value
    0.0     <<<     y value
    14      <<< snap spacing X and Y
    1.0     <<<     x value
    24      <<<     group code for y value
    1.0     <<<     y value
    15      <<< grid spacing X and Y
    0.0     <<<     x value
    25      <<<     group code for y value
    0.0     <<<     y value
    16      <<< view direction from target point (in WCS)
    1.0     <<<     x value
    26      <<<     group code for y value
    -1.0    <<<     y value
    36      <<<     group code for z value
    1.0     <<<     z value
    17      <<< view target point (in WCS)
    0.0     <<<     x value
    27      <<<     group code for y value
    0.0     <<<     y value
    37      <<<     group code for z value
    0.0     <<<     z value
    40      <<< view height
    35.22
    41      <<< viewport aspect ratio
    0.99
    42      <<< lens (focal) length
    50.0    <<< 50mm
    43      <<< front clipping planes, offsets from target point
    0.0
    44      <<< back clipping planes, offsets from target point
    0.0
    50      <<< snap rotation angle
    0.0
    51      <<< view twist angle
    0.0
    71      <<< view mode
    0
    72      <<< circle zoom percent
    1000
    73      <<< fast zoom setting
    1
    74      <<< UCSICON setting
    3
    75      <<< snap on/off
    0
    76      <<< grid on/off
    0
    77      <<< snap style
    0
    78      <<< snap isopair
    0
    281     <<< render mode 1-6 (... too many options)
    0       <<< 0 = 2D optimized (classic 2D)
    65      <<< Value of UCSVP for this viewport. (0 = UCS will not change when this viewport is activated)
    1       <<< 1 = then viewport stores its own UCS which will become the current UCS whenever the viewport is activated.
    110     <<< UCS origin (3D point)
    0.0     <<<     x value
    120     <<<     group code for y value
    0.0     <<<     y value
    130     <<<     group code for z value
    0.0     <<<     z value
    111     <<< UCS X-axis (3D vector)
    1.0     <<<     x value
    121     <<<     group code for y value
    0.0     <<<     y value
    131     <<<     group code for z value
    0.0     <<<     z value
    112     <<< UCS Y-axis (3D vector)
    0.0     <<<     x value
    122     <<<     group code for y value
    1.0     <<<     y value
    132     <<<     group code for z value
    0.0     <<<     z value
    79      <<< Orthographic type of UCS 0-6 (... too many options)
    0       <<< 0 = UCS is not orthographic
    146     <<< elevation
    0.0
    1001    <<< extended data - undocumented
    ACAD_NAV_VCDISPLAY
    1070
    3
    0       <<< next VPORT entry
    VPORT
    5
    158C
    330
    151F
    100
    AcDbSymbolTableRecord
    100
    AcDbViewportTableRecord
    2       <<< VPORT (configuration) name
    *ACTIVE <<< same as first VPORT entry
    70
    0
    10
    0.0
    20
    0.5
    11
    0.45
    21
    1.0
    12
    8.21
    22
    9.72
    ...
    ...
    0       <<< next VPORT entry
    VPORT
    5
    158D
    330
    151F
    100
    AcDbSymbolTableRecord
    100
    AcDbViewportTableRecord
    2       <<< VPORT (configuration) name
    *ACTIVE <<< same as first VPORT entry
    70
    0
    10
    0.0
    20
    0.0
    11
    0.45
    21
    0.5
    12
    2.01
    22
    -8.97
    ...
    ...
    0
    ENDTAB

.. _VPORT: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-8CE7CC87-27BD-4490-89DA-C21F516415A9


--- End of file: dxfinternals/tables/vport_table.rst ---



--- Start of file: dxfobjects/dictionary.rst ---

Dictionary
==========

.. module:: ezdxf.entities
    :noindex:

The `DICTIONARY`_ entity is a general storage entity.

AutoCAD maintains items such as MLINE_STYLES and GROUP definitions as objects in
dictionaries. Other applications are free to create and use their own
dictionaries as they see fit. The prefix ``'ACAD_'`` is reserved for use by
AutoCAD applications.

Dictionary entries are (key, :class:`DXFEntity`) pairs for fully loaded or
new created DXF documents. The referenced entities are owned by the dictionary
and cannot be graphical entities that always belong to the layout in which they
are located.

Loading DXF files is done in two passes, because at the first loading stage not
all referenced objects are already stored in the entity database. Therefore the
entities are stored as handles strings at the first loading stage and have to
be replaced by the real entity at the second loading stage.
If the entity is still a handle string after the second loading stage, the
entity does not exist.

Dictionary keys are handled case insensitive by AutoCAD, but not by `ezdxf`,
in doubt use an uppercase key. AutoCAD stores all keys in uppercase.

======================== =============================================================
Subclass of              :class:`ezdxf.entities.DXFObject`
DXF type                 ``'DICTIONARY'``
Factory function         :meth:`ezdxf.sections.objects.ObjectsSection.add_dictionary`
======================== =============================================================

.. warning::

    Do not instantiate object classes by yourself - always use the provided
    factory functions!

.. class:: Dictionary

    .. attribute:: dxf.hard_owned

        If set to 1, indicates that elements of the dictionary are to be
        treated as hard-owned.

    .. attribute:: dxf.cloning

        Duplicate record cloning flag (determines how to merge duplicate entries,
        ignored by `ezdxf`):

        === ==================
        0   not applicable
        1   keep existing
        2   use clone
        3   <xref>$0$<name>
        4   $0$<name>
        5   Unmangle name
        === ==================


    .. autoattribute:: is_hard_owner

    .. automethod:: __len__

    .. automethod:: __contains__

    .. automethod:: __getitem__

    .. automethod:: __setitem__

    .. automethod:: __delitem__

    .. automethod:: keys

    .. automethod:: items

    .. automethod:: count

    .. automethod:: get

    .. automethod:: add

    .. automethod:: remove

    .. automethod:: discard

    .. automethod:: clear

    .. automethod:: add_new_dict

    .. automethod:: get_required_dict

    .. automethod:: add_dict_var

    .. automethod:: add_xrecord

    .. automethod:: link_dxf_object


.. _DICTIONARY: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-40B92C63-26F0-485B-A9C2-B349099B26D0

DictionaryWithDefault
=====================

======================== =========================================================================
Subclass of              :class:`ezdxf.entities.Dictionary`
DXF type                 ``'ACDBDICTIONARYWDFLT'``
Factory function         :meth:`ezdxf.sections.objects.ObjectsSection.add_dictionary_with_default`
======================== =========================================================================

.. class:: DictionaryWithDefault

    .. attribute:: dxf.default

        Handle to default entry as hex string like ``FF00``.

    .. automethod:: get

    .. automethod:: set_default


DictionaryVar
=============

======================== =========================================================================
Subclass of              :class:`ezdxf.entities.DXFObject`
DXF type                 ``'DICTIONARYVAR'``
Factory function         :meth:`ezdxf.entities.Dictionary.add_dict_var`
======================== =========================================================================

.. class:: DictionaryVar

    .. attribute:: dxf.schema

        Object schema number (currently set to 0)

    .. attribute:: dxf.value

        Value as string.

    .. autoproperty:: value

--- End of file: dxfobjects/dictionary.rst ---



--- Start of file: dxfobjects/dxflayout.rst ---

DXFLayout
=========

.. module:: ezdxf.entities
    :noindex:

`LAYOUT`_ entity is part of a modelspace or paperspace layout definitions.

======================== ===========================================================
Subclass of              :class:`ezdxf.entities.PlotSettings`
DXF type                 ``'LAYOUT'``
Factory function         internal data structure, use :class:`~ezdxf.layouts.Layouts` to
                         manage layout objects.
======================== ===========================================================

.. _LAYOUT: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-433D25BF-655D-4697-834E-C666EDFD956D


.. class:: DXFLayout

    .. attribute:: dxf.name

        Layout name as shown in tabs by :term:`CAD` applications

    .. attribute:: dxf.layout_flags

        === =========================================================================
        1   Indicates the PSLTSCALE value for this layout when this layout is current
        2   Indicates the LIMCHECK value for this layout when this layout is current
        === =========================================================================

    .. attribute:: dxf.tab_order

        default is 1

    .. attribute:: dxf.limmin

        default is Vec2(0, 0)

    .. attribute:: dxf.limmax

        default is Vec2(420, 297)

    .. attribute:: dxf.insert_base

        default is Vec3(0, 0, 0)

    .. attribute:: dxf.extmin

        default is Vec3(1e20, 1e20, 1e20)

    .. attribute:: dxf.extmax

        default is Vec3(-1e20, -1e20, -1e20)

    .. attribute:: dxf.elevation

        default is 0

    .. attribute:: dxf.ucs_origin

        default is Vec3(0, 0, 0)

    .. attribute:: dxf.ucs_xaxis

        default is Vec3(1, 0, 0)

    .. attribute:: dxf.ucs_yaxis

        default is Vec3(0, 1, 0)

    .. attribute:: dxf.ucs_type

        === =========================
        0   UCS is not orthographic
        1   Top
        2   Bottom
        3   Front
        4   Back
        5   Left
        6   Right
        === =========================

        default is 1

    .. attribute:: dxf.block_record_handle

    .. attribute:: dxf.viewport_handle

    .. attribute:: dxf.ucs_handle

    .. attribute:: dxf.base_ucs_handle


--- End of file: dxfobjects/dxflayout.rst ---



--- Start of file: dxfobjects/dxfobject.rst ---

DXFObject
=========

.. module:: ezdxf.entities
    :noindex:

Common base class for all non-graphical DXF objects.

.. class:: DXFObject

    A class hierarchy marker class and subclass of
    :class:`ezdxf.entities.DXFEntity`


--- End of file: dxfobjects/dxfobject.rst ---



--- Start of file: dxfobjects/geodata.rst ---

GeoData
=======

.. module:: ezdxf.entities
    :noindex:

The `GEODATA`_ entity is associated to the :class:`~ezdxf.layouts.Modelspace`
object. The `GEODATA`_ entity is supported since the DXF version R2000,
but was officially documented the first time in the DXF reference for version
R2009.

======================== =============================================================
Subclass of              :class:`ezdxf.entities.DXFObject`
DXF type                 ``'GEODATA'``
Factory function         :meth:`ezdxf.layouts.Modelspace.new_geodata`
Required DXF version     R2010 (``'AC1024'``)
======================== =============================================================

.. seealso::

    `geodata_setup_local_grid.py <https://github.com/mozman/ezdxf/blob/master/examples/entities/geodata_setup_local_grid.py>`_

.. warning::

    Do not instantiate object classes by yourself - always use the provided factory functions!

.. _GEODATA: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-104FE0E2-4801-4AC8-B92C-1DDF5AC7AB64

.. class:: GeoData

    .. attribute:: dxf.version

        === =========
        1   R2009
        2   R2010
        === =========

    .. attribute:: dxf.coordinate_type

        === =================================
        0   unknown
        1   local grid
        2   projected grid
        3   geographic (latitude/longitude)
        === =================================

    .. attribute:: GeoData.dxf.block_record_handle

        Handle of host BLOCK_RECORD table entry, in general the :class:`~ezdxf.layouts.Modelspace`.

    .. attribute:: dxf.design_point

        Reference point in :ref:`WCS` coordinates.

    .. attribute:: dxf.reference_point

        Reference point in geo coordinates, valid only when coordinate type is `local grid`.
        The difference between `dxf.design_point` and `dxf.reference_point` defines the translation
        from WCS coordinates to geo-coordinates.

    .. attribute:: dxf.north_direction

        North direction as 2D vector. Defines the rotation (about the `dxf.design_point`) to transform
        from WCS coordinates to geo-coordinates

    .. attribute:: dxf.horizontal_unit_scale

        Horizontal unit scale, factor which converts horizontal design coordinates to meters by multiplication.

    .. attribute:: dxf.vertical_unit_scale

        Vertical unit scale, factor which converts vertical design coordinates to meters by multiplication.

    .. attribute:: dxf.horizontal_units

        Horizontal units (see  :class:`~ezdxf.entities.BlockRecord`). Will be 0 (Unitless) if units specified
        by horizontal unit scale is not supported by AutoCAD enumeration.

    .. attribute:: dxf.vertical_units

        Vertical units (see :class:`~ezdxf.entities.BlockRecord`). Will be 0 (Unitless) if units specified by
        vertical unit scale is not supported by AutoCAD enumeration.

    .. attribute:: dxf.up_direction

        Up direction as 3D vector.

    .. attribute:: dxf.scale_estimation_method

        === ========================================
        1   none
        2   user specified scale factor
        3   grid scale at reference point
        4   prismoidal
        === ========================================

    .. attribute:: dxf.sea_level_correction

        Bool flag specifying whether to do sea level correction.

    .. attribute:: dxf.user_scale_factor

    .. attribute:: dxf.sea_level_elevation

    .. attribute:: dxf.coordinate_projection_radius

    .. attribute:: dxf.geo_rss_tag

    .. attribute:: dxf.observation_from_tag

    .. attribute:: dxf.observation_to_tag

    .. attribute:: dxf.mesh_faces_count

    .. attribute:: source_vertices

        2D source vertices in the CRS of the GeoData as :class:`~ezdxf.lldxf.packedtags.VertexArray`.
        Used together with `target_vertices` to define the transformation from the CRS of the GeoData to WGS84.

    .. attribute:: target_vertices

        2D target vertices in WGS84 (EPSG:4326) as :class:`~ezdxf.lldxf.packedtags.VertexArray`.
        Used together with `source_vertices` to define the transformation from the CRS of the geoData to WGS84.

    .. attribute:: faces

        List of face definition tuples, each face entry is a 3-tuple of vertex indices (0-based).

    .. attribute:: coordinate_system_definition

        The coordinate system definition string. Stored as XML. Defines the CRS used by the GeoData.
        The EPSG number and other details like the axis-ordering of the CRS is stored.


    .. automethod:: get_crs

    .. automethod:: get_crs_transformation

    .. automethod:: setup_local_grid(*, design_point: UVec, reference_point: UVec, north_direction: UVec = (0, 1), crs: str = EPSG_3395)



--- End of file: dxfobjects/geodata.rst ---



--- Start of file: dxfobjects/imagedef.rst ---

ImageDef
========

.. module:: ezdxf.entities
    :noindex:

The `IMAGEDEF`_ entity defines an image file, which can be placed by the :class:`Image`
entity.

======================== ===========================================================
Subclass of              :class:`ezdxf.entities.DXFObject`
DXF type                 ``'IMAGEDEF'``
Factory function (1)     :meth:`ezdxf.document.Drawing.add_image_def`
Factory function (2)     :meth:`ezdxf.sections.objects.ObjectsSection.add_image_def`
======================== ===========================================================

.. warning::

    Do not instantiate object classes by yourself - always use the provided factory functions!

.. _IMAGEDEF: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-EFE5319F-A71A-4612-9431-42B6C7C3941F


.. class:: ImageDef

    .. attribute:: dxf.class_version

        Current version is 0.

    .. attribute:: dxf.filename

        Relative (to the DXF file) or absolute path to the image file as string.

    .. attribute:: dxf.image_size

        Image size in pixel as (x, y) tuple.

    .. attribute:: dxf.pixel_size

        Default size of one pixel in drawing units as (x, y) tuple.

    .. attribute:: dxf.loaded

        0 = unloaded; 1 = loaded, default is 1

    .. attribute:: dxf.resolution_units

        === ==================
        0   No units
        2   Centimeters
        5   Inch
        === ==================

        default is 0


ImageDefReactor
===============


.. class:: ImageDefReactor

    .. attribute:: dxf.class_version

    .. attribute:: dxf.image_handle

--- End of file: dxfobjects/imagedef.rst ---



--- Start of file: dxfobjects/index.rst ---

DXF Objects
===========

All DXF objects can only reside in the OBJECTS section of a DXF document.

The purpose of the OBJECTS section is to allow CAD software developers to define and
store custom objects that are not included in the basic DXF file format. These custom
objects can be used to represent complex data structures, such as database tables or
project management information, that are not easily represented by basic DXF entities.

By including custom objects in the OBJECTS section, CAD software developers can extend
the functionality of their software to support new types of data and objects. For
example, a custom application might define a new type of block or dimension style that
is specific to a particular industry or workflow. By storing this custom object
definition in the OBJECTS section, the CAD software can recognize and use the new object
type in a drawing.

In summary, the OBJECTS section is an important part of the DXF file format because it
allows CAD software developers to extend the functionality of their software by defining
and storing custom objects and entity types. This makes it possible to represent complex
data structures and workflows in CAD drawings, and allows CAD software to be customized
to meet the specific needs of different industries and applications.

.. toctree::
    :maxdepth: 1

    dictionary
    dxflayout
    dxfobject
    geodata
    imagedef
    mleaderstyle
    placeholder
    plotsettings
    spatial_filter
    sun
    underlaydef
    xrecord


--- End of file: dxfobjects/index.rst ---



--- Start of file: dxfobjects/mleaderstyle.rst ---

MLeaderStyle
============

.. module:: ezdxf.entities
    :noindex:

The MLEADERSTYLE entity (`DXF Reference`_) stores all attributes required to
create new :class:`MultiLeader` entities. The meaning of these attributes are
not really documented in the `DXF Reference`_.
The default style "Standard" always exist.

.. seealso::

    - :class:`ezdxf.entities.MultiLeader`
    - :class:`ezdxf.render.MultiLeaderBuilder`
    - :ref:`tut_mleader`

Create a new :class:`MLeaderStyle`::

    import ezdxf

    doc = ezdxf.new()
    new_style = doc.mleader_styles.new("NewStyle")

Duplicate an existing style::

    duplicated_style = doc.mleader_styles.duplicate_entry("Standard", "DuplicatedStyle")


======================== =======================================================
Subclass of              :class:`ezdxf.entities.DXFObject`
DXF type                 ``'MLEADERSTYLE'``
Factory function         :meth:`ezdxf.document.Drawing.mleader_styles.new`
======================== =======================================================

.. class:: MLeaderStyle

    .. attribute:: dxf.align_space

        unknown meaning

    .. attribute:: dxf.arrow_head_handle

        handle of default arrow head, see also :mod:`ezdxf.render.arrows` module,
        by default no handle is set, which mean default arrow "closed filled"

    .. attribute:: dxf.arrow_head_size

        default arrow head size in drawing units, default is 4.0

    .. attribute:: dxf.block_color

        default block color as ;term:`raw color` value, default is BY_BLOCK_RAW_VALUE

    .. attribute:: dxf.block_connection_type

        === ================
        0   center extents
        1   insertion point
        === ================

    .. attribute:: dxf.block_record_handle

        handle to block record of the BLOCK content, not set by default

    .. attribute:: dxf.block_rotation

        default BLOCK rotation in radians, default is 0.0

    .. attribute:: dxf.block_scale_x

        default block x-axis scale factor, default is 1.0

    .. attribute:: dxf.block_scale_y

        default block y-axis scale factor, default is 1.0

    .. attribute:: dxf.block_scale_z

        default block z-axis scale factor, default is 1.0

    .. attribute:: dxf.break_gap_size

        default break gap size, default is 3.75

    .. attribute:: dxf.char_height

        default MTEXT char height, default is 4.0

    .. attribute:: dxf.content_type

        === =========
        0   none
        1   BLOCK
        2   MTEXT
        3   TOLERANCE
        === =========

        default is MTEXT (2)

    .. attribute:: dxf.default_text_content

        default MTEXT content as string, default is ""

    .. attribute:: dxf.dogleg_length

        default dogleg length, default is 8.0

    .. attribute:: dxf.draw_leader_order_type

        unknown meaning

    .. attribute:: dxf.draw_mleader_order_type

        unknown meaning

    .. attribute:: dxf.first_segment_angle_constraint

        angle of fist leader segment in radians, default is 0.0

    .. attribute:: dxf.has_block_rotation

    .. attribute:: dxf.has_block_scaling

    .. attribute:: dxf.has_dogleg

        default is 1

    .. attribute:: dxf.has_landing

        default is 1

    .. attribute:: dxf.is_annotative

        default is 0

    .. attribute:: dxf.landing_gap_size

        default landing gap size, default is 2.0

    .. attribute:: dxf.leader_line_color

        default leader line color as :term:`raw-color` value, default is
        BY_BLOCK_RAW_VALUE

    .. attribute:: dxf.leader_linetype_handle

        handle of default leader linetype

    .. attribute:: dxf.leader_lineweight

        default leader lineweight, default is LINEWEIGHT_BYBLOCK

    .. attribute:: dxf.leader_type

        === ====================
        0   invisible
        1   straight line leader
        2   spline leader
        === ====================

        default is 1

    .. attribute:: dxf.max_leader_segments_points

        max count of leader segments, default is 2

    .. attribute:: dxf.name

        MLEADERSTYLE name

    .. attribute:: dxf.overwrite_property_value

        unknown meaning

    .. attribute:: dxf.scale

        overall scaling factor, default is 1.0

    .. attribute:: dxf.second_segment_angle_constraint

        angle of fist leader segment in radians, default is 0.0

    .. attribute:: dxf.text_align_always_left

        use always left side to attach leaders, default is 0

    .. attribute:: dxf.text_alignment_type

        unknown meaning - its not the MTEXT attachment point!

    .. attribute:: dxf.text_angle_type

        === =======================================================
        0   text angle is equal to last leader line segment angle
        1   text is horizontal
        2   text angle is equal to last leader line segment angle, but potentially
            rotated by 180 degrees so the right side is up for readability.
        === =======================================================

        default is 1

    .. attribute:: dxf.text_attachment_direction

        defines whether the leaders attach to the left & right of the content
        BLOCK/MTEXT or attach to the top & bottom:

        === =====================================
        0   horizontal - left & right of content
        1   vertical - top & bottom of content
        === =====================================

        default is 0

    .. attribute:: dxf.text_bottom_attachment_type

        === ===============================
        9   center
        10  overline and center
        === ===============================

        default is 9

    .. attribute:: dxf.text_color

        default MTEXT color as :term:`raw-color` value, default is
        BY_BLOCK_RAW_VALUE

    .. attribute:: dxf.text_left_attachment_type

        === ========================================================
        0   top of top MTEXT line
        1   middle of top MTEXT line
        2   middle of whole MTEXT
        3   middle of bottom MTEXT line
        4   bottom of bottom MTEXT line
        5   bottom of bottom MTEXT line & underline bottom MTEXT line
        6   bottom of top MTEXT line & underline top MTEXT line
        7   bottom of top MTEXT line
        8   bottom of top MTEXT line & underline all MTEXT lines
        === ========================================================

    .. attribute:: dxf.text_right_attachment_type

        === ========================================================
        0   top of top MTEXT line
        1   middle of top MTEXT line
        2   middle of whole MTEXT
        3   middle of bottom MTEXT line
        4   bottom of bottom MTEXT line
        5   bottom of bottom MTEXT line & underline bottom MTEXT line
        6   bottom of top MTEXT line & underline top MTEXT line
        7   bottom of top MTEXT line
        8   bottom of top MTEXT line & underline all MTEXT lines
        === ========================================================

    .. attribute:: dxf.text_style_handle

        handle of the default MTEXT text style, not set by default, which means
        "Standard"

    .. attribute:: dxf.text_top_attachment_type

        === ===============================
        9   center
        10  overline and center
        === ===============================



.. _DXF Reference: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-0E489B69-17A4-4439-8505-9DCE032100B4

--- End of file: dxfobjects/mleaderstyle.rst ---



--- Start of file: dxfobjects/placeholder.rst ---

Placeholder
===========

.. module:: ezdxf.entities
    :noindex:

The `ACDBPLACEHOLDER`_ object for internal usage.

======================== =============================================================
Subclass of              :class:`ezdxf.entities.DXFObject`
DXF type                 ``'ACDBPLACEHOLDER'``
Factory function         :meth:`ezdxf.sections.objects.ObjectsSection.add_placeholder`
======================== =============================================================

.. warning::

    Do not instantiate object classes by yourself - always use the provided factory functions!

.. class:: Placeholder


.. _ACDBPLACEHOLDER: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-3BC75FF1-6139-49F4-AEBB-AE2AB4F437E4


--- End of file: dxfobjects/placeholder.rst ---



--- Start of file: dxfobjects/plotsettings.rst ---

PlotSettings
============

.. module:: ezdxf.entities
    :noindex:

All `PLOTSETTINGS`_ attributes are part of the :class:`~ezdxf.entities.DXFLayout`
entity, I don't know if this entity also appears as standalone entity.

======================== ===========================================================
Subclass of              :class:`ezdxf.entities.DXFObject`
DXF type                 ``'PLOTSETTINGS'``
Factory function         internal data structure
======================== ===========================================================

.. _PLOTSETTINGS: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-1113675E-AB07-4567-801A-310CDE0D56E9


.. class:: PlotSettings

    .. attribute:: dxf.page_setup_name

        default is ""

    .. attribute:: dxf.plot_configuration_file

        default is "Adobe PDF"

    .. attribute:: dxf.paper_size

        default is "A3"

    .. attribute:: dxf.plot_view_name

        default is ""

    .. attribute:: dxf.left_margin

        default is 7.5 mm

    .. attribute:: dxf.bottom_margin

        default is 20 mm

    .. attribute:: dxf.right_margin

        default is 7.5 mm

    .. attribute:: dxf.top_margin

        default is 20 mm

    .. attribute:: dxf.paper_width

        default is 420 mm

    .. attribute:: dxf.paper_height

        default is 297 mm

    .. attribute:: dxf.plot_origin_x_offset

        default is 0

    .. attribute:: dxf.plot_origin_y_offset

        default is 0

    .. attribute:: dxf.plot_window_x1

        default is 0

    .. attribute:: dxf.plot_window_y1

        default is 0

    .. attribute:: dxf.plot_window_x2

        default is 0

    .. attribute:: dxf.plot_window_y2

        default is 0

    .. attribute:: dxf.scale_numerator

        default is 1

    .. attribute:: dxf.scale_denominator

        default is 1

    .. attribute:: dxf.plot_layout_flags

        ======= ======================================
        1       plot viewport borders
        2       show plot-styles
        4       plot centered
        8       plot hidden == hide paperspace entities?
        16      use standard scale
        32      plot with plot-styles
        64      scale lineweights
        128     plot entity lineweights
        512     draw viewports first
        1024    model type
        2048    update paper
        4096    zoom to paper on update
        8192    initializing
        16384   prev plot-init
        ======= ======================================

        default is 688

    .. attribute:: dxf.plot_paper_units

        === =====================
        0   Plot in inches
        1   Plot in millimeters
        2   Plot in pixels
        === =====================

    .. attribute:: dxf.plot_rotation

        === =============================
        0   No rotation
        1   90 degrees counterclockwise
        2   Upside-down
        3   90 degrees clockwise
        === =============================

    .. attribute:: dxf.plot_type

        === =============================
        0   Last screen display
        1   Drawing extents
        2   Drawing limits
        3   View specified by code 6
        4   Window specified by codes 48, 49, 140, and 141
        5   Layout information
        === =============================

    .. attribute:: dxf.current_style_sheet

        default is ""

    .. attribute:: dxf.standard_scale_type

        === =============================
        0   Scaled to Fit
        1   1/128"=1'
        2   1/64"=1'
        3   1/32"=1'
        4   1/16"=1'
        5   3/32"=1'
        6   1/8"=1'
        7   3/16"=1'
        8   1/4"=1'
        9   3/8"=1'
        10  1/2"=1'
        11  3/4"=1'
        12  1"=1'
        13  3"=1'
        14  6"=1'
        15  1'=1'
        16  1:1
        17  1:2
        18  1:4
        19  1:8
        20  1:10
        21  1:16
        22  1:20
        23  1:30
        24  1:40
        25  1:50
        26  1:100
        27  2:1
        28  4:1
        29  8:1
        30  10:1
        31  100:1
        32  1000:1
        === =============================

    .. attribute:: dxf.shade_plot_mode

        === =============================
        0   As Displayed
        1   Wireframe
        2   Hidden
        3   Rendered
        === =============================

    .. attribute:: dxf.shade_plot_resolution_level

        === =============================
        0   Draft
        1   Preview
        2   Normal
        3   Presentation
        4   Maximum
        5   Custom
        === =============================

    .. attribute:: dxf.shade_plot_custom_dpi

        default is 300

    .. attribute:: dxf.unit_factor

        default is 1

    .. attribute:: dxf.paper_image_origin_x

        default is 0

    .. attribute:: dxf.paper_image_origin_y

        default is 0

    .. attribute:: dxf.shade_plot_handle


--- End of file: dxfobjects/plotsettings.rst ---



--- Start of file: dxfobjects/spatial_filter.rst ---

SpatialFilter
=============

.. module:: ezdxf.entities
    :noindex:

The `SPATIAL_FILTER`_ object stores the clipping path for external references and block 
references.  For more information about getting, setting and removing clippings paths 
read the docs for the :class:`ezdxf.xclip.XClip` class.

The HEADER variable $XCLIPFRAME determines if the clipping path is displayed and 
plotted:

=== ===========================
0   not displayed, not plotted
1   displayed, not plotted
2   displayed and plotted
=== ===========================

.. seealso::

    - :mod:`ezdxf.xclip`
    - Knowledge Graph: https://ezdxf.mozman.at/notes/#/page/spatial_filter

======================== =============================================================
Subclass of              :class:`ezdxf.entities.DXFObject`
DXF type                 ``'SPATIAL_FILTER'``
Factory function         internal data structure
======================== =============================================================

.. class:: SpatialFilter

    .. attribute:: dxf.back_clipping_plane_distance

        Defines the distance of the back clipping plane from the origin in direction of 
        the extrusion vector.

    .. attribute:: dxf.is_clipping_enabled

        Block reference clipping is enabled when 1 and disabled when 0.


    .. attribute:: dxf.extrusion

        Defines the orientation of the OCS

    .. attribute:: dxf.front_clipping_plane_distance

        Defines the distance of the front clipping plane from the origin in direction of 
        the extrusion vector.

    .. attribute:: dxf.has_back_clipping_plane

    .. attribute:: dxf.has_front_clipping_plane

    .. attribute:: dxf.origin

        Defines the origin of the OCS

    .. autoproperty:: boundary_vertices

    .. autoproperty:: inverse_insert_matrix

    .. autoproperty:: transform_matrix

    .. automethod:: set_boundary_vertices

    .. automethod:: set_inverse_insert_matrix

    .. automethod:: set_transform_matrix

.. _SPATIAL_FILTER: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-34F179D8-2030-47E4-8D49-F87B6538A05A


--- End of file: dxfobjects/spatial_filter.rst ---



--- Start of file: dxfobjects/sun.rst ---

Sun
===

.. module:: ezdxf.entities
    :noindex:

The `SUN`_ entity defines properties of the sun.

======================== ===========================================================
Subclass of              :class:`ezdxf.entities.DXFObject`
DXF type                 ``'SUN'``
Factory function         creating a new SUN entity is not supported
======================== ===========================================================


.. _SUN: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-BB191D89-9302-45E4-9904-108AB418FAE1


.. class:: Sun

    .. attribute:: dxf.version

        Current version is 1.

    .. attribute:: dxf.status

        on = 1 or off = 0

    .. attribute:: dxf.color

        :ref:`ACI` value of the sun.

    .. attribute:: dxf.true_color

        :term:`true-color` value of the sun.

    .. attribute:: dxf.intensity

        Intensity value in the range of [0, 1]. (float)

    .. attribute:: dxf.julian_day

        use :func:`~ezdxf.tools.calendardate` to convert :attr:`dxf.julian_day` to
        :class:`datetime.datetime` object.

    .. attribute:: dxf.time

        Day time in seconds past midnight. (int)

    .. attribute:: dxf.daylight_savings_time

    .. attribute:: dxf.shadows

        === =======================
        0   Sun do not cast shadows
        1   Sun do cast shadows
        === =======================

    .. attribute:: dxf.shadow_type

    .. attribute:: dxf.shadow_map_size

    .. attribute:: dxf.shadow_softness


--- End of file: dxfobjects/sun.rst ---



--- Start of file: dxfobjects/underlaydef.rst ---

UnderlayDefinition
==================

.. module:: ezdxf.entities
    :noindex:

:class:`UnderlayDefinition` (`DXF Reference`_) defines an underlay file, which can be placed by the :class:`Underlay` entity.

======================== ==============================================================
Subclass of              :class:`ezdxf.entities.DXFObject`
DXF type                 internal base class
Factory function (1)     :meth:`ezdxf.document.Drawing.add_underlay_def`
Factory function (2)     :meth:`ezdxf.sections.objects.ObjectsSection.add_underlay_def`
======================== ==============================================================

.. class:: UnderlayDefinition

   Base class of :class:`PdfDefinition`, :class:`DwfDefinition` and :class:`DgnDefinition`

    .. attribute:: dxf.filename

        Relative (to the DXF file) or absolute path to the underlay file as string.

    .. attribute:: dxf.name

        Defines which part of the underlay file to display.

        ======= ============================
        "pdf"   PDF page number
        "dgn"   always "default"
        "dwf"   ?
        ======= ============================

.. warning::

    Do not instantiate object classes by yourself - always use the provided factory functions!

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A4FF15D3-F745-4E1F-94D4-1DC3DF297B0F

PdfDefinition
-------------

======================== ==============================================================
Subclass of              :class:`ezdxf.entities.UnderlayDefinition`
DXF type                 ``'PDFDEFINITION'``
Factory function (1)     :meth:`ezdxf.document.Drawing.add_underlay_def`
Factory function (2)     :meth:`ezdxf.sections.objects.ObjectsSection.add_underlay_def`
======================== ==============================================================

.. class:: PdfDefinition

    PDF underlay file.

DwfDefinition
-------------

======================== ==============================================================
Subclass of              :class:`ezdxf.entities.UnderlayDefinition`
DXF type                 ``'DWFDEFINITION'``
Factory function (1)     :meth:`ezdxf.document.Drawing.add_underlay_def`
Factory function (2)     :meth:`ezdxf.sections.objects.ObjectsSection.add_underlay_def`
======================== ==============================================================

.. class:: DwfDefinition

    DWF underlay file.

DgnDefinition
-------------

======================== ==============================================================
Subclass of              :class:`ezdxf.entities.UnderlayDefinition`
DXF type                 ``'DGNDEFINITION'``
Factory function (1)     :meth:`ezdxf.document.Drawing.add_underlay_def`
Factory function (2)     :meth:`ezdxf.sections.objects.ObjectsSection.add_underlay_def`
======================== ==============================================================

.. class:: DgnDefinition

    DGN underlay file.



--- End of file: dxfobjects/underlaydef.rst ---



--- Start of file: dxfobjects/xrecord.rst ---

XRecord
=======

.. module:: ezdxf.entities
    :noindex:

Important class for storing application defined data in DXF files.

The `XRECORD`_ entities are used to store and manage arbitrary data. They are
composed of DXF group codes ranging from 1 through 369. This object is
similar in concept to XDATA but is not limited by size or order.

To reference a XRECORD by an DXF entity, store the handle of the XRECORD in the
XDATA section, application defined data or the :class:`ExtensionDict` of the
DXF entity.

.. seealso::

    - :ref:`extended_data`
    - :ref:`extension_dictionary`
    - :ref:`tut_custom_data`

.. _XRECORD: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-24668FAF-AE03-41AE-AFA4-276C3692827F

======================== ===========================================================
Subclass of              :class:`ezdxf.entities.DXFObject`
DXF type                 ``'XRECORD'``
Factory function         :meth:`ezdxf.sections.objects.ObjectsSection.add_xrecord`
======================== ===========================================================

.. warning::

    Do not instantiate object classes by yourself - always use the provided factory functions!

.. class:: XRecord

    .. attribute:: dxf.cloning

        Duplicate record cloning flag (determines how to merge duplicate entries, ignored by `ezdxf`):

        === ==================
        0   not applicable
        1   keep existing
        2   use clone
        3   <xref>$0$<name>
        4   $0$<name>
        5   Unmangle name
        === ==================

    .. attribute:: tags

        Raw DXF tag container :class:`~ezdxf.lldxf.tags.Tags`. Be careful `ezdxf` does not validate the content of
        XRECORDS.

    .. automethod:: clear

    .. automethod:: reset

    .. automethod:: extend


--- End of file: dxfobjects/xrecord.rst ---



--- Start of file: edgeminer.rst ---

EdgeMiner
=========

.. module:: ezdxf.edgeminer

.. versionadded:: 1.4

Purpose of this Module
----------------------

This is a helper tool to:

    - build polylines from DXF primitives like LINE, ARC, ELLIPSE, SPLINE
    - build hatch boundary paths from DXF primitives
    - find open chains or closed loops in an unordered heap of DXF primitives (edges)
    - in general: find connections between edges

What are Edges?
---------------

An edge is a linear structure with an start- and end point and an optional length.

This module is not limited to DXF primitives. Anything that can be represented by an
start- and end point can be processed. This makes this module to a versatile tool with
the disadvantage that intersections between edges are not known and cannot be calculated.

e.g. When each arc is represented by an edge, the HATCH boundary path on the left can be
found because the arcs are connected by their end points. Finding the HATCH boundary
path on the right is not possible because the intersections points of the arcs (edges)
are not known:

.. image:: gfx/em-intersections.png

How to Create Edges?
--------------------

The process of creating edges is separated from this module and is done in the
companion module :mod:`ezdxf.edgesmith`.  The :mod:`edgeminer` module doesn't really
know what an edge represents or what it looks like.

Terminology
-----------

I try to use the terminology of `Graph Theory`_ but there are differences where I think
a different term is better suited for this module like loop for cycle.

Edge
    A linear connection between two points. The shape of an edge is not known.
    Intersection points between edges are not known and cannot be calculated.

.. image:: gfx/em-edges.png

Vertex
    A connection point of two or more edges.

Degree
    The degree of a vertex is the number of connected edges.

.. image:: gfx/em-degree.png

Leaf
    A leaf is a vertex of degree 1.
    A leaf is a loose end of an edge, which is not connected to other edges.

Junction
    A junction is a vertex of degree greater 2.
    A junction has more than two adjacent edges.
    A junction is an ambiguity when searching for open chains or closed loops.
    Graph Theory: multiple adjacency

Chain
    A chain has sequential connected edges.
    The end point of an edge is connected to the start point of the following edge.
    A chain has unique edges, each edge appears only once in the chain.
    A chain can contain vertices of degree greater 2.
    A solitary edge is also a chain.
    Graph Theory: Trail - no edge is repeated, vertex is repeated

.. image:: gfx/em-chain.png

Simple Chain (special to this module)
    A simple chain contains only vertices of degree 2, except the start- and end vertex.
    The start- and end vertices are leafs (degree of 1) or junctions (degree greater 2).
    The following image shows 3 simple chains: [1-2-3], [4-5-6] and [7-8-9].
    Simple chains are easy to detect and can be replaced by a single edge and reduces so
    the search space.

.. image:: gfx/em-simple-chains.png

Open Chain
    An open chain is a chain which starts and ends with a leaf.
    A solitary edge is also an open chain.
    Graph Theory: Path - no edge is repeated, no vertex is repeated, endings not connected

Loop
    A loop is a simple chain with connected start- and end vertices.
    A loop has two or more edges.
    A loop contains only vertices of degree 2.
    Graph Theory: Cycle - no edge is repeated, no vertex is repeated, endings connected;
    a loop in Graph Theory is something different!

Network
    A network has two or more edges that are directly and indirectly connected.
    The edges in a network have no order.
    A network can contain vertices of degree greater 2 (junctions).
    A solitary edge is not a network.
    A chain with two or more edges is a network.
    Graph Theory: multigraph; a network in Graph Theory is something different!

Gap Tolerance
    Maximum vertex distance to consider two edges as connected

Forward Connection
    An edge is forward connected when the end point of the edge is connected to the
    start point of the following edge.

.. seealso::

    - :ref:`tut_edges`
    - :mod:`ezdxf.edgesmith` module

.. important::

    This is the reference documentation and not a tutorial how to use this module.

High Level Functions
--------------------

.. autofunction:: find_sequential_chain

.. autofunction:: find_all_sequential_chains

.. autofunction:: find_simple_chain

.. autofunction:: find_all_simple_chains

.. autofunction:: find_all_open_chains

.. autofunction:: find_loop

.. autofunction:: find_loop_by_edge

.. autofunction:: find_all_loops


Low Level Functions
-------------------

.. autofunction:: filter_coincident_edges

.. autofunction:: flatten

.. autofunction:: is_chain

.. autofunction:: is_forward_connected

.. autofunction:: is_loop

.. autofunction:: is_wrapped_chain

.. autofunction:: isclose

.. autofunction:: length

.. autofunction:: longest_chain

.. autofunction:: make_edge

.. autofunction:: reverse_chain

.. autofunction:: shortest_chain

.. autofunction:: subtract_edges

.. autofunction:: unwrap_simple_chain

.. autofunction:: wrap_simple_chain

Classes
-------

.. autoclass:: Edge

    .. automethod:: __eq__

    .. automethod:: __hash__

    .. automethod:: reversed

.. autoclass:: Deposit

    .. autoproperty:: edges

    .. autoproperty:: max_degree

    .. automethod:: degree_counter

    .. automethod:: degree

    .. automethod:: degrees

    .. automethod:: edges_linked_to

    .. automethod:: find_all_networks

    .. automethod:: find_leafs

    .. automethod:: find_nearest_edge

    .. automethod:: find_network

    .. automethod:: unique_vertices


.. autoclass:: TimeoutError

Global Constants
----------------

.. code-block:: Python

    GAP_TOL = 1e-9
    ABS_TOL = 1e-9
    TIMEOUT = 60.0  # in seconds


.. _Graph Theory: https://en.wikipedia.org/wiki/Glossary_of_graph_theory
.. _GeeksForGeeks: https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/?ref=shm


--- End of file: edgeminer.rst ---



--- Start of file: edgesmith.rst ---

EdgeSmith
=========

.. module:: ezdxf.edgesmith

.. versionadded:: 1.4

Purpose of this Module
----------------------

This is a companion module to the :mod:`ezdxf.edgeminer` module:

    - create :class:`~ezdxf.edgeminer.Edge` instances from DXF primitives for processing
      by the :mod:`~ezdxf.edgeminer` module:

        - :class:`~ezdxf.entities.Line`
        - :class:`~ezdxf.entities.Arc`
        - :class:`~ezdxf.entities.Ellipse`
        - :class:`~ezdxf.entities.Spline`
        - :class:`~ezdxf.entities.LWPolyline`
        - :class:`~ezdxf.entities.Polyline`

    - create :class:`~ezdxf.entities.LWPolyline` and :class:`~ezdxf.entities.Polyline`
      entities from a sequence of :class:`~ezdxf.edgeminer.Edge` objects.
    - create :class:`~ezdxf.entities.Hatch` boundary paths from a sequence of
      :class:`~ezdxf.edgeminer.Edge` objects.
    - create :class:`ezdxf.path.Path` objects from a sequence of :class:`~ezdxf.edgeminer.Edge`
      objects.

.. seealso::

    - :ref:`tut_edges`
    - :mod:`ezdxf.edgeminer` module

.. important::

    This is the reference documentation and not a tutorial how to use this module.

Make Edges
----------

This functions convert open shapes into 2D edges, closed shapes as circles, closed
arcs, closed ellipses, closed splines and closed polylines are ignored or return
``None``.

.. function:: make_edge_2d(entity: DXFEntity, *, gap_tol=GAP_TOL) -> ezdxf.edgeminer.Edge | None

    Makes an :class:`~ezdxf.edgeminer.Edge` instance from the following DXF entity types:

    - :class:`~ezdxf.entities.Line` (length accurate)
    - :class:`~ezdxf.entities.Arc` (length accurate)
    - :class:`~ezdxf.entities.Ellipse` (length approximated)
    - :class:`~ezdxf.entities.Spline` (length approximated as straight lines between
      control points)
    - :class:`~ezdxf.entities.LWPolyline` (length of bulges as straight line from
      start- to end point)
    - :class:`~ezdxf.entities.Polyline` (length of bulges as straight line from
      start- to end point)

    The start- and end points of the edge is projected onto the xy-plane. Returns
    ``None`` if the entity has a closed shape or cannot be represented as an edge.

.. autofunction:: edges_from_entities_2d

Build From Edges
----------------

ARC, LWPOLYLINE, POLYLINE and ELLIPSE entities must have an extrusion vector
of (0, 0, 1) (WCS Z-Axis). Entities with an inverted extrusion vector (0, 0, -1) will be
treated as a 3D curve and approximated by a polyline projected onto the xy-plane.
The :mod:`ezdxf.upright` module can convert such inverted extrusion vectors to (0, 0, 1).

Curve Approximation
~~~~~~~~~~~~~~~~~~~

For some target entities curves have to be approximated by polylines.
This process is also called flattening and is controlled by the parameter
:attr:`max_sagitta`. (`Wikipedia <https://en.wikipedia.org/wiki/Sagitta_(geometry)>`_)

The :attr:`max_sagitta` argument defines the maximum distance from the center of the
curve segment to the center of the line segment between two approximation points to
determine if a segment should be subdivided. The default value is -1 and uses a 1/100
of the approximated length of the curve as :attr:`max_sagitta`.

.. image:: gfx/es-max-sagitta.png

The good choice for a :attr:`max_sagitta` depends on the output resolution and is maybe
not known at the time of processing the data. E.g. for a printer/plotter a
:attr:`max_sagitta` of around 1/300 inch (300 dpi) is maybe a good choice.
The convertion from output units to drawing units depends on the scale and is the task
of the package user.

All flattened curves will be projected onto the xy-plane of the :ref:`WCS`.

.. autofunction:: lwpolyline_from_chain

.. autofunction:: polyline2d_from_chain

.. autofunction:: edge_path_from_chain

.. autofunction:: polyline_path_from_chain

.. autofunction:: path2d_from_chain

Helper Functions
----------------

.. function:: is_closed_entity(entity: DXFEntity) -> bool

    Returns ``True`` if the given entity represents a closed loop.

    Tests the following DXF entities:

        - CIRCLE
        - ARC
        - ELLIPSE
        - SPLINE
        - LWPOLYLINE
        - POLYLINE
        - HATCH
        - SOLID
        - TRACE

    Returns ``False`` for all other DXF entities.

.. function:: is_pure_2d_entity(entity: DXFEntity) -> bool

    Returns ``True`` if the given entity represents a pure 2D entity in the
    xy-plane of the :ref:`WCS`.

    - All vertices must be in the xy-plane of the :ref:`WCS`.
    - Thickness must be 0.
    - The extrusion vector must be (0, 0, 1).
    - Entities with inverted extrusions vectors (0, 0, -1) are **not** pure 2D entities.
      The :mod:`ezdxf.upright` module can be used to revert inverted extrusion vectors
      back to (0, 0, 1).

    Tests the following DXF entities:

        - LINE
        - CIRCLE
        - ARC
        - ELLIPSE
        - SPLINE
        - LWPOLYLINE
        - POLYLINE
        - HATCH
        - SOLID
        - TRACE

    Returns ``False`` for all other DXF entities.

.. autofunction:: filter_edge_entities

.. autofunction:: filter_2d_entities

.. autofunction:: filter_open_edges

.. autofunction:: bounding_box_2d

.. autofunction:: loop_area

.. autofunction:: is_inside_polygon_2d

.. autofunction:: intersecting_edges_2d

.. class:: IntersectingEdge

    NamedTuple as return type of :func:`intersecting_edges_2d`.

    .. attribute:: edge

        Intersecting edge as :class:`~ezdxf.edgeminer.Edge`; alias for field 0.

    .. attribute:: distance

        Distance from intersection point to point `p1` as float; alias for field 1.


Global Constants
----------------

.. code-block:: Python

    GAP_TOL = 1e-9
    LEN_TOL = 1e-9  # length and distance
    DEG_TOL = 1e-9  # angles in degree
    RAD_TOL = 1e-7  # angles in radians


--- End of file: edgesmith.rst ---



--- Start of file: enums.rst ---


.. module:: ezdxf.enums

TextEntityAlignment
-------------------

.. autoclass:: TextEntityAlignment

    .. attribute:: LEFT

    .. attribute:: CENTER

    .. attribute:: RIGHT

    .. attribute:: ALIGNED

    .. attribute:: MIDDLE

    .. attribute:: FIT

    .. attribute:: BOTTOM_LEFT

    .. attribute:: BOTTOM_CENTER

    .. attribute:: BOTTOM_RIGHT

    .. attribute:: MIDDLE_LEFT

    .. attribute:: MIDDLE_CENTER

    .. attribute:: MIDDLE_RIGHT

    .. attribute:: TOP_LEFT

    .. attribute:: TOP_CENTER

    .. attribute:: TOP_RIGHT

MTextEntityAlignment
--------------------

.. autoclass:: MTextEntityAlignment

    .. attribute:: TOP_LEFT

    .. attribute:: TOP_CENTER

    .. attribute:: TOP_RIGHT

    .. attribute:: MIDDLE_LEFT

    .. attribute:: MIDDLE_CENTER

    .. attribute:: MIDDLE_RIGHT

    .. attribute:: BOTTOM_LEFT

    .. attribute:: BOTTOM_CENTER

    .. attribute:: BOTTOM_RIGHT

MTextParagraphAlignment
-----------------------

.. autoclass:: MTextParagraphAlignment

    .. attribute:: DEFAULT

    .. attribute:: LEFT

    .. attribute:: RIGHT

    .. attribute:: CENTER

    .. attribute:: JUSTIFIED

    .. attribute:: DISTRIBUTED

MTextFlowDirection
------------------

.. autoclass:: MTextFlowDirection

    .. attribute:: LEFT_TO_RIGHT

    .. attribute:: TOP_TO_BOTTOM

    .. attribute:: BY_STYLE

MTextLineAlignment
------------------

.. autoclass:: MTextLineAlignment

    .. attribute:: BOTTOM

    .. attribute:: MIDDLE

    .. attribute:: TOP

MTextStroke
-----------

.. autoclass:: MTextStroke

    .. attribute:: UNDERLINE

    .. attribute:: STRIKE_THROUGH

    .. attribute:: OVERLINE

MTextLineSpacing
----------------

.. autoclass:: MTextLineSpacing

    .. attribute:: AT_LEAST

    .. attribute:: EXACT

MTextBackgroundColor
--------------------

.. autoclass:: MTextBackgroundColor

    .. attribute:: OFF

    .. attribute:: COLOR

    .. attribute:: WINDOW

    .. attribute:: CANVAS

InsertUnits
-----------

.. autoclass:: InsertUnits

    .. attribute:: Unitless

    .. attribute:: Inches

    .. attribute:: Feet

    .. attribute:: Miles

    .. attribute:: Millimeters

    .. attribute:: Centimeters

    .. attribute:: Meters

    .. attribute:: Kilometers

    .. attribute:: Microinches

    .. attribute:: Mils

    .. attribute:: Yards

    .. attribute:: Angstroms

    .. attribute:: Nanometers

    .. attribute:: Microns

    .. attribute:: Decimeters

    .. attribute:: Decameters

    .. attribute:: Hectometers

    .. attribute:: Gigameters

    .. attribute:: AstronomicalUnits

    .. attribute:: Lightyears

    .. attribute:: Parsecs

    .. attribute:: USSurveyFeet

    .. attribute:: USSurveyInch

    .. attribute:: USSurveyYard

    .. attribute:: USSurveyMile

Measurement
-----------

.. autoclass:: Measurement

    .. attribute:: Imperial

    .. attribute:: Metric

LengthUnits
-----------

.. autoclass:: LengthUnits

    .. attribute:: Scientific

    .. attribute:: Decimal

    .. attribute:: Engineering

    .. attribute:: Architectural

    .. attribute:: Fractional

AngularUnits
------------

.. autoclass:: AngularUnits

    .. attribute:: DecimalDegrees

    .. attribute:: DegreesMinutesSeconds

    .. attribute:: Grad

    .. attribute:: Radians

SortEntities
------------

.. autoclass:: SortEntities

    .. attribute:: DISABLE

    .. attribute:: SELECTION

        Sorts for object selection

    .. attribute:: SNAP

        Sorts for object snap

    .. attribute:: REDRAW

        Sorts for redraws; obsolete

    .. attribute:: MSLIDE

        Sorts for MSLIDE command slide creation; obsolete

    .. attribute:: REGEN

        Sorts for REGEN commands

    .. attribute:: PLOT

        Sorts for plotting

    .. attribute:: POSTSCRIPT

        Sorts for PostScript output; obsolete

ACI
---

.. autoclass:: ACI

    .. attribute:: BYBLOCK

    .. attribute:: BYLAYER

    .. attribute:: BYOBJECT

    .. attribute:: RED

    .. attribute:: YELLOW

    .. attribute:: GREEN

    .. attribute:: CYAN

    .. attribute:: BLUE

    .. attribute:: MAGENTA

    .. attribute:: BLACK

    .. attribute:: WHITE

    .. attribute:: GRAY

    .. attribute:: LIGHT_GRAY

EndCaps
-------

.. autoclass:: EndCaps

    .. attribute:: NONE

    .. attribute:: ROUND

    .. attribute:: ANGLE

    .. attribute:: SQUARE

JoinStyle
---------

.. autoclass:: JoinStyle

    .. attribute:: NONE

    .. attribute:: ROUND

    .. attribute:: ANGLE

    .. attribute:: FLAT



--- End of file: enums.rst ---



--- Start of file: faq.rst ---

.. _faq:

FAQ
===

These are the old FAQ until late 2023, new FAQs will only be added to the 
:ref:`Knowledge_Graph`.

.. _faq001:

What is the Relationship between ezdxf, dxfwrite and dxfgrabber?
----------------------------------------------------------------

In 2010 I started my first Python package for creating DXF documents called `dxfwrite`,
this package can't read DXF files and writes only the DXF R12 (AC1009) version.
While `dxfwrite` works fine, I wanted a more versatile package, that can read
and write DXF files and maybe also supports newer DXF formats than DXF R12.

This was the start of the `ezdxf` package in 2011, but the progress was so slow,
that I created a spin off in 2012 called `dxfgrabber`, which implements only the
reading part of `ezdxf`, which I needed for my work and I wasn't sure if `ezdxf`
will ever be usable. Luckily in 2014 the first usable version of `ezdxf` could
be released. The `ezdxf` package has all the features of `dxfwrite` and
`dxfgrabber` and much more, but with a different API. So `ezdxf` is not a
drop-in replacement for `dxfgrabber` or `dxfwrite`.

Since `ezdxf` can do all the things that `dxfwrite` and `dxfgrabber` can do, I
focused on the development of `ezdxf`, `dxfwrite` and `dxfgrabber` are in
maintenance-only mode and will not get any new features, just bugfixes.

There are no advantages of `dxfwrite` over `ezdxf`, `dxfwrite` has a smaller
memory footprint, but the :mod:`r12writer` add-on does the same job as
`dxfwrite` without any in-memory structures by writing direct to a stream
or file and there is also no advantage of `dxfgrabber` over `ezdxf` for ordinary
DXF files, the smaller memory footprint of `dxfgrabber` is not noticeable and
for really big files the :mod:`iterdxf` add-on does a better job.

.. _faq002:

Imported ezdxf package has no content. (readfile, new)
------------------------------------------------------

1. AttributeError: partially initialized module 'ezdxf' has no attribute 'readfile'
   (most likely due to a circular import)

   Did you name your file/script "ezdxf.py"? This causes problems with
   circular imports. Renaming your file/script should solve this issue.

2. AttributeError: module 'ezdxf' has no attribute 'readfile'

   This could be a hidden permission error, for more information about this issue
   read Petr Zemeks article: https://blog.petrzemek.net/2020/11/17/when-you-import-a-python-package-and-it-is-empty/

.. _faq003:

How to add/edit ACIS based entities like 3DSOLID, REGION or SURFACE?
--------------------------------------------------------------------

The BODY, 3DSOLID, SURFACE, REGION and so on, are stored as ACIS data embedded
in the DXF file. The ACIS data is stored as SAT (text) format in the entity
itself for DXF R2000-R2010 and as SAB (binary) format in the
ACDSDATA section for DXF R2013+. `Ezdxf` can read SAT and SAB data, but
only write SAT data.

The ACIS data is a proprietary format from `Spatial Inc.`_, and there exist no
free available documentation or open source libraries to create or edit SAT or
SAB data, and also `ezdxf` provides no functionality for creating or editing
ACIS data.

The ACIS support provided by `ezdxf` is only useful for users which have
access to the ACIS SDK from `Spatial Inc.`_.

.. _Spatial Inc.: https://www.spatial.com/products/3d-acis-modeling

.. _faq004:

Are OLE/OLE2 entities supported?
--------------------------------

TLDR; NO!

The Wikipedia definition of `OLE`_: Object Linking & Embedding (OLE) is a proprietary
technology developed by Microsoft that allows embedding and linking to documents
and other objects. For developers, it brought OLE Control Extension (OCX), a
way to develop and use custom user interface elements. On a technical level, an
OLE object is any object that implements the ``IOleObject`` interface, possibly
along with a wide range of other interfaces, depending on the object's needs.

Therefore `ezdxf` does not support this entities in any way, this only
work on Windows and with the required editing application installed.
The binary data stored in the OLE objects cannot be used without the
editing application.

In my opinion, using OLE objects in a CAD drawing is a very bad design decision
that can and will cause problems opening these files in the future, even in
AutoCAD on Windows when the required editing application is no longer available
or the underlying technology is no longer supported.

All of this is unacceptable for a data storage format that should be accessed
for many years or decades (e.g. construction drawings for buildings or bridges).

Rendering SHX fonts
-------------------

The SHX font format is not documented nor supported by many libraries/packages
like `Matplotlib` and `Qt`, therefore only SHX fonts which have corresponding
TTF-fonts can be rendered by these backends. See also how-tos about
:ref:`howto_fonts`

Drawing Add-on
--------------

There is a dedicated how-to section for the :ref:`how_to_drawing_addon`.

Is the AutoCAD command XYZ available?
-------------------------------------

TLDR; Would you expect Photoshop features from a JPG library?

The package is designed as an interface to the DXF format and therefore does not offer
any advanced features of interactive CAD applications. First, some tasks are difficult
to perform without human guidance, and second, in complex situations, it's not that easy
to tell a "headless" system what exactly to do, so it's very likely that not many users
would ever use these features, despite the fact that a lot of time and effort would have
to be spent on development, testing and long-term support.

Recognize New Installed Fonts
-----------------------------

    - `Knowledge Graph <https://ezdxf.mozman.at/notes/#/page/recognize%20new%20installed%20fonts>`_

Why are ARC coordinates wrong?
------------------------------

    - `Knowledge Graph <https://ezdxf.mozman.at/notes/#/page/why%20are%20arc%20coordinates%20wrong%3F>`_
    - `Github FAQ #1266 <https://github.com/mozman/ezdxf/discussions/1266>`_

.. _OLE: https://en.wikipedia.org/wiki/Object_Linking_and_Embedding

--- End of file: faq.rst ---



--- Start of file: glossary.rst ---

Glossary
========

.. glossary::

    ACI
        :ref:`ACI`

    ACIS
        The 3D ACIS Modeler (`ACIS`_) is a geometric modeling kernel developed
        by `Spatial Corp.`_  (formerly `Spatial Technology`) and now part of
        `Dassault Systems`. All ACIS based DXF entities store their geometry as
        :term:`SAT` or :term:`SAB` data. These are not open data formats and
        a license has to be purchased to get access to their SDK, therefore
        `ezdxf` can not provide any support for creating, processing or transforming
        of ACIS based DXF entities.

    bulge
        The :ref:`bulge value` is used to create arc shaped line segments in
        :class:`~ezdxf.entities.Polyline` and :class:`~ezdxf.entities.LWPolyline`
        entities.

    CAD
        Computer-Assisted Drafting or Computer-Aided Design

    CTB
        Color dependent plot style table (:class:`~ezdxf.acadctb.ColorDependentPlotStyles`)

    DWG
        Proprietary file format of `AutoCAD`_ . Documentation for this format
        is available from the Open Design Alliance (`ODA`_) at their `Downloads`_
        section. This documentation is created by reverse engineering therefore
        not perfect nor complete.

    DXF
        Drawing eXchange Format is a file format used by `AutoCAD`_  to
        interchange data with other :term:`CAD` applications. `DXF`_ is a
        trademark of `Autodesk`_ . See also :ref:`what is dxf`

    proxy-graphic
        The proxy-graphic is an internal data format to add a graphical
        representation to DXF entities which are unknown (custom DXF entities),
        not documented or very complex so CAD applications can display them
        without knowledge about the internal structure of these entities.

    raw-color
        Raw color value as stored in DWG files, this integer value can
        represent :term:`ACI` values as well as and :term:`true-color` values

    reliable CAD application
        CAD applications which create valid DXF documents in the meaning and
        interpretation of `Autodesk`_. See also :ref:`what is dxf`

    SAB
        ACIS file format (Standard ACIS Binary), binary stored data

    SAT
        ACIS file format (Standard ACIS Text), data stored as ASCII text

    STB
        Named plot style table (:class:`~ezdxf.acadctb.NamedPlotStyles`)

    true-color
        RGB color representation, a combination red, green and blue values to
        define a color.


.. (R) = Atl+0174

.. _Autodesk: https://www.autodesk.com/

.. _AutoCAD: https://www.autodesk.com/products/autocad/overview

.. _DXF: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-235B22E0-A567-4CF6-92D3-38A2306D73F3

.. _Spatial Corp.: http://www.spatial.com/products/3d-acis-modeling

.. _ACIS: https://en.wikipedia.org/wiki/ACIS

.. _ODA: https://www.opendesign.com/

.. _downloads: https://www.opendesign.com/guestfiles

--- End of file: glossary.rst ---



--- Start of file: groups.rst ---

Groups
======

.. module:: ezdxf.entities.dxfgroups


A group is just a bunch of DXF entities tied together. All entities of a group
has to be in the same layout (modelspace or any paperspace layout but not block).
Groups can be named or unnamed, but in reality an unnamed groups has just a
special name like "\*Annnn". The name of a group has to be unique in the drawing.
Groups are organized in the group table, which is stored as attribute
:attr:`~ezdxf.document.Drawing.groups` in the :class:`~ezdxf.document.Drawing`
object.

.. important::

    Group entities have to reside in the modelspace or an paperspace layout but not in a
    block definition!

DXFGroup
--------

.. class:: DXFGroup

    The group name is not stored in the GROUP entity, it is stored in the
    :class:`GroupCollection` object.

    .. attribute:: dxf.description

        group description (string)

    .. attribute:: dxf.unnamed

        1 for unnamed, 0 for named group (int)

    .. attribute:: dxf.selectable

        1 for selectable, 0 for not selectable group (int)

    .. automethod:: __iter__

    .. automethod:: __len__

    .. automethod:: __getitem__

    .. automethod:: __contains__

    .. automethod:: handles

    .. automethod:: edit_data

    .. automethod:: set_data

    .. automethod:: extend

    .. automethod:: clear

    .. automethod:: audit

GroupCollection
---------------

Each :class:`~ezdxf.document.Drawing` has one group table, which is accessible
by the attribute :attr:`~ezdxf.document.Drawing.groups`.

.. class:: GroupCollection

    Manages all :class:`DXFGroup` objects of a :class:`~ezdxf.document.Drawing`.

    .. method:: __len__

        Returns the count of DXF groups.

    .. method:: __iter__

        Iterate over all existing groups as (`name`, `group`) tuples. `name` is
        the name of the group as string and `group` is an :class:`DXFGroup`
        object.

    .. method:: __contains__

        Returns ``True`` if a group `name` exist.

    .. method:: get(name: str) -> DXFGroup

        Returns the group `name`. Raises :class:`DXFKeyError` if group `name`
        does not exist.

    .. automethod:: groups

    .. automethod:: new

    .. automethod:: delete

    .. method:: clear

       Delete all groups.

    .. automethod:: audit

--- End of file: groups.rst ---



--- Start of file: howto/content.rst ---

DXF Content
===========

General preconditions:

.. code-block:: python

    import sys
    import ezdxf

    try:
        doc = ezdxf.readfile("your_dxf_file.dxf")
    except IOError:
        print(f'Not a DXF file or a generic I/O error.')
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f'Invalid or corrupted DXF file.')
        sys.exit(2)
    msp = doc.modelspace()


.. _howto_get_color:

Get/Set Entity Color
--------------------

The entity color is stored as :term:`ACI` (AutoCAD Color Index):

.. code-block:: python

    aci = entity.dxf.color

Default value is 256 which means BYLAYER:

.. code-block:: python

    layer = doc.layers.get(entity.dxf.layer)
    aci = layer.get_color()

The special :meth:`~ezdxf.entities.Layer.get_color` method is required, because
the color attribute :attr:`Layer.dxf.color` is misused as layer on/off flag, a
negative color value means the layer is off.

ACI value 0 means BYBLOCK, which means the color from the block reference
(INSERT entity).

Set color as ACI value as int in range [0, 256]:

.. code-block:: python

    entity.dxf.color = 1


The ACI value 7 has a special meaning, it is white on dark backgrounds and white
on light backgrounds.

.. _howto_get_entity_rgb_color:

Get/Set Entity RGB Color
------------------------

RGB true color values are supported since DXF R13 (AC1012), the 24-bit RGB value
is stored as integer in the DXF attribute :attr:`~ezdxf.entities.DXFGraphic.dxf.true_color`:

.. code-block:: python

    # 24 bit binary value: 0bRRRRRRRRGGGGGGGGBBBBBBBB or hex value: 0xRRGGBB
    # set true color value to red
    entity.dxf.true_color = 0xFF0000

Use the helper functions from the :mod:`ezdxf.colors` module for
RGB integer value handling:

.. code-block:: python

    from ezdxf import colors

    entity.dxf.true_color = colors.rgb2int((0xFF, 0, 0))
    r, g, b = colors.int2rgb(entity.dxf.true_color)

The RGB values of the AutoCAD default colors are not officially documented,
but an accurate translation table is included in `ezdxf`:

.. code-block:: python

    # Warning: ACI value 256 (BYLAYER) raises an IndexError!
    rgb24 = colors.DXF_DEFAULT_COLORS[aci]
    print(f"RGB Hex Value: #{rgb24:06X}")
    r, g, b = colors.int2rgb(rgb24)
    print(f"RGB Channel Values: R={r:02X} G={g:02X} b={b:02X}")

If :attr:`color` and :attr:`true_color` values are set, BricsCAD and AutoCAD use
the :attr:`true_color` value as display color for the entity.

Get/Set True Color as RGB-Tuple
-------------------------------

Get/Set the true color value as (r, g, b)-tuple by the
:attr:`~ezdxf.entities.DXFGraphic.rgb` property of the
:class:`~ezdxf.entities.DXFGraphic` entity:

.. code-block:: python

    # set true color value to red
    entity.rgb = (0xFF, 0, 0)

    # get true color values
    r, g, b = entity.rgb

.. _howto_get_attribs:

Get/Set Block Reference Attributes
----------------------------------

Block references (:class:`~ezdxf.entities.Insert`) can have attached attributes (:class:`~ezdxf.entities.Attrib`),
these are simple text annotations with an associated tag appended to the block reference.

Iterate over all appended attributes:

.. code-block:: python

    # get all INSERT entities with entity.dxf.name == "Part12"
    blockrefs = msp.query('INSERT[name=="Part12"]')
    if len(blockrefs):
        entity = blockrefs[0]  # process first entity found
        for attrib in entity.attribs:
            if attrib.dxf.tag == "diameter":  # identify attribute by tag
                attrib.dxf.text = "17mm"  # change attribute content

Get attribute by tag:

.. code-block:: python

    diameter = entity.get_attrib('diameter')
    if diameter is not None:
        diameter.dxf.text = "17mm"


Adding XDATA to Entities
------------------------

Adding XDATA as list of tuples (group code, value) by :meth:`~ezdxf.entities.DXFEntity.set_xdata`, overwrites
data if already present:

.. code-block:: python

    doc.appids.new('YOUR_APPID')  # IMPORTANT: create an APP ID entry

    circle = msp.add_circle((10, 10), 100)
    circle.set_xdata(
        'YOUR_APPID',
        [
            (1000, 'your_web_link.org'),
            (1002, '{'),
            (1000, 'some text'),
            (1002, '{'),
            (1071, 1),
            (1002, '}'),
            (1002, '}')
        ])

For group code meaning see DXF reference section `DXF Group Codes in Numerical Order Reference`_, valid group codes are
in the range 1000 - 1071.

Method :meth:`~ezdxf.entities.DXFEntity.get_xdata` returns the extended data for an entity as
:class:`~ezdxf.lldxf.tags.Tags` object.

.. seealso::

    Tutorial: :ref:`tut_custom_data`

Get Overridden DIMSTYLE Values from DIMENSION
---------------------------------------------

In general the :class:`~ezdxf.entities.Dimension` styling and config attributes are stored in the
:class:`~ezdxf.entities.Dimstyle` entity, but every attribute can be overridden for each DIMENSION
entity individually, get overwritten values by the :class:`~ezdxf.entities.DimstyleOverride` object
as shown in the following example:

.. code-block:: python

    for dimension in msp.query('DIMENSION'):
        dimstyle_override = dimension.override()  # requires v0.12
        dimtol = dimstyle_override['dimtol']
        if dimtol:
            print(f'{str(dimension)} has tolerance values:')
            dimtp = dimstyle_override['dimtp']
            dimtm = dimstyle_override['dimtm']
            print(f'Upper tolerance: {dimtp}')
            print(f'Lower tolerance: {dimtm}')

The :class:`~ezdxf.entities.DimstyleOverride` object returns the value of the underlying DIMSTYLE objects if the
value in DIMENSION was not overwritten, or ``None`` if the value was neither defined in DIMSTYLE nor in DIMENSION.

Override DIMSTYLE Values for DIMENSION
--------------------------------------

Same as above, the :class:`~ezdxf.entities.DimstyleOverride` object supports also overriding DIMSTYLE values.
But just overriding this values have no effect on the graphical representation of the DIMENSION entity, because
CAD applications just show the associated anonymous block which contains the graphical representation on the
DIMENSION entity as simple DXF entities. Call the :class:`~ezdxf.entities.DimstyleOverride.render` method of the
:class:`~ezdxf.entities.DimstyleOverride` object to recreate this graphical representation by `ezdxf`, but `ezdxf`
**does not** support all DIMENSION types and DIMVARS yet, and results **will differ** from AutoCAD
or BricsCAD renderings.

.. code-block:: python

    dimstyle_override = dimension.override()
    dimstyle_override.set_tolerance(0.1)

    # delete associated geometry block
    del doc.blocks[dimension.dxf.geometry]

    # recreate geometry block
    dimstyle_override.render()

How to Change the HATCH Pattern Origin Point
--------------------------------------------

This code sets the origin of the first pattern line to the given `origin` and
the origins of all remaining pattern lines relative to the first pattern line
origin.

.. code-block:: python

    from ezdxf.entities import Hatch, Pattern
    from ezdxf.math import Vec2

    def shift_pattern_origin(hatch: Hatch, offset: Vec2):
        if isinstance(hatch.pattern, Pattern):
            for pattern_line in hatch.pattern.lines:
                pattern_line.base_point += offset

    def reset_pattern_origin_of_first_pattern_line(hatch: Hatch, origin: Vec2):
        if isinstance(hatch.pattern, Pattern) and len(hatch.pattern.lines):
            first_pattern_line = hatch.pattern.lines[0]
            offset = origin - first_pattern_line.base_point
            shift_pattern_origin(hatch, offset)

.. seealso::

    - Discussion `#769 <https://github.com/mozman/ezdxf/discussions/769>`_

How to Get the Length of a Spline or Polyline
---------------------------------------------

There exist no analytical function to calculate the length of a `B-spline`_, you
have to approximate the curve and calculate the length of the polyline.
The construction tool :class:`ezdxf.math.ConstructionPolyline` is may be useful
for that.

.. code-block:: python

    import ezdxf
    from ezdxf.math import ConstructionPolyline

    doc = ezdxf.new()
    msp = doc.modelspace()
    fit_points = [(0, 0, 0), (750, 500, 0), (1750, 500, 0), (2250, 1250, 0)]

    spline = msp.add_spline(fit_points)
    # Adjust the max. sagitta distance to your needs or run the calculation in a loop
    # reducing the distance until the difference to the previous run is smaller
    # than your expected precision:
    polyline = ConstructionPolyline(spline.flattening(distance=0.1))
    print(f"approximated length = {polyline.length:.2f}")

How to Resolve DXF Properties
-----------------------------

Graphical properties of DXF entities (color, lineweight, ...) are sometimes
hard to resolve because of the complex possibilities to inherit properties from
layers or blocks, or overriding them by :term:`ctb` files.

The :mod:`~ezdxf.addons.drawing` add-on provides the
:class:`~ezdxf.addons.drawing.properties.RenderContext` class that can be used
to resolve properties of entities in the context of their use:

.. code-block:: python

    import ezdxf
    from ezdxf.addons.drawing.properties import RenderContext

    doc = ezdxf.new()
    doc.layers.add("LINE", color=ezdxf.colors.RED)
    msp = doc.modelspace()
    line = msp.add_line((0, 0), (1, 0), dxfattribs={"layer": "LINE"})

    ctx = RenderContext(doc)
    ctx.set_current_layout(msp)
    print(f"resolved RGB value: {ctx.resolve_color(line)}")

Output::

    resolved RGB value: #ff0000

This works in most simple cases, resolving properties of objects in viewports or
nested blocks requires additional information that is beyond the scope of a
simple guide.

How to Find XREF Definitions
----------------------------

XREFs are normal block definitions and can be found in the BLOCKS section:

.. code-block:: Python

    for block_layout in doc.blocks:
        block = block_layout.block  # the BLOCK entity
        if block.is_xref:
            handle_xref(block_layout)
        elif block.is_xref_overlay:
            handle_xref_overlay(block_layout)

.. seealso::

    - documentation of the :mod:`ezdxf.xref` module
    - :class:`ezdxf.layouts.BlockLayout`

How to Find XREF References
---------------------------

An XREF reference is a block reference (INSERT entity) to the block definition of
the XREF:

.. code-block:: Python

    for insert in msp.query("INSERT"):
        if insert.is_xref:
            handle_xref_reference(insert)
            # ... or get the XREF definition
            block_layout = insert.block()
            if block_layout is not None:
                block = block_layout.block
                if block.is_xref:
                    handle_xref(block_layout)
                elif block.is_xref_overlay:
                    handle_xref_overlay(block_layout)

Like any normal block, an XREF can be inserted multiple times.

.. seealso::

    - documentation of the :mod:`ezdxf.xref` module
    - :class:`ezdxf.layouts.BlockLayout`

.. _DXF Group Codes in Numerical Order Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-3F0380A5-1C15-464D-BC66-2C5F094BCFB9
.. _B-spline: https://en.wikipedia.org/wiki/B-spline

--- End of file: howto/content.rst ---



--- Start of file: howto/document.rst ---

General Document
================


General preconditions:

.. code-block:: python

    import sys
    import ezdxf

    try:
        doc = ezdxf.readfile("your_dxf_file.dxf")
    except IOError:
        print(f"Not a DXF file or a generic I/O error.")
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f"Invalid or corrupted DXF file.")
        sys.exit(2)
    msp = doc.modelspace()

This works well with DXF files from trusted sources like AutoCAD or BricsCAD,
for loading DXF files with minor or major flaws look at the
:mod:`ezdxf.recover` module.

Load DXF Files with Structure Errors
------------------------------------

If you know the files you will process have most likely minor or major flaws,
use the :mod:`ezdxf.recover` module:

.. code-block:: Python

    import sys
    from ezdxf import recover

    try:  # low level structure repair:
        doc, auditor = recover.readfile(name)
    except IOError:
        print(f"Not a DXF file or a generic I/O error.")
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f"Invalid or corrupted DXF file: {name}.")
        sys.exit(2)

    # DXF file can still have unrecoverable errors, but this is maybe
    # just a problem when saving the recovered DXF file.
    if auditor.has_errors:
        print(f"Found unrecoverable errors in DXF file: {name}.")
        auditor.print_error_report()

For more loading scenarios follow the link: :mod:`ezdxf.recover`

.. _set/get header variables:

Set/Get Header Variables
------------------------

`ezdxf` has an interface to get and set HEADER variables:

.. code-block:: python

    doc.header["VarName"] = value
    value = doc.header["VarName"]

.. seealso::

    :class:`~ezdxf.sections.header.HeaderSection` and online documentation from Autodesk 
    for available `header variables`_.

.. _set drawing units:

Set DXF Drawing Units
---------------------

The header variable $INSUNITS defines the drawing units for the modelspace and
therefore for the DXF document if no further settings are applied. The most
common units are 6 for meters and 1 for inches.

Use this HEADER variables to setup the default units for CAD applications
opening the DXF file. This setting is not relevant for `ezdxf` API calls,
which are unitless for length values and coordinates and decimal degrees for
angles (in most cases).

Sets drawing units:

.. code-block:: python


    doc.header["$INSUNITS"] = 6

For more information see section :ref:`DXF Units`.

Explore the DXF File Structure
------------------------------

DXF files are plain text files, you can open this files with every text editor
which handles bigger files. But it is not really easy to get quick the
information you want.

Use the DXF structure browser:

.. code-block::

    # Call as executable script from the command line:
    ezdxf browse FILE

    # Call as module on Windows:
    py -m ezdxf browse FILE

    # Call as module on Linux/Mac
    python3 -m ezdxf browse FILE

This command requires `PySide6` or `PyQt5` to be installed. It opens a desktop window 
with a selection panel for all DXF entities in the document, and handles int the entity 
view are links between DXF entities, this simplifies the navigation between the DXF 
entities. Read the docs for the :ref:`browse_command` command for more information.

.. figure:: ../gfx/gear-browse.png

.. _calc msp extents:

Calculate Extents for the Modelspace
------------------------------------

Since `ezdxf` v0.16 exist a :mod:`ezdxf.bbox` module to calculate bounding
boxes for DXF entities. This module makes the extents calculation very easy,
but read the documentation for the :mod:`~ezdxf.bbox` module to understand its
limitations.

.. code-block:: Python

    import ezdxf
    from ezdxf import bbox

    doc = ezdxf.readfile("your.dxf")
    msp = doc.modelspace()

    extents = bbox.extents(msp)


The returned `extents` is a :class:`ezdxf.math.BoundingBox` object.

.. _set msp initial view:

Set Initial View/Zoom for the Modelspace
----------------------------------------

To show an arbitrary location of the modelspace centered in the CAD application
window, set the ``'*Active'`` VPORT to this location. The DXF attribute
:attr:`dxf.center` defines the location in the modelspace, and the :attr:`dxf.height`
specifies the area of the modelspace to view. Shortcut function:

.. code-block:: Python

    doc.set_modelspace_vport(height=10, center=(10, 10))

.. seealso::

    The :mod:`ezdxf.zoom` module is another way to set the initial modelspace
    view.

Setting the initial view to the extents of all entities in the modelspace:

.. code-block:: Python

    import ezdxf
    from ezdxf import zoom

    doc = ezdxf.readfile("your.dxf")
    msp = doc.modelspace()
    zoom.extents(msp)

Setting the initial view to the extents of just some entities:

.. code-block:: Python

    lines = msp.query("LINES")
    zoom.objects(lines)

The :mod:`~ezdxf.zoom` module also works for paperspace layouts.

.. Important::

    The :mod:`~ezdxf.zoom` module uses the :mod:`~ezdxf.bbox` module to
    calculate the bounding boxes for DXF entities. Read the documentation for
    the :mod:`~ezdxf.bbox` module to understand its limitations and the
    bounding box calculation for large documents can take a while!

Hide the UCS Icon
-----------------

The visibility of the UCS icon is controlled by the DXF
:attr:`~ezdxf.entities.VPort.dxf.ucs_icon` attribute of the
:class:`~ezdxf.entities.VPort` entity:

    - bit 0: 0=hide, 1=show
    - bit 1: 0=display in lower left corner, 1=display at origin

The state of the UCS icon can be set in conjunction with the initial
:class:`~ezdxf.entities.VPort` of the model space, this code turns off the UCS
icon:

.. code-block:: Python

    doc.set_modelspace_vport(10, center=(10, 10), dxfattribs={"ucs_icon": 0})

Alternative: turn off UCS icons for all :class:`VPort` entries in the active
viewport configuration:

.. code-block:: Python

    for vport in doc.viewports.get_config("*Active"):
        vport.dxf.ucs_icon = 0

Show Lineweights in DXF Viewers
-------------------------------

By default lines and curves are shown without lineweights in DXF viewers.
By setting the header variable $LWDISPLAY to 1 the DXF viewer should display
lineweights, if supported by the viewer.

.. code-block:: Python

    doc.header["$LWDISPLAY"] = 1

Add `ezdxf` Resources to Existing DXF Document
----------------------------------------------

Add all `ezdxf` specific resources (line types, text- and dimension styles)
to an existing DXF document:

.. code-block:: Python

    import ezdxf
    from ezdxf.tools.standards import setup_drawing

    doc = ezdxf.readfile("your.dxf")
    setup_drawing(doc, topics="all")

Set Logging Level of `ezdxf`
----------------------------

Set the logging level of the `ezdxf` package to a higher level to minimize
logging messages from ezdxf. At level ``ERROR`` only severe errors will be
logged and ``WARNING``, ``INFO`` and ``DEBUG`` messages will be suppressed:

.. code-block:: Python

    import logging

    logging.getLogger("ezdxf").setLevel(logging.ERROR)


.. _header variables: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A85E8E67-27CD-4C59-BE61-4DC9FADBE74A

--- End of file: howto/document.rst ---



--- Start of file: howto/drawing-addon.rst ---

.. _how_to_drawing_addon:

Drawing Add-on
==============

This section consolidates the `FAQ`_ about the drawing add-on from the github
forum.

All Backends
------------

.. _how_to_set_bg_and_fg_colors:

How to Set Background and Foreground Colors
+++++++++++++++++++++++++++++++++++++++++++

Override the default background and foreground colors.  The foreground color is
the :ref:`ACI` 7, which is white/black depending on the background color.
If the foreground color is not specified, the foreground color is white for dark
backgrounds and black for light backgrounds.  The required color format is
a hex string "#RRGGBBAA".

.. code-block:: Python

    from ezdxf.addons.drawing.properties import LayoutProperties

    # -x-x-x snip -x-x-x-

    fig: plt.Figure = plt.figure()
    ax: plt.Axes = fig.add_axes((0, 0, 1, 1))
    ctx = RenderContext(doc)

    # get the modelspace properties
    msp_properties = LayoutProperties.from_layout(msp)

    # set light gray background color and black foreground color
    msp_properties.set_colors("#eaeaea")
    out = MatplotlibBackend(ax)

    # override the layout properties and render the modelspace
    Frontend(ctx, out).draw_layout(
        msp,
        finalize=True,
        layout_properties=msp_properties,
    )
    fig.savefig("image.png")

A light background "#eaeaea" has a black foreground color by default:

.. image:: gfx/bg0.png
    :align: center

A dark background "#0a0a0a" has a white foreground color by default:

.. code-block:: Python

    # -x-x-x snip -x-x-x-

    msp_properties.set_colors("#0a0a0a")

    # -x-x-x snip -x-x-x-

.. image:: gfx/bg1.png
    :align: center

.. _how_to_set_transparent_bg_color:

How to Set a Transparent Background Color
+++++++++++++++++++++++++++++++++++++++++

The override color include an alpha transparency "#RRGGBBAA" value. An alpha
value of "00" is opaque and "ff" is fully transparent.
A transparent background color still defines the foreground color!

.. hint::

    The :func:`savefig` function of the matplotlib backend requires the
    `transparent` argument to be set to ``True`` to support transparency.

A light and fully transparent background "#eaeaeaff" has a black foreground
color by default:

.. code-block:: Python

    # -x-x-x snip -x-x-x-

    msp_properties.set_colors("#eaeaeaff")

    # -x-x-x snip -x-x-x-

    fig.savefig("image.png", transparent=True)

.. image:: gfx/bg2.png
    :align: center

A dark and fully transparent background "#0a0a0aff" has a **white**
foreground color by default:

.. code-block:: Python

    # -x-x-x snip -x-x-x-

    msp_properties.set_colors("#0a0a0aff")

    # -x-x-x snip -x-x-x-

    fig.savefig("image.png", transparent=True)

.. image:: gfx/bg3.png
    :align: center

.. _how_to_exclude_entities_from_rendering:

How to Exclude DXF Entities from Rendering
++++++++++++++++++++++++++++++++++++++++++

- If all unwanted entities are on the same layer switch off the layer.
- If the document is not saved later, you can delete the entities or set them
  invisible.
- Filter the unwanted entities by a filter function.

The argument `filter_func` of the :meth:`Frontend.draw_layout` method expects a
function which takes a graphical DXF entity as input and returns ``True`` if the
entity should be rendered or ``False`` to exclude the entity from rendering.

This filter function excludes all DXF entities with an ACI color value of 2:

.. code-block:: Python

    from ezdxf.entities import DXFGraphic

    def my_filter(e: DXFGraphic) -> bool:
        return e.dxf.color != 2

    # -x-x-x snip -x-x-x-

    Frontend(ctx, out).draw_layout(msp, finalize=True, filter_func=my_filter)

.. important::

    Not all attributes have a default value if the attribute does not exist.
    If you are not sure about this, use the :meth:`get` method::

        def my_filter(e: DXFGraphic) -> bool:
            return e.dxf.get("color", 7) != 2

.. _how_to_override_dxf_properties:

How to Override Properties of DXF Entities
++++++++++++++++++++++++++++++++++++++++++

Create a custom :class:`Frontend` class and override the the
:meth:`override_properties` method:

.. code-block:: Python

    class MyFrontend(Frontend):
        def override_properties(self, entity: DXFGraphic, properties: Properties) -> None:
            # remove alpha channel from all entities, "#RRGGBBAA"
            properties.color = properties.color[:7]

    # -x-x-x snip -x-x-x-

    MyFrontend(ctx, out).draw_layout(msp, finalize=True)

.. seealso::

    - :class:`ezdxf.addons.drawing.properties.Properties`

Matplotlib Backend
------------------

.. seealso::

    - Matplotlib package: https://matplotlib.org/stable/api/matplotlib_configuration_api.html
    - :class:`Figure` API: https://matplotlib.org/stable/api/figure_api.html
    - :class:`Axes` API: https://matplotlib.org/stable/api/axis_api.html

.. _matplotlib_how_to_get_pixel_coordinates:

How to Get the Pixel Coordinates of DXF Entities
++++++++++++++++++++++++++++++++++++++++++++++++

.. seealso::

    - Source: https://github.com/mozman/ezdxf/discussions/219

Transformation from modelspace coordinates to image coordinates:

.. code-block:: Python

    import matplotlib.pyplot as plt
    from PIL import Image, ImageDraw

    import ezdxf
    from ezdxf.math import Matrix44
    from ezdxf.addons.drawing import RenderContext, Frontend
    from ezdxf.addons.drawing.matplotlib import MatplotlibBackend

    def get_wcs_to_image_transform(
        ax: plt.Axes, image_size: tuple[int, int]
    ) -> Matrix44:
        """Returns the transformation matrix from modelspace coordinates to image
        coordinates.
        """

        x1, x2 = ax.get_xlim()
        y1, y2 = ax.get_ylim()
        data_width, data_height = x2 - x1, y2 - y1
        image_width, image_height = image_size
        return (
            Matrix44.translate(-x1, -y1, 0)
            @ Matrix44.scale(
                image_width / data_width, -image_height / data_height, 1.0
            )
            # +1 to counteract the effect of the pixels being flipped in y
            @ Matrix44.translate(0, image_height + 1, 0)
        )

    # create the DXF document
    doc = ezdxf.new()
    msp = doc.modelspace()
    msp.add_lwpolyline([(0, 0), (1, 0), (1, 1), (0, 1)], close=True)
    msp.add_line((0, 0), (1, 1))

    # export the pixel image
    fig: plt.Figure = plt.figure()
    ax: plt.Axes = fig.add_axes([0, 0, 1, 1])
    ctx = RenderContext(doc)
    out = MatplotlibBackend(ax)
    Frontend(ctx, out).draw_layout(msp, finalize=True)
    fig.savefig("cad.png")
    plt.close(fig)

    # reload the pixel image by Pillow (PIL)
    img = Image.open("cad.png")
    draw = ImageDraw.Draw(img)

    # add some annotations to the pixel image by using modelspace coordinates
    m = get_wcs_to_image_transform(ax, img.size)
    a, b, c = (
        (v.x, v.y)  # draw.line() expects tuple[float, float] as coordinates
        # transform modelspace coordinates to image coordinates
        for v in m.transform_vertices([(0.25, 0.75), (0.75, 0.25), (1, 1)])
    )
    draw.line([a, b, c, a], fill=(255, 0, 0))

    # show the image by the default image viewer
    img.show()

.. _matplotlib_how_to_get_msp_coordinates:

How to Get Modelspace Coordinates from Pixel Coordinates
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

This is the reverse operation of the previous how-to: :ref:`matplotlib_how_to_get_pixel_coordinates`

.. seealso::

    - Full example script: `wcs_to_image_coordinates.py`_
    - Source: https://github.com/mozman/ezdxf/discussions/269

.. code-block:: Python

    def get_image_to_wcs_transform(
        ax: plt.Axes, image_size: tuple[int, int]
    ) -> Matrix44:
        m = get_wcs_to_image_transform(ax, image_size)
        m.inverse()
        return m

    # -x-x-x snip -x-x-x-

    img2wcs = get_image_to_wcs_transform(ax, img.size)
    print(f"0.25, 0.75 == {img2wcs.transform(a).round(2)}")
    print(f"0.75, 0.25 == {img2wcs.transform(b).round(2)}")
    print(f"1.00, 1.00 == {img2wcs.transform(c).round(2)}")


.. _matplotlib_export_specific_area:

How to Export a Specific Area of the Modelspace
+++++++++++++++++++++++++++++++++++++++++++++++

This code exports the specified modelspace area from (5, 3) to (7, 8) as a
2x5 inch PNG image to maintain the aspect ratio of the source area.

Use case: render only a specific area of the modelspace.

.. seealso::

    - Full example script: `export_specific_area.py`_
    - Source: https://github.com/mozman/ezdxf/discussions/451

.. code-block:: Python

    # -x-x-x snip -x-x-x-

    # export the pixel image
    fig: plt.Figure = plt.figure()
    ax: plt.Axes = fig.add_axes([0, 0, 1, 1])
    ctx = RenderContext(doc)
    out = MatplotlibBackend(ax)
    Frontend(ctx, out).draw_layout(msp, finalize=True)

    # setting the export area:
    xmin, xmax = 5, 7
    ymin, ymax = 3, 8
    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)

    # set the output size to get the expected aspect ratio:
    fig.set_size_inches(xmax - xmin, ymax - ymin)
    fig.savefig("x5y3_to_x7y8.png")
    plt.close(fig)

.. _matplotlib_render_without_Margin:

How to Render Without Margins
+++++++++++++++++++++++++++++

To remove the empty space at the image borders set the margins of the
:class:`Axes` object to zero:

.. code-block:: Python

    ax.margins(0)
    fig.savefig("image_without_margins.png")
    plt.close(fig)

.. seealso::

    - Matplotlib docs about `margins`_

.. _matplotlib_export_pixel_density:

How to Set the Pixel Count per Drawing Unit
+++++++++++++++++++++++++++++++++++++++++++

This code exports the modelspace with an extent of 5 x 3 drawing units with
100 pixels per drawing unit as a 500 x 300 pixel image.

Use case: render the content with a fixed number of pixels for a drawing unit,
e.g. a drawing unit of 1 inch should be rendered by 100 pixels.

.. seealso::

    - Full example script: `export_image_pixel_size.py`_
    - Source: https://github.com/mozman/ezdxf/discussions/357

.. code-block:: Python

    # -x-x-x snip -x-x-x-

    def set_pixel_density(fig: plt.Figure, ax: plt.Axes, ppu: int):
        """Argument `ppu` is pixels per drawing unit."""
        xmin, xmax = ax.get_xlim()
        width = xmax - xmin
        ymin, ymax = ax.get_ylim()
        height = ymax - ymin
        dpi = fig.dpi
        width_inch = width * ppu / dpi
        height_inch = height * ppu / dpi
        fig.set_size_inches(width_inch, height_inch)

    # -x-x-x snip -x-x-x-

    # export image with 100 pixels per drawing unit = 500x300 pixels
    set_pixel_density(fig, ax, 100)
    fig.savefig("box_500x300.png")
    plt.close(fig)

.. _matplotlib_export_pixel_size:

How to Export a Specific Image Size in Pixels
+++++++++++++++++++++++++++++++++++++++++++++

This code exports the modelspace with an extent of 5 x 3 drawing units as a
1000 x 600 pixel Image.

Use case: render the content with a fixed image size in pixels.

.. seealso::

    - Full example script: `export_image_pixel_size.py`_
    - Source: https://github.com/mozman/ezdxf/discussions/357

.. code-block:: Python

    # -x-x-x snip -x-x-x-

    def set_pixel_size(fig: plt.Figure, size: tuple[int, int]):
        x, y = size
        fig.set_size_inches(x / fig.dpi, y / fig.dpi)

    # -x-x-x snip -x-x-x-

    # export image with a size of 1000x600 pixels
    set_pixel_size(fig, (1000, 600))
    fig.savefig("box_1000x600.png")
    plt.close(fig)

.. _matplotlib_set_page_size_in_inches:

How to Set the Page Size in Inches
++++++++++++++++++++++++++++++++++

The page- or image size in inches is set by the :meth:`set_size_inches` method
of the :class:`Figure` class. The content within the :class:`Axes` limits will
be scaled to fill the page.

Use case: render the whole content to a PDF document with a specific paper size
without worrying about scale.

.. code-block:: Python

    fig.set_size_inches(8, 11)

.. _matplotlib_render_at_scale:

How to Render at a Specific Scale
+++++++++++++++++++++++++++++++++

This code exports the modelspace at a specific scale and paper size.

Use case: render the content to a PDF document with a specific paper size and
scale, but not all content may be rendered.

.. seealso::

    - Full example script: `render_to_scale.py`_
    - Source: https://github.com/mozman/ezdxf/discussions/665

.. code-block:: Python

    # -x-x-x snip -x-x-x-

    def render_limits(
        origin: tuple[float, float],
        size_in_inches: tuple[float, float],
        scale: float,
    ) -> tuple[float, float, float, float]:
        """Returns the final render limits in drawing units.

        Args:
             origin: lower left corner of the modelspace area to render
             size_in_inches: paper size in inches
             scale: render scale, e.g. scale=100 means 1:100, 1m is
                 rendered as 0.01m or 1cm on paper

        """
        min_x, min_y = origin
        max_x = min_x + size_in_inches[0] * scale
        max_y = min_y + size_in_inches[1] * scale
        return min_x, min_y, max_x, max_y


    def export_to_scale(
        paper_size: tuple[float, float] = (8.5, 11),
        origin: tuple[float, float] = (0, 0),
        scale: float = 1,
        dpi: int = 300,
    ):
        """Render the modelspace content with to a specific paper size and scale.

        Args:
            paper_size: paper size in inches
            origin: lower left corner of the modelspace area to render
            scale: render scale, e.g. scale=100 means 1:100, 1m is
                rendered as 0.01m or 1cm on paper
            dpi: pixel density on paper as dots per inch

        """
        # -x-x-x snip -x-x-x-

        ctx = RenderContext(doc)
        fig: plt.Figure = plt.figure(dpi=dpi)
        ax: plt.Axes = fig.add_axes([0, 0, 1, 1])

        # disable all margins
        ax.margins(0)

        # get the final render limits in drawing units:
        min_x, min_y, max_x, max_y = render_limits(
            origin, paper_size, scale
        )

        ax.set_xlim(min_x, max_x)
        ax.set_ylim(min_y, max_y)

        out = MatplotlibBackend(ax)
        # finalizing invokes auto-scaling by default!
        Frontend(ctx, out).draw_layout(msp, finalize=False)

        # set output size in inches:
        fig.set_size_inches(paper_size[0], paper_size[1], forward=True)

        fig.savefig(f"image_scale_1_{scale}.pdf", dpi=dpi)
        plt.close(fig)


.. _matplotlib_how_to_control_the_line_width:

How to Control the Line Width
+++++++++++++++++++++++++++++

The DXF :attr:`lineweight` attribute defines the line width as absolute width on the
output medium (e.g. 25 = 0.25mm) and therefore depends only on the DPI (dots per inch)
setting of the :class:`Figure` class and the :meth:`savefig` method.

There are two additional settings in the :class:`~ezdxf.addons.drawing.config.Configuration`
class which influences the line width:

- :attr:`~ezdxf.addons.drawing.config.Configuration.min_lineweight` sets the minimum line
  width in 1/300 inch - a value of 300 is a line width of 1 inch
- :attr:`~ezdxf.addons.drawing.config.Configuration.lineweight_scaling`, multiply the
  line width by a this factor

The following table shows the line width in pixels for all valid DXF lineweights for a
resolution of 72, 100, 200 and 300 dpi:

.. image:: gfx/lineweight_table.png
    :align: center

.. seealso::

    Discussion: https://github.com/mozman/ezdxf/discussions/797

.. _FAQ: https://github.com/mozman/ezdxf/discussions/550
.. _wcs_to_image_coordinates.py: https://github.com/mozman/ezdxf/blob/master/examples/addons/drawing/wcs_to_image_coodinates.py
.. _export_specific_area.py: https://github.com/mozman/ezdxf/blob/master/examples/addons/drawing/export_specific_area.py
.. _export_image_pixel_size.py: https://github.com/mozman/ezdxf/blob/master/examples/addons/drawing/export_image_pixel_size.py
.. _margins: https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.margins.html
.. _render_to_scale.py: https://github.com/mozman/ezdxf/blob/master/examples/addons/drawing/render_to_scale.py

--- End of file: howto/drawing-addon.rst ---



--- Start of file: howto/fonts.rst ---

.. _howto_fonts:

Fonts
=====

Rendering SHX Fonts
-------------------

The SHX font format is not documented nor supported by many libraries/packages
like `Matplotlib` and `Qt`, therefore only SHX fonts which have corresponding
TTF-fonts can be rendered by these backends. The mapping from/to SHX/TTF fonts
is hard coded in the source code file: `fonts.py`_

Since `ezdxf` v1.1 is the rendering of SHX fonts supported if the path to these fonts 
is added to the ``support_dirs`` in the :ref:`config_files`.

Adding New Font Directories
---------------------------

When you add new directories to the ``support_dirs`` in your config file, you have to
rebuild the font cache to use these fonts with `ezdxf`, see section `Rebuild Font Manager Cache`_


Adding New Fonts
----------------

When you add new fonts to any of the support directories, you have to rebuild the font
cache to use these fonts with `ezdxf`, see section `Rebuild Font Manager Cache`_

Rebuild Font Manager Cache
--------------------------

If you want to use new installed fonts or fonts from a new added font directory which is
not included in the current cache file of `ezdxf` you have to rebuild the cache file:

.. code-block:: Python

    import ezdxf
    from ezdxf.fonts import fonts

    fonts.build_system_font_cache()

or call the `ezdxf` launcher to do that::

    ezdxf --fonts


.. _fonts.py: https://github.com/mozman/ezdxf/blob/master/src/ezdxf/fonts/fonts.py

--- End of file: howto/fonts.rst ---



--- Start of file: howto/index.rst ---

.. _howto:

Howto
=====

The Howto section show how to accomplish specific tasks with `ezdxf` in a straight
forward way without teaching basics or internals, if you are looking for more
information about the ezdxf internals look at the :ref:`Reference` section or if
you want to learn how to use `ezdxf` go to the :ref:`Tutorials` section or to the
:ref:`Basic Concepts` section.

.. toctree::
    :maxdepth: 2

    document
    viewer
    content
    fonts
    drawing-addon



--- End of file: howto/index.rst ---



--- Start of file: howto/viewer.rst ---

DXF Viewer
==========

A360 Viewer Problems
--------------------

AutoDesk web service A360_ seems to be more picky than the AutoCAD desktop applications, may be it helps to use the
latest DXF version supported by ezdxf, which is DXF R2018 (AC1032) in the year of writing this lines (2018).

DXF Entities Are Not Displayed in the Viewer
--------------------------------------------

`ezdxf` does not automatically locate the main viewport of the modelspace at the entities, you have to perform the
"Zoom to Extends" command, here in TrueView 2020:

.. image:: gfx/trueview_2020_zoom_to_extends.png
    :align: center

And here in the Autodesk Online Viewer:

.. image:: gfx/autodesk_online_viewer_zoom_to_extends.png
    :align: center

Add this line to your code to relocate the main viewport, adjust the `center` (in modelspace coordinates) and
the `height` (in drawing units) arguments to your needs::

    doc.set_modelspace_vport(height=10, center=(0, 0))

Show IMAGES/XREFS on Loading in AutoCAD
---------------------------------------

If you are adding XREFS and IMAGES with relative paths to existing drawings and they do not show up in AutoCAD
immediately, change the HEADER variable :code:`$PROJECTNAME=''` to *(not really)* solve this problem.
The ezdxf templates for DXF R2004 and later have :code:`$PROJECTNAME=''` as default value.

Thanks to `David Booth <https://github.com/worlds6440>`_:

    If the filename in the IMAGEDEF contains the full path (absolute in AutoCAD) then it
    shows on loading, otherwise it won't display (reports as unreadable) until you
    manually reload using XREF manager.

    A workaround (to show IMAGES on loading) appears to be to save the full file path in
    the DXF or save it as a DWG.

Thanks to `Zac Luzader <https://github.com/luzader>`_:

    Has anyone else noticed that very short simple image file names seem to avoid this
    problem? Once I ensured that the image file's name was short and had no special
    characters (letters, numbers and underscores only) the problem seemed to go away.
    I didn't rigorously analyze the behavior as its very time consuming.

    Also: You can safely put the image in a subdirectory and use a relative path. The
    name of the subdirectory does not seem to trigger this problem, provided that the
    image file name itself is very short and simple.

    Also pro tip: The XRef manager exists in DWG TrueView 2023, but access to it is only
    possible if you have a completely broken reference. Create a DXF with a reference
    to a non-existent file, then the error dialog will let you open the XRef Manager.
    Once it is open you can pin it and it will be open next time, even if you have no
    broken references.

.. seealso::

    Discussion on github:
    `Images don't show in AutoCAD until ... <https://github.com/mozman/ezdxf/discussions/845>`_

Set Initial View/Zoom for the Modelspace
----------------------------------------

See section "General Document": :ref:`set msp initial view`

Show Lineweights in DXF Viewers
-------------------------------

By default lines and curves are shown without lineweights in DXF viewers.
By setting the header variable $LWDISPLAY to 1 the DXF viewer should display
lineweights, if supported by the viewer.

.. code-block:: Python

    doc.header["$LWDISPLAY"] = 1

.. _A360: https://a360.autodesk.com/viewer/


--- End of file: howto/viewer.rst ---



--- Start of file: index.rst ---

.. ezdxf documentation master file, created by
   sphinx-quickstart on Tue Mar 15 06:49:46 2011.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

.. image:: gfx/ezdxf-logo-light-bg.svg
   :align: center
   :width: 400px

Welcome! This is the documentation for ezdxf release |release|, last updated |today|.

Quick-Info
==========

- *ezdxf* is a Python package to create new DXF documents and read/modify/write
  existing DXF documents
- MIT-License
- the intended audience are programmers
- requires at least Python 3.9
- OS independent
- tested with CPython and pypy3
- has type annotations and passes ``mypy --ignore-missing-imports -p ezdxf`` successful
- additional required packages for the core package without add-ons:
  `typing_extensions <https://pypi.org/project/typing-extensions/>`_,
  `pyparsing <https://pypi.org/project/pyparsing/>`_,
  `numpy <https://pypi.org/project/numpy/>`_,
  `fontTools <https://pypi.org/project/fonttools>`_
- read/write/new support for DXF versions: R12, R2000, R2004, R2007, R2010, R2013 and R2018
- additional read-only support for DXF versions R13/R14 (upgraded to R2000)
- additional read-only support for older DXF versions than R12 (upgraded to R12)
- read/write support for ASCII DXF and Binary DXF
- retains third-party DXF content
- optional C-extensions for CPython are included in the binary wheels, available
  on `PyPI <https://pypi.org/project/ezdxf/>`_ for Windows, Linux and macOS

Included Extensions
-------------------

Additional packages required for these add-ons are not automatically installed
during the *basic* setup, for more information about the setup & dependencies
visit the `documentation <https://ezdxf.mozman.at/docs/setup.html>`_.


- :mod:`~ezdxf.addons.drawing` add-on to visualise and convert DXF files to
  images which can be saved as PNG, PDF or SVG files
- :mod:`~ezdxf.addons.r12writer` add-on to write basic DXF entities direct and
  fast into a DXF R12 file or stream
- :mod:`~ezdxf.addons.iterdxf` add-on to iterate over DXF entities from the
  modelspace of huge DXF files (> 5GB) which do not fit into memory
- :mod:`~ezdxf.addons.importer` add-on to import entities, blocks and table
  entries from another DXF document
- :mod:`~ezdxf.addons.dxf2code` add-on to generate Python code for DXF structures
  loaded from DXF documents as starting point for parametric DXF entity creation
- :mod:`~ezdxf.addons.acadctb` add-on to read/write :ref:`plot_style_files`
- :mod:`~ezdxf.addons.pycsg` add-on for Constructive Solid Geometry (CSG)
  modeling technique
- :class:`~ezdxf.addons.MTextExplode` add-on for exploding MTEXT entities into
  single-line TEXT entities
- :mod:`~ezdxf.addons.text2path` add-on to convert text into outline paths
- :mod:`~ezdxf.addons.geo` add-on to support the `__geo_interface__ <https://gist.github.com/sgillies/2217756>`_
- :mod:`~ezdxf.addons.meshex` add-on for exchanging meshes with other tools as
  STL, OFF or OBJ files
- :mod:`~ezdxf.addons.openscad`  add-on, an interface to `OpenSCAD <https://openscad.org>`_
- :mod:`~ezdxf.addons.odafc` add-on, an interface to the `ODA File Converter <https://www.opendesign.com/guestfiles/oda_file_converter>`_
  to read and write DWG files
- :mod:`~ezdxf.addons.hpgl2` add-on for converting `HPGL/2 <https://en.wikipedia.org/wiki/HP-GL>`_
  plot files to DXF, SVG and PDF

Website
-------

https://ezdxf.mozman.at/

Documentation
-------------

Documentation of development version at https://ezdxf.mozman.at/docs

Documentation of latest release at http://ezdxf.readthedocs.io/

Knowledge Graph
---------------

The :ref:`knowledge_graph` contains additional information beyond the documentation and is 
managed by `logseq <https://logseq.com/>`_.  The source data is included in the repository 
in the folder ``ezdxf/notes``.  There is also a `HTML export <https://ezdxf.mozman.at/notes/#/page/ezdxf>`_
on the website which gets regular updates.

Release Notes
-------------

The `release notes <https://ezdxf.mozman.at/notes/#/page/release%20notes>`_ are included 
in the :ref:`knowledge_graph`.

Changelog
---------

The `changelog <https://ezdxf.mozman.at/notes/#/page/changelog>`_ is included 
in the :ref:`knowledge_graph`.


Source Code & Feedback
----------------------

Source Code: http://github.com/mozman/ezdxf.git

Issue Tracker: http://github.com/mozman/ezdxf/issues

Forum: https://github.com/mozman/ezdxf/discussions

Questions and Answers
---------------------

Please post questions at the `forum <https://github.com/mozman/ezdxf/discussions>`_
or `stack overflow <https://stackoverflow.com/>`_ to make answers available to
other users as well.


Contents
========

.. toctree::
   :maxdepth: 3

   introduction
   setup
   usage_for_beginners
   concepts/index
   tasks/index
   xref
   addons/index
   reference
   launcher
   tutorials/index
   howto/index
   faq
   glossary
   knowledgegraph

Indices and tables
------------------

* :ref:`genindex`
* :ref:`search`



--- End of file: index.rst ---



--- Start of file: introduction.rst ---

============
Introduction
============

What is ezdxf
-------------

`Ezdxf`  is a `Python`_ interface to the :term:`DXF` (drawing interchange file)
format developed by `Autodesk`_, `ezdxf` allows developers to read and modify
existing DXF documents or create new DXF documents.

The main objective in the development of `ezdxf` was to hide complex DXF details
from the programmer but still support most capabilities of the :term:`DXF`
format. Nevertheless, a basic understanding of the DXF format is required, also
to understand which tasks and goals are possible to accomplish by using the
DXF format.

Not all DXF features are supported yet, but additional features will be added in
the future gradually.

`Ezdxf` is also a replacement for the outdated `dxfwrite`_ and `dxfgrabber`_
packages but with different APIs, for more information see also: :ref:`faq001`

What ezdxf can't do
-------------------

- `ezdxf` is not a DXF converter: `ezdxf` can not convert between different
  DXF versions, if you are looking for an appropriate application, try the
  free `ODAFileConverter`_ from the `Open Design Alliance`_, which converts
  between different DXF version and also between the DXF and the DWG file format.
- `ezdxf` is not a CAD file format converter: `ezdxf` can not convert DXF files
  to other CAD formats such as DWG
- `ezdxf` is not a CAD kernel and does not provide high level functionality for
  construction work, it is just an interface to the DXF file format. If you are
  looking for a CAD kernel with `Python`_ scripting support, look at `FreeCAD`_.


Supported Python Versions
-------------------------

`Ezdxf` requires at least Python 3.9 (determined by `numpy`) and will be tested with the
latest stable CPython version and the latest stable release of pypy3 during development.

`Ezdxf` is written in pure Python with optional Cython implementations of some
low level math classes and requires `pyparsing`, `numpy`, `fontTools` and
`typing_extensions` as additional library beside the Python Standard Library.
`Pytest` is required to run the unit and integration tests. Data to run the
stress and audit test can not be provided, because I don't have the rights for
publishing these DXF files.

Supported Operating Systems
---------------------------

`Ezdxf` is OS independent and runs on all platforms which provide an appropriate
Python interpreter (>=3.9).

Supported DXF Versions
----------------------

.. include:: dxfversion.inc

`Ezdxf` also reads older DXF versions but saves it as DXF R12.

Embedded DXF Information of 3rd Party Applications
--------------------------------------------------

The DXF format allows third-party applications to embed application-specific
information. `Ezdxf` manages DXF data in a structure-preserving form, but for
the price of large memory requirement. Because of this, processing of DXF
information of third-party applications is possible and will retained on
rewriting.

License
-------

`Ezdxf` is licensed under the very liberal MIT-License_.

.. _Autodesk: http://usa.autodesk.com/

.. _Open Design Alliance: https://www.opendesign.com/

.. _ODAFileConverter: https://www.opendesign.com/guestfiles/oda_file_converter

.. _DXF: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-235B22E0-A567-4CF6-92D3-38A2306D73F3

.. _Python: http://www.python.org

.. _FreeCAD: https://www.freecadweb.org/

.. _MIT-License: http://opensource.org/licenses/mit-license.php

.. _dxfwrite: https://pypi.org/project/dxfwrite/

.. _dxfgrabber: https://pypi.org/project/dxfgrabber/


--- End of file: introduction.rst ---



--- Start of file: knowledgegraph.rst ---

.. _knowledge_graph:

Knowledge Graph
===============

I have started managing notes and documents that are not included in the `ezdxf` 
documentation in `Logseq`_ in late 2023.  It works like a wiki but does not require a 
backend server. The Information is edited as Markdown files, which is much more intuitive 
than reStructured Text, and the content is stored in local files.  

The notes are included in the source code repository on Github in the `notes folder`_.

A published edition of this Knowledge Graph is included on the `ezdxf` website and is 
accessible by the link https://ezdxf.mozman.at/notes.


The Knowledge Graph includes:

- `Release Notes`_ of future releases and some versions back
- `CHANGELOG`_
- `IDEAS`_ for future releases
- `FAQ`_ and the `HOWTO`_ sections from this documentation
- all my notes to `ezdxf`
- In the future the `DXF Internals` section from this documentation may also move to the 
  Knowledge Graph.

Logseq's outline structure is not ideal for all the documents I want to include, but I 
chose `Logseq`_ over `Obsidian.md`_ because it is open source and can publish the 
knowledge graph as a static website, static in the sense of no server-side code execution. 

This feature is important to me for hosting the content of the Knowledge Graph on the 
`ezdxf`` website  and cannot be achieved for free with `Obsidian.md`_. 

`Logseq`_ is an `Electron`_ application that runs on all platforms, with the 
disadvantage: it's an `Electron`_ application.

.. _Logseq: https://www.logseq.com/
.. _Obsidian.md: https://obsidian.md/
.. _Release Notes: https://ezdxf.mozman.at/notes/#/page/release%20notes
.. _CHANGELOG: https://ezdxf.mozman.at/notes/#/page/changelog
.. _IDEAS: https://ezdxf.mozman.at/notes/#/page/ideas
.. _FAQ: https://ezdxf.mozman.at/notes/#/page/faq
.. _HOWTO: https://ezdxf.mozman.at/notes/#/page/howto
.. _Electron: https://electronjs.org/
.. _notes folder: https://github.com/mozman/ezdxf/tree/master/notes


--- End of file: knowledgegraph.rst ---



--- Start of file: launcher.rst ---

Launcher
========

The command line script `ezdxf` launches various sub-commands:

=============== ====================================================================
``audit``       Audit and repair DXF files
``draw``        Draw and convert DXF files by the Matplotlib backend
``view``        PyQt DXF file viewer
``browse``      PyQt DXF structure browser for DXF debugging and curious people
``browse-acis`` PyQt ACIS entity content browser for SAT/SAB debugging
``strip``       Strip comments and THUMBNAILIMAGE section from DXF files
``config``      Manage config files
``info``        Show information and optional stats of DXF files as loaded by ezdxf
``hpgl``        View and/or convert HPGL/2 plot files to DXF, SVG or PDF
=============== ====================================================================

The help option ``-h`` is supported by the main script and all sub-commands:

.. code-block:: Text

    C:\> ezdxf -h
    usage: ezdxf [-h] [-V] [-v] [--config CONFIG] [--log LOG]
                 {pp,audit,draw,view,browse,browse-acis,strip,config} ...

    Command launcher for the Python package "ezdxf":
    https://pypi.org/project/ezdxf/

    positional arguments:
      {audit,draw,view,browse,strip}
        audit               audit and repair DXF files
        draw                draw and convert DXF files by Matplotlib
        view                view DXF files by the PyQt viewer
        browse              browse DXF file structure
        browse-acis         browse ACIS structures in DXF files
        strip               strip comments from DXF files
        config              manage config files
        info                show information and optional stats of DXF files loaded by ezdxf,
                            this may not represent the original content of the file, use the
                            browse command to see the original content

    optional arguments:
      -h, --help            show this help message and exit
      -V, --version         show version and exit
      -f, --fonts           rebuild system font cache and print all fonts found
      -v, --verbose         give more output
      --config CONFIG       path to a config file
      --log LOG             path to a verbose appending log

.. note::

    The ``ezdxf`` script  is the only executable script installed on the
    user system.

System
------

:code:`ezdxf -V` shows the `ezdxf` and `Python` version your are running and if the
C-extensions are used.

.. code-block:: Text

    ezdxf 1.1.0b1 from c:\source\ezdxf.git\src\ezdxf
    Python version: 3.11.2 (tags/v3.11.2:878ead1, Feb  7 2023, 16:38:35) [MSC v.1934 64 bit (AMD64)]
    using C-extensions: yes

:code:`ezdxf -f` rebuilds the system font cache and shows all fonts found.

.. _audit_command:

Audit
-----

Audit and recover the DXF file "gear.dxf" and save the recovered version
as "gear.rec.dxf":

.. code-block:: Text

    C:\> ezdxf audit -s gear.dxf

    auditing file: gear.dxf
    No errors found.
    Saved recovered file as: gear.rec.dxf

Print help:

.. code-block:: Text

    C:\> ezdxf audit -h
    usage: ezdxf audit [-h] [-s] FILE [FILE ...]

    positional arguments:
      FILE        audit DXF files

    optional arguments:
      -h, --help  show this help message and exit
      -s, --save  save recovered files with extension ".rec.dxf"

.. _draw_command:

Draw
----

Convert the DXF file "gear.dxf" into a SVG file by the *Matplotlib* backend:

.. versionadded:: 1.2.0
  
  support for more backends

.. code-block:: Text

    C:\> ezdxf draw -o gear.svg gear.dxf

The "gear.svg" created by the *Matplotlib* backend:

.. image:: gfx/gear.svg
   :align: center

Show all output formats supported by the *Matplotlib* backend
on your system. This output may vary:

.. code-block:: Text

    C:\> ezdxf draw --formats
    eps: Encapsulated Postscript
    jpg: Joint Photographic Experts Group
    jpeg: Joint Photographic Experts Group
    pdf: Portable Document Format
    pgf: PGF code for LaTeX
    png: Portable Network Graphics
    ps: Postscript
    raw: Raw RGBA bitmap
    rgba: Raw RGBA bitmap
    svg: Scalable Vector Graphics
    svgz: Scalable Vector Graphics
    tif: Tagged Image File Format
    tiff: Tagged Image File Format

Print help:

.. code-block:: Text

  C:\> ezdxf draw -h
  usage: ezdxf draw [-h] [--backend {matplotlib,qt,mupdf,custom_svg}] [--formats]
                    [-l LAYOUT]
                    [--background {DEFAULT,WHITE,BLACK,PAPERSPACE,MODELSPACE,OFF,CUSTOM}]
                    [--all-layers-visible] [--all-entities-visible] [-o OUT]
                    [--dpi DPI] [-f] [-v]
                    [FILE]

  positional arguments:
    FILE                  DXF file to view or convert

  options:
    -h, --help            show this help message and exit
    --backend {matplotlib,qt,mupdf,custom_svg}
                          choose the backend to use for rendering
    --formats             show all supported export formats and exit
    -l LAYOUT, --layout LAYOUT
                          select the layout to draw, default is "Model"
    --background {DEFAULT,WHITE,BLACK,PAPERSPACE,MODELSPACE,OFF,CUSTOM}
                          choose the background color to use
    --all-layers-visible  draw all layers including the ones marked as invisible
    --all-entities-visible
                          draw all entities including the ones marked as invisible
                          (some entities are individually marked as invisible even if
                          the layer is visible)
    -o OUT, --out OUT     output filename for export
    --dpi DPI             target render resolution, default is 300
    -f, --force           overwrite the destination if it already exists
    -v, --verbose         give more output

.. _view_command:

View
----

View the DXF file "gear.dxf" by the *PyQt* backend:

.. code-block:: Text

    C:\> ezdxf view gear.dxf

.. image:: gfx/gear-qt-backend.png
   :align: center

Print help:

.. code-block:: Text

    C:\> ezdxf view -h
    usage: ezdxf view [-h] [-l LAYOUT] [--lwscale LWSCALE] [FILE]

    positional arguments:
      FILE                  DXF file to view

    optional arguments:
      -h, --help            show this help message and exit
      -l LAYOUT, --layout LAYOUT
                            select the layout to draw, default is "Model"
      --lwscale LWSCALE     set custom line weight scaling, default is 0 to
                            disable line weights at all

.. _browse_command:

Browse
------

Browse the internal structure of a DXF file like a file system:

.. code-block:: Text

    C:\> ezdxf browse gear.dxf


.. figure:: gfx/gear-browse.png

.. code-block:: Text

    C:\> ezdxf browse -h
    usage: ezdxf browse [-h] [-l LINE] [-g HANDLE] [FILE]

    positional arguments:
      FILE                  DXF file to browse

    optional arguments:
      -h, --help            show this help message and exit
      -l LINE, --line LINE  go to line number
      -g HANDLE, --handle HANDLE
                            go to entity by HANDLE, HANDLE has to be a hex value without
                            any prefix like 'fefe'

The `browse` command stores options in the config file,
e.g. for the `Notepad++` on Windows:

.. code-block:: ini

    [browse-command]

    text_editor = "C:\Program Files\Notepad++\notepad++.exe" "{filename}" -n{num}
    icon_size = 32

``text_editor`` is a simple format string:
:code:`text_editor.format(filename="test.dxf", num=100)`

Quote commands including spaces and always quote the filename argument!

For `xed` on Linux Mint use (note: absolute path to executable):

.. code-block:: ini

    [browse-command]

    text_editor = /usr/bin/xed "{filename}" +{num}
    icon_size = 32

For `gedit` on Linux use (untested):

.. code-block:: ini

    [browse-command]

    text_editor = /usr/bin/gedit +{num} "{filename}"
    icon_size = 32

The *browse* command opens a DXF structure browser to investigate the
internals of a DXF file without interpreting the content. The intended usage is 
debugging invalid DXF files, which can not be loaded by the :func:`ezdxf.readfile()` or
the :func:`ezdxf.recover.readfile()` functions.

Line Numbers
~~~~~~~~~~~~

The low level tag loader ignores DXF comments (group code 999). If there are
comments in the DXF file the line numbers displayed in the DXF browser are
not synchronized, use the `strip`_ command beforehand to remove all comments
from the DXF file in order to keep the line numbers synchronized.

GUI Features
~~~~~~~~~~~~

The tree view on the left shows the outline of the DXF file. The number in round
brackets on the right side of each item shows the count of structure entities
within the structure layer, the value in angle brackets on the left side is
the entity handle.

The right list view shows the entity content as DXF tags.
Structure tags (data type <ctrl>) are shown in blue, a double click on a reference
handle (datatype <ref>) jumps to the referenced entity, reference handles of
non-existent targets are shown in red.

Clicking on the first structure tag in the list opens the DXF reference provided
by Autodesk in the standard web browser.

Auto Reload
~~~~~~~~~~~

The browser automatically displays a dialog for reloading DXF files if they have
been modified by an external application.

Menus and Shortcuts
~~~~~~~~~~~~~~~~~~~

- File Menu
    - **Open DXF file...** *Ctrl+O*
    - **Reload DXF file** *Ctrl+R*
    - **Open in Text Editor** *Ctrl+T*, open the DXF file in the associated text
      editor at the current location
    - **Export DXF Entity...** *Ctrl+E*, export the current DXF entity shown in the
      list view as text file
    - **Copy selected DXF Tags to Clipboard** *Ctrl+C*, copy the current
      selected DXF tags into the clipboard
    - **Copy DXF Entity to Clipboard** *Ctrl+Shift+C*, copy all DXF tags of the
      current DXF entity shown in the list view into the clipboard
    - **Quit** *Ctrl+Q*

- Navigate Menu
    - **Go to Handle...** *Ctrl+G*
    - **Go to Line...** *Ctrl+L*
    - **Find Text...** *Ctrl+F*, opens the find text dialog
    - **Next Entity** *Ctrl+Right*, go to the next entity in the DXF structure
    - **Previous Entity** *Ctrl+Right*, go to the previous entity in the DXF structure
    - **Show Entity in TreeView** *Ctrl+Down*, expand the left tree view to the
      currently displayed entity in the list view - this does not happen
      automatically for performance reasons
    - **Entity History Back** *Alt+Left*
    - **Entity History Forward** *Alt+Right*
    - **Go to HEADERS Section** *Shift+H*
    - **Go to BLOCKS Section** *Shift+B*
    - **Go to ENTITIES Section** *Shift+E*
    - **Go to OBJECTS Section** *Shift+O*

- Bookmarks Menu
    - **Store Bookmark...** *Ctrl+Shift+B*, store current location as named bookmark
    - **Go to Bookmark...** *Ctrl+B*, go to stored location

.. _browse_acis__command:

Browse-ACIS
-----------

Show and export the :term:`SAT` or :term:`SAB` content of :term:`ACIS` entities:

.. code-block:: Text

    C:\> ezdxf browse-acis 3dsolid.dxf

.. image:: gfx/browse-acis-3dsolid.png
   :align: center

The DXF format stores modern solid geometry as :term:`SAT` data for DXF R2000 -
R2010 and as :term:`SAB` data for DXF R2013 and later. This command shows the
content of this entities and also let you export the raw data for further
processing.

Entity View
~~~~~~~~~~~

The entity view is a read-only text editor, it's possible to select and copy
parts of the text into the clipboard.
To improve the readability all ACIS entities get automatically an id because
AutoCAD and BricsCAD use relative references for ACIS data export and do not
assign entity ids.
The id is shown as decimal number in parenthesis after the entity
name. The ``~`` character is a shortcut for a null-pointer.

.. code-block:: Text

    C:\>ezdxf browse-acis -h
    usage: ezdxf browse-acis [-h] [-g HANDLE] [FILE]

    positional arguments:
      FILE                  DXF file to browse

    options:
      -h, --help            show this help message and exit
      -g HANDLE, --handle HANDLE
                            go to entity by HANDLE, HANDLE has to be a hex value
                            without any prefix like 'fefe'

Menus and Shortcuts
~~~~~~~~~~~~~~~~~~~

- File Menu
    - **Open DXF file...** *Ctrl+O*
    - **Reload DXF file** *Ctrl+R*
    - **Export Current Entity View...** *Ctrl+E*, Export the parsed content of
      the entity view as text file
    - **Export Raw SAT/SAB Data...** *Ctrl+W*, export the raw SAT data as text
      file and the raw SAB data as a binary file for further processing
    - **Quit** *Ctrl+Q*

.. _strip_command:

Strip
-----

Strip comment tags (group code 999) from ASCII DXF files and can remove the
THUMBNAILIMAGE section. Binary DXF files are not supported.

.. versionadded:: 1.1.3
  
    remove handles from DXF R12 and older

.. code-block:: Text

  C:\> ezdxf strip -h
  usage: ezdxf strip [-h] [-b] [-t] [--handles] [-v] FILE [FILE ...]

  positional arguments:
    FILE             DXF file to process, wildcards "*" and "?" are supported

  options:
    -h, --help       show this help message and exit
    -b, --backup     make a backup copy with extension ".bak" from the DXF file,
                    overwrites existing backup files
    -t, --thumbnail  strip THUMBNAILIMAGE section
    --handles        remove handles from DXF R12 or older files
    -v, --verbose    give more output

.. _config_command:

Config
------

Manage config files.

.. code-block:: Text

    C:\> ezdxf config -h
    usage: ezdxf config [-h] [-p] [-w FILE] [--home] [--reset]

    optional arguments:
      -h, --help   show this help message and exit
      -p, --print  print configuration
      -w FILE, --write FILE
                   write configuration
      --home       create config file 'ezdxf.ini' in the user home directory
                   '~/.config/ezdxf', $XDG_CONFIG_HOME is supported if set

      --reset      factory reset, delete default config files 'ezdxf.ini'

.. _Info_command:

Info
----

Show information and optional stats of DXF files as loaded by `ezdxf`, this may
not represent the original content of the file, use the `browse`_ command to see
the original content. The upgrade is necessary for very old DXF versions
prior to R12 and for the "special" versions R13 and R14. The `-s` option shows
some statistics about the DXF content like entity count or table count. Use the
`-v` option show more of everything.

.. code-block:: Text

    C:\> ezdxf info -h
    usage: ezdxf info [-h] [-v] [-s] FILE [FILE ...]

    positional arguments:
      FILE           DXF file to process, wildcards "*" and "?" are supported

    options:
      -h, --help     show this help message and exit
      -v, --verbose  give more output
      -s, --stats    show content stats

This is the verbose output for an old DXF R10 file and shows that the loading
process created some required structures which do not exist in DXF R10 files,
like the BLOCK_RECORD table or the OBJECTS section:

.. code-block:: Text

    C:\> ezdxf info -v -s test_R10.dxf

    Filename: "test_R10.dxf"
    Loaded content was upgraded from DXF Version AC1006 (R10)
    Release: R12
    DXF Version: AC1009
    Maintenance Version: <undefined>
    Codepage: ANSI_1252
    Encoding: cp1252
    Unit system: Imperial
    Modelspace units: Unitless
    $LASTSAVEDBY: <undefined>
    $HANDSEED: 0
    $FINGERPRINTGUID: {9EADDC7C-5982-4C68-B770-8A62378C2B90}
    $VERSIONGUID: {49336E63-D99B-45EC-803C-4D2BD03A7DE0}
    $USERI1=0
    $USERI2=0
    $USERI3=0
    $USERI4=0
    $USERI5=0
    $USERR1=0.0
    $USERR2=0.0
    $USERR3=0.0
    $USERR4=0.0
    $USERR5=0.0
    File was not created by ezdxf >= 0.16.4
    File was not written by ezdxf >= 0.16.4
    Content stats:
    LAYER table entries: 18
      0
      Defpoints
      LYR_00
      LYR_01
      LYR_02
      LYR_03
      LYR_04
      LYR_05
      LYR_06
      LYR_07
      LYR_08
      LYR_09
      LYR_10
      LYR_11
      LYR_12
      LYR_13
      LYR_14
      LYR_15
    LTYPE table entries: 13
      BORDER
      ByBlock
      ByLayer
      CENTER
      CONTINUOUS
      CUTTING
      DASHDOT
      DASHED
      DIVIDE
      DOT
      HIDDEN
      PHANTOM
      STITCH
    STYLE table entries: 1
      STANDARD
    DIMSTYLE table entries: 1
      Standard
    APPID table entries: 1
      ACAD
    UCS table entries: 0
    VIEW table entries: 0
    VPORT table entries: 1
      *Active
    BLOCK_RECORD table entries: 2
      *Model_Space
      *Paper_Space
    Entities in modelspace: 78
      ARC (2)
      CIRCLE (2)
      LINE (74)
    Entities in OBJECTS section: 20
      ACDBDICTIONARYWDFLT (1)
      ACDBPLACEHOLDER (1)
      DICTIONARY (11)
      LAYOUT (2)
      MATERIAL (3)
      MLEADERSTYLE (1)
      MLINESTYLE (1)


Show Version & Configuration
----------------------------

Show the *ezdxf* version and configuration:

.. code-block:: Text

    C:\> ezdxf -Vv

    ezdxf v0.16.5b0 @ d:\source\ezdxf.git\src\ezdxf
    Python version: 3.9.6 (tags/v3.9.6:db3ff76, Jun 28 2021, 15:26:21) [MSC v.1929 64 bit (AMD64)]
    using C-extensions: yes
    using Matplotlib: yes

    Configuration:
    [core]
    default_dimension_text_style = OpenSansCondensed-Light
    test_files = D:\Source\dxftest
    font_cache_directory =
    load_proxy_graphics = true
    store_proxy_graphics = true
    log_unprocessed_tags = false
    filter_invalid_xdata_group_codes = true
    write_fixed_meta_data_for_testing = false
    disable_c_ext = false

    [browse-command]
    text_editor = "C:\Program Files\Notepad++\notepad++.exe" "{filename}" -n{num}


    Environment Variables:
    EZDXF_DISABLE_C_EXT=
    EZDXF_TEST_FILES=D:\Source\dxftest
    EZDXF_CONFIG_FILE=

    Existing Configuration Files:
    C:\Users\manfred\.config\ezdxf\ezdxf.ini

.. seealso::

    Documentation of the :mod:`ezdxf.options` module and the
    :ref:`environment_variables`.

.. _hpgl_command:

HPGL/2 Viewer/Converter
-----------------------

.. versionadded:: 1.1

The ``hpgl`` command shows and/or converts `HPGL/2`_ plot files to DXF, SVG or PDF.

DXF
~~~

The page content is created at the origin of the modelspace and 1 drawing unit is 1
plot unit (1 plu = 0.025mm) unless scaling values are provided.

The content of HPGL files is intended to be plotted on white paper, so the appearance on
a dark background in modelspace is not very clear. To fix this, the ``--map_black_to_white``
option maps black fillings and lines to white.

All entities are mapped to a layer named  ``COLOR_<#>`` according to the pen number.
In order to process the content better, it is also possible to assign the DXF elements an
ACI color value according to the pen number through the ``--aci`` option, but then the
RGB color is lost because the RGB color always has the higher priority over the
:term:`ACI` value.

The first paperspace layout "Layout0" is set up to print the entire modelspace on one
sheet, the size of the page is the size of the original plot file in millimeters.

SVG
~~~

The plot units are mapped 1:1 to ``viewBox`` units and the size of image is the size of
the original plot file in millimeters.

PDF
~~~

The plot units are converted to PDF units (1/72 inch) so the size of image is the
size of the original plot file in millimeters.

All Formats
~~~~~~~~~~~

HPGL/2's merge control works at the pixel level and cannot be replicated by DXF,
but to prevent fillings from obscuring text, the filled polygons are
sorted by luminance - this can be forced or disabled by the ``--merge_control`` option.

Some plot files that contain pure HPGL/2 code do not contain the escape sequence
"Enter HPGL/2 mode", without this sequence the HPGL/2 parser cannot recognize the
beginning of the HPGL/2 code. The ``--force`` option inserts the "Enter HPGL/2 mode"
escape sequence into the data stream, regardless of whether the file is an HPGL/2 plot
file or not, so be careful.

.. code-block:: Text

    C:\> ezdxf hpgl -h
    usage: ezdxf hpgl [-h] [-e FORMAT] [-r {0,90,180,270}] [-x SX] [-y SY] [-m {0,1,2}]
                      [-f] [--aci] [--map_black_to_white]
                      [FILE]

    positional arguments:
      FILE                  view and/or convert HPGL/2 plot files, wildcards (*, ?)
                            supported in command line mode

    options:
      -h, --help            show this help message and exit
      -e FORMAT, --export FORMAT
                            convert HPGL/2 plot file to SVG, PDF or DXF from the
                            command line (no gui)
      -r {0,90,180,270}, --rotate {0,90,180,270}
                            rotate page about 90, 180 or 270 degrees (no gui)
      -x SX, --scale_x SX   scale page in x-axis direction, use negative values to
                            mirror page, (no gui)
      -y SY, --scale_y SY   scale page in y-axis direction, use negative values to
                            mirror page (no gui)
      -m {0,1,2}, --merge_control {0,1,2}
                            provides control over the order of filled polygons, 0=off
                            (print order), 1=luminance (order by luminance), 2=auto
                            (default)
      -f, --force           inserts the mandatory 'enter HPGL/2 mode' escape sequence
                            into the data stream; use this flag when no HPGL/2 data was
                            found and you are sure the file is a HPGL/2 plot file
      --aci                 use pen numbers as ACI colors (DXF only)
      --map_black_to_white  map black RGB plot colors to white RGB, does not affect ACI
                            colors (DXF only)

    Note that plot files are intended to be plotted on white paper.

.. _PyMuPDF: https://pypi.org/project/PyMuPDF/
.. _HPGL/2: https://en.wikipedia.org/wiki/HP-GL
.. _SVG: https://en.wikipedia.org/wiki/SVG
.. _PDF: https://en.wikipedia.org/wiki/PDF


--- End of file: launcher.rst ---



--- Start of file: layouts/index.rst ---

Layouts
=======

.. module:: ezdxf.layouts

.. toctree::
   :maxdepth: 2

   layout_manager
   layouts

--- End of file: layouts/index.rst ---



--- Start of file: layouts/layout_manager.rst ---

.. _layout_manager:

Layout Manager
==============

.. module:: ezdxf.layouts
    :noindex:

The layout manager is unique to each DXF drawing, access the layout manager as
:attr:`~ezdxf.document.Drawing.layouts` attribute of the
:class:`~ezdxf.document.Drawing` object
(e.g. ``doc.layouts.rename("Layout1", "PlanView")``).

.. class:: Layouts

    The :class:`Layouts` class manages :class:`~ezdxf.layouts.Paperspace` layouts and
    the :class:`~ezdxf.layouts.Modelspace`.

    .. automethod:: __len__

    .. automethod:: __contains__

    .. automethod:: __iter__

    .. automethod:: names

    .. automethod:: names_in_taborder

    .. automethod:: modelspace

    .. automethod:: get

    .. automethod:: new

    .. automethod:: rename

    .. automethod:: delete

    .. automethod:: active_layout

    .. automethod:: set_active_layout

    .. automethod:: get_layout_for_entity


--- End of file: layouts/layout_manager.rst ---



--- Start of file: layouts/layouts.rst ---

.. include:: ../spline-links.inc

.. _layout:

Layout Types
============

.. module:: ezdxf.layouts
    :noindex:

A Layout represents and manages DXF entities, there are three different layout objects:

- :class:`Modelspace` is the common working space, containing basic drawing entities.
- :class:`Paperspace` is the arrangement of objects for printing and plotting,
  this layout contains basic drawing entities and viewports to the
  :class:`Modelspace`.
- :class:`BlockLayout` works on an associated :class:`~ezdxf.entities.block.Block`,
  Blocks are collections of DXF entities for reusing by block references.

.. warning::

    Do not instantiate layout classes by yourself - always use the provided
    factory functions!

Entity Ownership
----------------

A layout owns all entities residing in their entity space, therefore the
:attr:`dxf.owner` attribute of any :class:`~ezdxf.entities.DXFGraphic` entity
in this layout is the :attr:`dxf.handle` of the layout, and deleting an entity
from a layout is the end of life of this entity, because it is also deleted from
the :class:`~ezdxf.entitydb.EntityDB`. It's possible to just unlink an entity
from a layout to assign the entity to another layout, use the
:meth:`~BaseLayout.move_to_layout` method to move entities between layouts.


BaseLayout
==========

.. class:: BaseLayout

    :class:`BaseLayout` is the common base class for :class:`Layout` and :class:`BlockLayout`.

    .. autoattribute:: is_alive

    .. autoattribute:: is_active_paperspace

    .. autoattribute:: is_any_paperspace

    .. autoattribute:: is_modelspace

    .. autoattribute:: is_any_layout

    .. autoattribute:: is_block_layout

    .. autoattribute:: units

    .. automethod:: __len__

    .. automethod:: __iter__

    .. automethod:: __getitem__

    .. automethod:: get_extension_dict

    .. automethod:: delete_entity

    .. automethod:: delete_all_entities

    .. automethod:: unlink_entity

    .. automethod:: purge

    .. automethod:: query

    .. automethod:: groupby

    .. automethod:: move_to_layout

    .. automethod:: set_redraw_order

    .. automethod:: get_redraw_order

    .. automethod:: entities_in_redraw_order

    .. automethod:: add_entity

    .. automethod:: add_foreign_entity

    .. automethod:: add_point

    .. automethod:: add_line

    .. automethod:: add_circle

    .. automethod:: add_ellipse

    .. automethod:: add_arc

    .. automethod:: add_solid

    .. automethod:: add_trace

    .. automethod:: add_3dface

    .. automethod:: add_text

    .. automethod:: add_blockref

    .. automethod:: add_auto_blockref

    .. automethod:: add_attdef

    .. automethod:: add_polyline2d

    .. automethod:: add_polyline3d

    .. automethod:: add_polymesh

    .. automethod:: add_polyface

    .. automethod:: add_shape

    .. automethod:: add_lwpolyline

    .. automethod:: add_mtext

    .. automethod:: add_mtext_static_columns

    .. automethod:: add_mtext_dynamic_manual_height_columns

    .. automethod:: add_mtext_dynamic_auto_height_columns

    .. automethod:: add_ray

    .. automethod:: add_xline

    .. automethod:: add_mline

    .. automethod:: add_spline

    .. automethod:: add_cad_spline_control_frame

    .. automethod:: add_spline_control_frame

    .. automethod:: add_open_spline

    .. automethod:: add_rational_spline

    .. automethod:: add_hatch

    .. automethod:: add_helix

    .. automethod:: add_mpolygon

    .. automethod:: add_mesh

    .. automethod:: add_image

    .. automethod:: add_wipeout

    .. automethod:: add_underlay

    .. automethod:: add_linear_dim

    .. automethod:: add_multi_point_linear_dim

    .. automethod:: add_aligned_dim

    .. automethod:: add_radius_dim

    .. automethod:: add_radius_dim_2p

    .. automethod:: add_radius_dim_cra

    .. automethod:: add_diameter_dim

    .. automethod:: add_diameter_dim_2p

    .. automethod:: add_angular_dim_2l

    .. automethod:: add_angular_dim_3p

    .. automethod:: add_angular_dim_cra

    .. automethod:: add_angular_dim_arc

    .. automethod:: add_arc_dim_3p

    .. automethod:: add_arc_dim_cra

    .. automethod:: add_arc_dim_arc

    .. automethod:: add_ordinate_dim

    .. automethod:: add_ordinate_x_dim

    .. automethod:: add_ordinate_y_dim

    .. automethod:: add_leader

    .. automethod:: add_multileader_mtext

    .. automethod:: add_multileader_block

    .. automethod:: add_body

    .. automethod:: add_region

    .. automethod:: add_3dsolid

    .. automethod:: add_surface

    .. automethod:: add_extruded_surface

    .. automethod:: add_lofted_surface

    .. automethod:: add_revolved_surface

    .. automethod:: add_swept_surface

Layout
======

.. class:: Layout

    :class:`Layout` is a subclass of :class:`BaseLayout` and common base class of :class:`Modelspace` and
    :class:`Paperspace`.

    .. autoattribute:: name

    .. autoattribute:: dxf

    .. automethod:: __contains__

    .. automethod:: reset_extents

    .. automethod:: reset_limits

    .. automethod:: set_plot_type

    .. automethod:: set_plot_style

    .. automethod:: set_plot_window

    .. automethod:: plot_viewport_borders

    .. automethod:: show_plot_styles

    .. automethod:: plot_centered

    .. automethod:: plot_hidden

    .. automethod:: use_standard_scale

    .. automethod:: use_plot_styles

    .. automethod:: scale_lineweights

    .. automethod:: print_lineweights

    .. automethod:: draw_viewports_first

    .. automethod:: model_type

    .. automethod:: update_paper

    .. automethod:: zoom_to_paper_on_update

    .. automethod:: plot_flags_initializing

    .. automethod:: prev_plot_init

    .. automethod:: set_plot_flags

Modelspace
==========

.. class:: Modelspace

    :class:`Modelspace` is a subclass of :class:`Layout`.

    The modelspace contains the "real" world representation of the drawing subjects in real world units.

    .. autoattribute:: name

    .. automethod:: new_geodata

    .. automethod:: get_geodata

Paperspace
==========

.. class:: Paperspace

    :class:`Paperspace` is a subclass of :class:`Layout`.

    Paperspace layouts are used to create different drawing sheets of the modelspace subjects for printing or
    PDF export.

    .. autoattribute:: name

    .. automethod:: page_setup(size=(297, 210), margins=(10, 15, 10, 15), units='mm', offset=(0, 0), rotation=0, scale=16, name='ezdxf', device='DWG to PDF.pc3')

    .. automethod:: viewports

    .. automethod:: main_viewport

    .. automethod:: add_viewport

    .. automethod:: reset_viewports

    .. automethod:: reset_main_viewport

    .. automethod:: reset_paper_limits

    .. automethod:: get_paper_limits


BlockLayout
===========

.. class:: BlockLayout

    :class:`BlockLayout` is a subclass of :class:`BaseLayout`.

    Block layouts are reusable sets of graphical entities, which can be referenced by multiple
    :class:`~ezdxf.entities.Insert` entities. Each reference can be placed, scaled and rotated individually and can
    have it's own set of DXF :class:`~ezdxf.entities.Attrib` entities attached.

    .. autoproperty:: name

    .. autoproperty:: block

    .. autoproperty:: endblk

    .. autoproperty:: dxf

    .. autoproperty:: can_explode

    .. autoproperty:: scale_uniformly

    .. autoproperty:: base_point

    .. automethod:: __contains__

    .. automethod:: attdefs

    .. automethod:: has_attdef

    .. automethod:: get_attdef

    .. automethod:: get_attdef_text


.. _limits: https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2020/ENU/AutoCAD-Core/files/GUID-6CF82FC7-E1BC-4A8C-A23D-4396E3D99632-htm.html


.. _extents: https://knowledge.autodesk.com/de/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2020/DEU/AutoCAD-Core/files/GUID-B3926CFA-DE74-4661-A9A5-2738A1FD937B-htm.html

--- End of file: layouts/layouts.rst ---



--- Start of file: low_level_tools/dxf_unicode_decoder.rst ---

.. _DXF Unicode Decoder:

DXF Unicode Decoder
===================

The DXF format uses a special form of unicode encoding: "\\U+xxxx".

To avoid a speed penalty such encoded characters are not decoded
automatically by the regular loading function:func:`ezdxf.readfile`,
only the :mod:`~ezdxf.recover` module does the decoding
automatically, because this loading mode is already slow.

This kind of encoding is most likely used only in older DXF versions, because
since DXF R2007 the whole DXF file is encoded in ``utf8`` and a special unicode
encoding is not necessary.

The :func:`ezdxf.has_dxf_unicode` and :func:`ezdxf.decode_dxf_unicode` are
new support functions to decode unicode characters "\\U+xxxx" manually.

.. autofunction:: ezdxf.has_dxf_unicode

.. autofunction:: ezdxf.decode_dxf_unicode


--- End of file: low_level_tools/dxf_unicode_decoder.rst ---



--- Start of file: low_level_tools/functions.rst ---

Low Level Functions
===================


Some handy tool functions used internally by ``ezdxf``.

.. autofunction:: ezdxf.tools.juliandate

.. autofunction:: ezdxf.tools.calendardate

.. autofunction:: ezdxf.tools.set_flag_state

.. autofunction:: ezdxf.tools.guid

.. autofunction:: ezdxf.tools.bytes_to_hexstr

.. autofunction:: ezdxf.tools.suppress_zeros

.. autofunction:: ezdxf.tools.normalize_text_angle



--- End of file: low_level_tools/functions.rst ---



--- Start of file: low_level_tools/sat_crypt.rst ---


SAT Format "Encryption"
=======================

.. autofunction:: ezdxf.tools.crypt.encode

.. autofunction:: ezdxf.tools.crypt.decode


--- End of file: low_level_tools/sat_crypt.rst ---



--- Start of file: math/clipping.rst ---


.. module:: ezdxf.math.clipping

.. _math_clipping:

Clipping
========

Clipping module: :mod:`ezdxf.math.clipping`

.. autofunction:: greiner_hormann_union

.. autofunction:: greiner_hormann_difference

.. autofunction:: greiner_hormann_intersection

.. autoclass:: ConvexClippingPolygon2d

    .. automethod:: clip_polygon

    .. automethod:: clip_polyline

    .. automethod:: clip_line

    .. automethod:: is_inside

.. autoclass:: ClippingRect2d

    .. automethod:: clip_polygon

    .. automethod:: clip_polyline

    .. automethod:: clip_line

    .. automethod:: is_inside

.. autoclass:: ConcaveClippingPolygon2d

    .. automethod:: clip_polygon

    .. automethod:: clip_polyline

    .. automethod:: clip_line

    .. automethod:: is_inside

.. autoclass:: InvertedClippingPolygon2d

    .. automethod:: clip_polygon

    .. automethod:: clip_polyline

    .. automethod:: clip_line

    .. automethod:: is_inside


--- End of file: math/clipping.rst ---



--- Start of file: math/clustering.rst ---


.. module:: ezdxf.math.clustering

.. _math_clustering:

Clustering
==========

Clustering module: :mod:`ezdxf.math.clustering`

.. autofunction:: average_cluster_radius

.. autofunction:: average_intra_cluster_distance

.. autofunction:: dbscan

.. autofunction:: k_means


--- End of file: math/clustering.rst ---



--- Start of file: math/core.rst ---

.. _math_core:

Core
####

.. module:: ezdxf.math

Math core module: :mod:`ezdxf.math`

These are the core math functions and classes which should be imported from
:mod:`ezdxf.math`.


Utility Functions
=================

.. autosummary::
    :nosignatures:

    arc_angle_span_deg
    arc_angle_span_rad
    arc_chord_length
    arc_segment_count
    area
    closest_point
    ellipse_param_span
    has_matrix_2d_stretching
    has_matrix_3d_stretching
    open_uniform_knot_vector
    required_knot_values
    uniform_knot_vector
    xround
    gps_to_world_mercator
    world_mercator_to_gps

.. autofunction:: closest_point

.. autofunction:: uniform_knot_vector

.. autofunction:: open_uniform_knot_vector

.. autofunction:: required_knot_values

.. autofunction:: xround

.. autofunction:: area

.. autofunction:: arc_angle_span_deg

.. autofunction:: arc_angle_span_rad

.. autofunction:: arc_segment_count

.. autofunction:: arc_chord_length

.. autofunction:: ellipse_param_span

.. autofunction:: has_matrix_2d_stretching

.. autofunction:: has_matrix_3d_stretching

.. autofunction:: gps_to_world_mercator

.. autofunction:: world_mercator_to_gps

.. _bulge_related_functions:

Bulge Related Functions
=======================

.. autosummary::
    :nosignatures:

    arc_to_bulge
    bulge_3_points
    bulge_center
    bulge_radius
    bulge_to_arc
    bulge_from_radius_and_chord
    bulge_from_arc_angle

.. seealso::

    Description of the :ref:`bulge value`.

.. autofunction:: arc_to_bulge

.. autofunction:: bulge_3_points

.. autofunction:: bulge_center

.. autofunction:: bulge_radius

.. autofunction:: bulge_to_arc

.. autofunction:: bulge_from_radius_and_chord

.. autofunction:: bulge_from_arc_angle

2D Graphic Functions
====================

.. autosummary::
    :nosignatures:

    convex_hull_2d
    distance_point_line_2d
    intersect_polylines_2d
    intersection_line_line_2d
    is_axes_aligned_rectangle_2d
    is_convex_polygon_2d
    is_point_in_polygon_2d
    is_point_left_of_line
    is_point_on_line_2d
    offset_vertices_2d
    point_to_line_relation
    rytz_axis_construction


.. autofunction:: convex_hull_2d

.. autofunction:: distance_point_line_2d

.. autofunction:: intersect_polylines_2d

.. autofunction:: intersection_line_line_2d

.. autofunction:: is_axes_aligned_rectangle_2d

.. autofunction:: is_convex_polygon_2d

.. autofunction:: is_point_in_polygon_2d

.. autofunction:: is_point_left_of_line

.. autofunction:: is_point_on_line_2d

.. autofunction:: offset_vertices_2d

.. code-block:: Python

    source = [(0, 0), (3, 0), (3, 3), (0, 3)]
    result = list(offset_vertices_2d(source, offset=0.5, closed=True))

.. image:: gfx/offset_vertices_2d_1.png

Example for a closed collinear shape, which creates 2 additional vertices and the first one has an unexpected location:

.. code-block:: Python

    source = [(0, 0), (0, 1), (0, 2), (0, 3)]
    result = list(offset_vertices_2d(source, offset=0.5, closed=True))

.. image:: gfx/offset_vertices_2d_2.png

.. autofunction:: point_to_line_relation

.. autofunction:: rytz_axis_construction

3D Graphic Functions
====================

.. autosummary::
    :nosignatures:

    basic_transformation
    best_fit_normal
    bezier_to_bspline
    closed_uniform_bspline
    cubic_bezier_bbox
    cubic_bezier_from_3p
    cubic_bezier_from_arc
    cubic_bezier_from_ellipse
    cubic_bezier_interpolation
    distance_point_line_3d
    estimate_end_tangent_magnitude
    estimate_tangents
    fit_points_to_cad_cv
    fit_points_to_cubic_bezier
    global_bspline_interpolation
    have_bezier_curves_g1_continuity
    intersect_polylines_3d
    intersection_line_line_3d
    intersection_line_polygon_3d
    intersection_ray_polygon_3d
    intersection_ray_ray_3d
    is_planar_face
    is_vertex_order_ccw_3d
    linear_vertex_spacing
    local_cubic_bspline_interpolation
    normal_vector_3p
    open_uniform_bspline
    quadratic_bezier_bbox
    quadratic_bezier_from_3p
    quadratic_to_cubic_bezier
    rational_bspline_from_arc
    rational_bspline_from_ellipse
    safe_normal_vector
    spherical_envelope
    split_bezier
    split_polygon_by_plane
    subdivide_face
    subdivide_ngons

.. seealso::

    The free online book `3D Math Primer for Graphics and Game Development <https://gamemath.com/>`_
    is a very good resource for learning vector math and other graphic related topics,
    it is easy to read for beginners and especially targeted to programmers.

.. autofunction:: basic_transformation

.. autofunction:: best_fit_normal

.. autofunction:: bezier_to_bspline

.. autofunction:: closed_uniform_bspline

.. autofunction:: cubic_bezier_bbox

.. autofunction:: cubic_bezier_from_3p

.. autofunction:: cubic_bezier_from_arc

.. autofunction:: cubic_bezier_from_ellipse

.. autofunction:: cubic_bezier_interpolation

.. autofunction:: distance_point_line_3d

.. autofunction:: estimate_end_tangent_magnitude

.. autofunction:: estimate_tangents

.. autofunction:: fit_points_to_cad_cv

.. autofunction:: fit_points_to_cubic_bezier

.. autofunction:: global_bspline_interpolation

.. autofunction:: have_bezier_curves_g1_continuity

.. autofunction:: intersect_polylines_3d

.. autofunction:: intersection_line_line_3d

.. autofunction:: intersection_line_polygon_3d

.. autofunction:: intersection_ray_polygon_3d

.. autofunction:: intersection_ray_ray_3d

.. autofunction:: is_planar_face

.. autofunction:: is_vertex_order_ccw_3d

.. autofunction:: linear_vertex_spacing

.. autofunction:: local_cubic_bspline_interpolation

.. autofunction:: normal_vector_3p

.. autofunction:: open_uniform_bspline

.. autofunction:: quadratic_bezier_bbox

.. autofunction:: quadratic_bezier_from_3p

.. autofunction:: quadratic_to_cubic_bezier

.. autofunction:: rational_bspline_from_arc

.. autofunction:: rational_bspline_from_ellipse

.. autofunction:: safe_normal_vector

.. autofunction:: spherical_envelope

.. autofunction:: split_bezier

.. autofunction:: split_polygon_by_plane

.. autofunction:: subdivide_face

.. autofunction:: subdivide_ngons

Transformation Classes
======================

.. autosummary::
    :nosignatures:

    Matrix44
    OCS
    UCS

OCS Class
---------

.. autoclass:: OCS

    .. autoattribute:: ux

    .. autoattribute:: uy

    .. autoattribute:: uz

    .. automethod:: from_wcs

    .. automethod:: points_from_wcs

    .. automethod:: to_wcs

    .. automethod:: points_to_wcs

    .. automethod:: render_axis


UCS Class
---------

.. autoclass:: UCS

    .. autoattribute:: ux

    .. autoattribute:: uy

    .. autoattribute:: uz

    .. autoattribute:: is_cartesian

    .. automethod:: copy

    .. automethod:: to_wcs

    .. automethod:: points_to_wcs

    .. automethod:: direction_to_wcs

    .. automethod:: from_wcs

    .. automethod:: points_from_wcs

    .. automethod:: direction_from_wcs

    .. automethod:: to_ocs

    .. automethod:: points_to_ocs

    .. automethod:: to_ocs_angle_deg

    .. automethod:: transform

    .. automethod:: rotate

    .. automethod:: rotate_local_x

    .. automethod:: rotate_local_y

    .. automethod:: rotate_local_z

    .. automethod:: shift

    .. automethod:: moveto

    .. automethod:: from_x_axis_and_point_in_xy

    .. automethod:: from_x_axis_and_point_in_xz

    .. automethod:: from_y_axis_and_point_in_xy

    .. automethod:: from_y_axis_and_point_in_yz

    .. automethod:: from_z_axis_and_point_in_xz

    .. automethod:: from_z_axis_and_point_in_yz

    .. automethod:: render_axis


Matrix44
--------

.. autoclass:: Matrix44

    .. automethod:: __repr__

    .. automethod:: get_row

    .. automethod:: set_row

    .. automethod:: get_col

    .. automethod:: set_col

    .. automethod:: copy

    .. automethod:: __copy__

    .. automethod:: scale

    .. automethod:: translate

    .. automethod:: x_rotate

    .. automethod:: y_rotate

    .. automethod:: z_rotate

    .. automethod:: axis_rotate

    .. automethod:: xyz_rotate

    .. automethod:: shear_xy

    .. automethod:: perspective_projection

    .. automethod:: perspective_projection_fov

    .. automethod:: chain

    .. automethod:: ucs

    .. automethod:: __hash__

    .. automethod:: __getitem__

    .. automethod:: __setitem__

    .. automethod:: __iter__

    .. automethod:: rows

    .. automethod:: columns

    .. automethod:: __mul__

    .. automethod:: __imul__

    .. automethod:: transform

    .. automethod:: transform_direction

    .. automethod:: transform_vertices

    .. automethod:: fast_2d_transform

    .. automethod:: transform_directions

    .. automethod:: transpose

    .. automethod:: determinant

    .. automethod:: inverse

    .. autoproperty:: is_cartesian

    .. autoproperty:: is_orthogonal

Basic Construction Classes
==========================

.. autosummary::
    :nosignatures:

    BoundingBox
    BoundingBox2d
    ConstructionArc
    ConstructionBox
    ConstructionCircle
    ConstructionEllipse
    ConstructionLine
    ConstructionPolyline
    ConstructionRay
    Plane
    Shape2d
    Vec2
    Vec3

UVec
----

.. class:: UVec

    Type alias for :code:`Union[Sequence[float], Vec2, Vec3]`

Vec3
----

.. autoclass:: Vec3

    .. autoattribute:: x

    .. autoattribute:: y

    .. autoattribute:: z

    .. autoattribute:: xy

    .. autoattribute:: xyz

    .. autoattribute:: vec2

    .. autoattribute:: magnitude

    .. autoattribute:: magnitude_xy

    .. autoattribute:: magnitude_square

    .. autoattribute:: is_null

    .. autoattribute:: angle

    .. autoattribute:: angle_deg

    .. autoattribute:: spatial_angle

    .. autoattribute:: spatial_angle_deg

    .. automethod:: __str__

    .. automethod:: __repr__

    .. automethod:: __len__

    .. automethod:: __hash__

    .. automethod:: copy

    .. automethod:: __copy__

    .. automethod:: __deepcopy__

    .. automethod:: __getitem__

    .. automethod:: __iter__

    .. automethod:: __abs__

    .. automethod:: replace

    .. automethod:: generate

    .. automethod:: list

    .. automethod:: tuple

    .. automethod:: from_angle

    .. automethod:: from_deg_angle

    .. automethod:: orthogonal

    .. automethod:: lerp

    .. automethod:: is_parallel

    .. automethod:: project

    .. automethod:: normalize

    .. automethod:: reversed

    .. automethod:: isclose

    .. automethod:: __neg__

    .. automethod:: __bool__

    .. automethod:: __eq__

    .. automethod:: __lt__

    .. automethod:: __add__

    .. automethod:: __radd__

    .. automethod:: __sub__

    .. automethod:: __rsub__

    .. automethod:: __mul__

    .. automethod:: __rmul__

    .. automethod:: __truediv__

    .. automethod:: dot

    .. automethod:: cross

    .. automethod:: distance

    .. automethod:: angle_about

    .. automethod:: angle_between

    .. automethod:: rotate

    .. automethod:: rotate_deg

    .. automethod:: sum

.. attribute:: X_AXIS

    :code:`Vec3(1, 0, 0)`

.. attribute:: Y_AXIS

    :code:`Vec3(0, 1, 0)`

.. attribute:: Z_AXIS

    :code:`Vec3(0, 0, 1)`

.. attribute:: NULLVEC

    :code:`Vec3(0, 0, 0)`

Vec2
----

.. autoclass:: Vec2


Plane
-----


.. autoclass:: Plane(normal: Vec3, distance: float)

    .. autoattribute:: normal

    .. autoattribute:: distance_from_origin

    .. autoattribute:: vector

    .. automethod:: from_3p

    .. automethod:: from_vector

    .. automethod:: copy

    .. automethod:: signed_distance_to

    .. automethod:: distance_to

    .. automethod:: is_coplanar_vertex

    .. automethod:: is_coplanar_plane

    .. automethod:: intersect_line

    .. automethod:: intersect_ray


BoundingBox
-----------

.. autoclass:: BoundingBox

    .. attribute:: extmin

        "lower left" corner of bounding box

    .. attribute:: extmax

        "upper right" corner of bounding box

    .. autoproperty:: is_empty

    .. autoproperty:: has_data

    .. autoproperty:: size

    .. autoproperty:: center

    .. automethod:: inside

    .. automethod:: any_inside

    .. automethod:: all_inside

    .. automethod:: has_intersection

    .. automethod:: has_overlap

    .. automethod:: contains

    .. automethod:: extend

    .. automethod:: union

    .. automethod:: intersection

    .. automethod:: rect_vertices

    .. automethod:: cube_vertices

    .. automethod:: grow

BoundingBox2d
-------------

.. autoclass:: BoundingBox2d

    .. attribute:: extmin

        "lower left" corner of bounding box

    .. attribute:: extmax

        "upper right" corner of bounding box

    .. autoproperty:: is_empty

    .. autoproperty:: has_data

    .. autoproperty:: size

    .. autoproperty:: center

    .. automethod:: inside

    .. automethod:: any_inside

    .. automethod:: all_inside

    .. automethod:: has_intersection

    .. automethod:: has_overlap

    .. automethod:: contains

    .. automethod:: extend

    .. automethod:: union

    .. automethod:: intersection

    .. automethod:: rect_vertices

ConstructionRay
---------------

.. autoclass:: ConstructionRay

    .. autoattribute:: location

    .. autoattribute:: direction

    .. autoattribute:: slope

    .. autoattribute:: angle

    .. autoattribute:: angle_deg

    .. autoattribute:: is_vertical

    .. autoattribute:: is_horizontal

    .. automethod:: __str__

    .. automethod:: is_parallel

    .. automethod:: intersect

    .. automethod:: orthogonal

    .. automethod:: bisectrix

    .. automethod:: yof

    .. automethod:: xof

ConstructionLine
----------------

.. autoclass:: ConstructionLine

    .. attribute:: start

        start point as :class:`Vec2`

    .. attribute:: end

        end point as :class:`Vec2`

    .. autoattribute:: bounding_box

    .. autoattribute:: ray

    .. autoattribute:: is_vertical

    .. autoattribute:: is_horizontal

    .. automethod:: __str__

    .. automethod:: translate

    .. automethod:: length

    .. automethod:: midpoint

    .. automethod:: inside_bounding_box

    .. automethod:: intersect

    .. automethod:: has_intersection

    .. automethod:: is_point_left_of_line


ConstructionCircle
------------------

.. autoclass:: ConstructionCircle

    .. attribute:: center

        center point as :class:`Vec2`

    .. attribute:: radius

        radius as float

    .. autoattribute:: bounding_box

    .. automethod:: from_3p

    .. automethod:: __str__

    .. automethod:: translate

    .. automethod:: point_at

    .. automethod:: vertices

    .. automethod:: flattening

    .. automethod:: inside

    .. automethod:: tangent

    .. automethod:: intersect_ray

    .. automethod:: intersect_line

    .. automethod:: intersect_circle

ConstructionArc
---------------

.. autoclass:: ConstructionArc

    .. attribute:: center

        center point as :class:`Vec2`

    .. attribute:: radius

        radius as float

    .. attribute:: start_angle

        start angle in degrees

    .. attribute:: end_angle

        end angle in degrees

    .. autoattribute:: angle_span

    .. autoattribute:: start_angle_rad

    .. autoattribute:: end_angle_rad

    .. autoattribute:: start_point

    .. autoattribute:: end_point

    .. autoattribute:: bounding_box

    .. automethod:: angles

    .. automethod:: vertices

    .. automethod:: tangents

    .. automethod:: translate

    .. automethod:: scale_uniform

    .. automethod:: rotate_z

    .. automethod:: from_2p_angle

    .. automethod:: from_2p_radius

    .. automethod:: from_3p

    .. automethod:: add_to_layout

    .. automethod:: intersect_ray

    .. automethod:: intersect_line

    .. automethod:: intersect_circle

    .. automethod:: intersect_arc

ConstructionEllipse
-------------------

.. autoclass:: ConstructionEllipse

    .. attribute:: center

        center point as :class:`Vec3`

    .. attribute:: major_axis

        major axis as :class:`Vec3`

    .. attribute:: minor_axis

        minor axis as :class:`Vec3`, automatically calculated from
        :attr:`major_axis` and :attr:`extrusion`.

    .. attribute:: extrusion

        extrusion vector (normal of ellipse plane) as :class:`Vec3`

    .. attribute:: ratio

        ratio of minor axis to major axis (float)

    .. attribute:: start

        start param in radians (float)

    .. attribute:: end

        end param in radians (float)

    .. autoattribute:: start_point

    .. autoattribute:: end_point

    .. autoproperty:: param_span

    .. automethod:: to_ocs

    .. automethod:: params

    .. automethod:: vertices

    .. automethod:: flattening

    .. automethod:: params_from_vertices

    .. automethod:: dxfattribs

    .. automethod:: main_axis_points

    .. automethod:: from_arc

    .. automethod:: transform

    .. automethod:: swap_axis

    .. automethod:: add_to_layout


ConstructionBox
---------------

.. autoclass:: ConstructionBox

    .. autoattribute:: center

    .. autoattribute:: width

    .. autoattribute:: height

    .. autoattribute:: angle

    .. autoattribute:: corners

    .. autoattribute:: bounding_box

    .. autoattribute:: incircle_radius

    .. autoattribute:: circumcircle_radius

    .. automethod:: __iter__

    .. automethod:: __getitem__

    .. automethod:: __repr__

    .. automethod:: from_points

    .. automethod:: translate

    .. automethod:: expand

    .. automethod:: scale

    .. automethod:: rotate

    .. automethod:: is_inside

    .. automethod:: is_any_corner_inside

    .. automethod:: is_overlapping

    .. automethod:: border_lines

    .. automethod:: intersect

ConstructionPolyline
--------------------

.. autoclass:: ConstructionPolyline

    .. autoproperty:: length

    .. autoproperty:: is_closed

    .. automethod:: data

    .. automethod:: index_at

    .. automethod:: vertex_at

    .. automethod:: divide

    .. automethod:: divide_by_length


Shape2d
-------

.. autoclass:: Shape2d

    .. attribute:: vertices

        List of :class:`Vec2` objects

    .. autoattribute:: bounding_box

    .. automethod:: __len__

    .. automethod:: __getitem__

    .. automethod:: append

    .. automethod:: extend

    .. automethod:: translate

    .. automethod:: scale

    .. automethod:: scale_uniform

    .. automethod:: rotate

    .. automethod:: rotate_rad

    .. automethod:: offset

    .. automethod:: convex_hull

Curves
======

.. autosummary::
    :nosignatures:

    ApproxParamT
    BSpline
    Bezier
    Bezier3P
    Bezier4P
    EulerSpiral

BSpline
-------

.. autoclass:: BSpline

    .. autoproperty:: control_points

    .. autoproperty:: count

    .. autoproperty:: order

    .. autoproperty:: degree

    .. autoproperty:: max_t

    .. autoproperty:: is_rational

    .. autoproperty:: is_clamped

    .. automethod:: knots

    .. automethod:: weights

    .. automethod:: params

    .. automethod:: reverse

    .. automethod:: transform

    .. automethod:: approximate

    .. automethod:: flattening

    .. automethod:: point

    .. automethod:: points

    .. automethod:: derivative

    .. automethod:: derivatives

    .. automethod:: insert_knot

    .. automethod:: knot_refinement

    .. automethod:: from_ellipse

    .. automethod:: from_arc

    .. automethod:: from_fit_points

    .. automethod:: arc_approximation

    .. automethod:: ellipse_approximation

    .. automethod:: bezier_decomposition

    .. automethod:: cubic_bezier_approximation

    .. automethod:: degree_elevation

    .. automethod:: point_inversion

    .. automethod:: measure

    .. automethod:: split


.. autoclass:: ezdxf.math.bspline.Measurement

    .. attribute:: extmin

        minimum extents of the approximated curve as :class:`~ezdxf.math.Vec3`

    .. attribute:: extmax

        maximum extents of the approximated curve as :class:`~ezdxf.math.Vec3`

    .. autoproperty:: length

    .. automethod:: distance

    .. automethod:: param_at

    .. automethod:: divide



Bezier
------

.. autoclass:: Bezier

    .. autoattribute:: control_points

    .. automethod:: params

    .. automethod:: reverse

    .. automethod:: transform

    .. automethod:: approximate

    .. automethod:: flattening

    .. automethod:: point

    .. automethod:: points

    .. automethod:: derivative

    .. automethod:: derivatives


Bezier4P
--------

.. autoclass:: Bezier4P

    .. autoattribute:: control_points

    .. automethod:: reverse

    .. automethod:: transform

    .. automethod:: approximate

    .. automethod:: flattening

    .. automethod:: approximated_length

    .. automethod:: point

    .. automethod:: tangent

Bezier3P
--------

.. autoclass:: Bezier3P

    .. autoattribute:: control_points

    .. automethod:: reverse

    .. automethod:: transform

    .. automethod:: approximate

    .. automethod:: flattening

    .. automethod:: approximated_length

    .. automethod:: point

    .. automethod:: tangent

ApproxParamT
------------

.. autoclass:: ApproxParamT(curve, *, max_t: float = 1.0, segments: int = 100)

    .. autoproperty:: max_t

    .. autoproperty:: polyline

    .. automethod:: param_t

    .. automethod:: distance


EulerSpiral
-----------

.. autoclass:: EulerSpiral

    .. automethod:: radius

    .. automethod:: tangent

    .. automethod:: distance

    .. automethod:: point

    .. automethod:: circle_center

    .. automethod:: approximate

    .. automethod:: bspline

.. _Global Curve Interpolation: http://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/INT-APP/CURVE-INT-global.html
.. _uniform: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/INT-APP/PARA-uniform.html
.. _chord length: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/INT-APP/PARA-chord-length.html
.. _centripetal: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/INT-APP/PARA-centripetal.html
.. _knot: http://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/INT-APP/PARA-knot-generation.html
.. _clamped curve: http://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/bspline-curve.html
.. _open curve: http://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/bspline-curve-open.html
.. _closed curve: http://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/bspline-curve-closed.html
.. _basis: http://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/bspline-basis_vector.html
.. _B-spline: https://en.wikipedia.org/wiki/B-spline
.. _Bzier curve: https://en.wikipedia.org/wiki/B%C3%A9zier_curve
.. _Lee Mac: http://www.lee-mac.com/bulgeconversion.html
.. _sagitta: https://en.wikipedia.org/wiki/Sagitta_(geometry)

--- End of file: math/core.rst ---



--- Start of file: math/linalg.rst ---


.. module:: ezdxf.math.linalg

.. _math_linalg:

Linear Algebra
==============

Linear algebra module **for internal usage**: :mod:`ezdxf.math.linalg`

Functions
---------

.. autofunction:: tridiagonal_vector_solver

.. autofunction:: tridiagonal_matrix_solver

.. autofunction:: banded_matrix

.. autofunction:: detect_banded_matrix

.. autofunction:: compact_banded_matrix


Matrix Class
------------

.. autoclass:: Matrix

    .. autoattribute:: nrows

    .. autoattribute:: ncols

    .. autoattribute:: shape

    .. automethod:: append_col

    .. automethod:: append_row

    .. automethod:: col

    .. automethod:: cols

    .. automethod:: determinant

    .. automethod:: diag

    .. automethod:: freeze

    .. automethod:: identity

    .. automethod:: inverse

    .. automethod:: isclose

    .. automethod:: reshape

    .. automethod:: row

    .. automethod:: rows

    .. automethod:: set_col

    .. automethod:: set_diag

    .. automethod:: set_row

    .. automethod:: transpose

    .. automethod:: __getitem__

    .. automethod:: __setitem__

    .. automethod:: __eq__

    .. automethod:: __add__

    .. automethod:: __sub__

    .. automethod:: __mul__


NumpySolver
-----------

.. autoclass:: NumpySolver

    .. automethod:: solve_vector

    .. automethod:: solve_matrix


BandedMatrixLU Class
--------------------

.. autoclass:: BandedMatrixLU

    .. attribute:: upper

        Upper triangle

    .. attribute:: lower

        Lower triangle

    .. attribute:: m1

        Lower band count, excluding main matrix diagonal

    .. attribute:: m2

        Upper band count, excluding main matrix diagonal

    .. attribute:: index

        Swapped indices

    .. autoattribute:: nrows

    .. automethod:: solve_vector

    .. automethod:: solve_matrix


.. _Gauss-Jordan: https://en.wikipedia.org/wiki/Gaussian_elimination
.. _Gauss-Elimination: https://en.wikipedia.org/wiki/Gaussian_elimination
.. _LU Decomposition: https://en.wikipedia.org/wiki/LU_decomposition


--- End of file: math/linalg.rst ---



--- Start of file: math/rtree.rst ---


.. module:: ezdxf.math.rtree

.. _math_rtree:

RTree
=====

RTree module: :mod:`ezdxf.math.rtree`

.. autoclass:: RTree

    .. automethod:: __len__

    .. automethod:: __iter__

    .. automethod:: contains

    .. automethod:: nearest_neighbor

    .. automethod:: points_in_sphere

    .. automethod:: points_in_bbox

    .. automethod:: avg_leaf_size

    .. automethod:: avg_spherical_envelope_radius

    .. automethod:: avg_nn_distance


--- End of file: math/rtree.rst ---



--- Start of file: math/triangulation.rst ---


.. module:: ezdxf.math.triangulation

.. _math_triangulation:

Triangulation
=============

Triangulation module: :mod:`ezdxf.math.triangulation`

.. autofunction:: mapbox_earcut_2d

.. autofunction:: mapbox_earcut_3d


--- End of file: math/triangulation.rst ---



--- Start of file: math_construction_tools.rst ---


Math Construction Tools
=======================

These are links to tools in the :mod:`ezdxf.math` core module:

.. autosummary::
    :nosignatures:

    ezdxf.math.ConstructionRay
    ezdxf.math.ConstructionLine
    ezdxf.math.ConstructionCircle
    ezdxf.math.ConstructionArc
    ezdxf.math.ConstructionEllipse
    ezdxf.math.ConstructionBox
    ezdxf.math.ConstructionPolyline
    ezdxf.math.Shape2d
    ezdxf.math.BSpline
    ezdxf.math.Bezier4P
    ezdxf.math.Bezier3P
    ezdxf.math.Bezier
    ezdxf.math.EulerSpiral

.. _Bzier curve: https://en.wikipedia.org/wiki/B%C3%A9zier_curve

--- End of file: math_construction_tools.rst ---



--- Start of file: options.rst ---

.. _global_options:

Global Options Object
=====================

.. module:: ezdxf.options

The global `ezdxf` options are stored in the object :mod:`ezdxf.options`.

Recommended usage of the global :attr:`options` object::

    import ezdxf

    value = ezdxf.options.attribute

.. important::

    Most options are only read at startup (support folders, paths to executables),
    changing these values has no effect at runtime. To change these options, you must
    create a configuration file, see section :ref:`config_files`.

The :attr:`options` object uses the Standard Python class :class:`ConfigParser`
to manage the configuration. Shortcut attributes like :attr:`test_files` are
simple properties and most shortcuts are read only marked by (Read only),
read and writeable attributes are marked by (Read/Write).

To change options, especially the read only attributes, you have to edit the
config file with a text editor, or set options by the :meth:`set` method and
write the current configuration into a config file.

.. _config_files:

Config Files
============

The default config files are loaded from the user home directory as
"~/.config/ezdxf/ezdxf.ini", and the current working directory as "./ezdxf.ini".
A custom config file can be specified  by the environment variable
``EZDXF_CONFIG_FILE``. Ezdxf follows the `XDG Base Directory specification`_
if the environment variable ``XDG_CONFIG_HOME`` is set.

The config file loading order:

1. user home directory: "~/.config/ezdxf/ezdxf.ini"
2. current working directory: "./ezdxf.ini"
3. config file specified by ``EZDXF_CONFIG_FILE``

A configuration file that is loaded later does not replace the previously loaded
ones, only the existing options in the newly loaded file are added to the
configuration and can overwrite existing options.

.. _config_file:

Configuration files are regular INI files, managed by the standard Python
`ConfigParser`_ class.

File Structure:

.. code:: INI

    [core]
    default_dimension_text_style = OpenSansCondensed-Light
    test_files = D:\Source\dxftest
    support_dirs =
        "C:\Program Files\Bricsys\BricsCAD V23 en_US\Fonts",
        "~/dir2",
        "~/dir3",
    load_proxy_graphics = true
    store_proxy_graphics = true
    log_unprocessed_tags = false
    filter_invalid_xdata_group_codes = true
    write_fixed_meta_data_for_testing = false
    disable_c_ext = false

    [browse-command]
    text_editor = "C:\Program Files\Notepad++\notepad++.exe" "{filename}" -n{num}

Modify and Save Changes
-----------------------

This code shows how to get and set values of the underlying :class:`ConfigParser`
object, but use the shortcut attributes if available:

.. code-block:: Python

    # Set options, value has to ba a str, use "true"/"false" for boolean values
    ezdxf.options.set(section, key, value)

    # Get option as string
    value = ezdxf.options.get(section, key, default="")

    # Special getter for boolean, int and float
    value = ezdxf.options.get_bool(section, key, default=False)
    value = ezdxf.options.get_int(section, key, default=0)
    value = ezdxf.options.get_float(section, key, default=0.0)

If you set options, they are not stored automatically in a config file, you have
to write back the config file manually:

.. code-block:: Python

    # write back the default user config file "ezdxf.ini" in the
    # user home directory
    ezdxf.options.write_home_config()

    # write back to the default config file "ezdxf.ini" in the
    # current working directory
    ezdxf.options.write_file()

    # write back to a specific config file
    ezdxf.options.write_file("my_config.ini")
    # which has to be loaded manually at startup
    ezdxf.options.read_file("my_config.ini")

This example shows how to change the :attr:`test_files` path and save the
changes into a custom config file "my_config.ini":

.. code-block:: Python

    import ezdxf

    test_files = Path("~/my-dxf-test-files").expand_user()
    ezdxf.options.set(
        ezdxf.options.CORE,  # section
        "test_files",  # key
        "~/my-dxf-test-files",  # value
    )
    ezdxf.options.write_file("my_config.ini")

.. _use_a_custom_config_file:

Use a Custom Config File
------------------------

You can specify a config file by the environment variable
``EZDXF_CONFIG_FILE``, which is loaded after the default config files.

.. code-block:: Text

    C:\> set EZDXF_CONFIG_FILE=D:\user\path\custom.ini

Custom config files are not loaded automatically like the default config files.

This example shows how to load the previous created custom config file
"my_config.ini" from the current working directory:

.. code-block:: Python

    import ezdxf

    ezdxf.options.read("my_config.ini")

That is all and because this is the last loaded config file, it overrides all
default config files and the config file specified by ``EZDXF_CONFIG_FILE``.

Functions
---------

.. function:: set(section: str, key: str, value: str)

    Set option `key` in `section` to `values` as ``str``.

.. function:: get(section: str, key: str, default: str = "") -> str

    Get option `key` in `section` as string.

.. function:: get_bool(section: str, key: str, default: bool = False) -> bool

    Get option `key` in `section` as ``bool``.

.. function:: get_int(section: str, key: str, default: int = 0) -> int

    Get option `key` in `section` as ``int``.

.. function:: get_float(section: str, key: str, default: float = 0.0) -> flot

    Get option `key` in `section` as ``float``.

.. function:: write(fp: TextIO)

    Write configuration into given file object `fp`, the file object
    must be a writeable text file with "utf8" encoding.

.. function:: write_file(filename: str = "ezdxf.ini")

    Write current configuration into file `filename`, default is "ezdxf.ini" in
    the current working directory.

.. function:: write_home_config()

    Write configuration into file "~/.config/ezdxf/ezdxf.ini",
    ``$XDG_CONFIG_HOME`` is supported if set.

.. function:: read_file(filename: str)

    Append content from config file `filename`, but does not reset the
    configuration.

.. function:: print()

    Print configuration to `stdout`.

.. function:: reset()

    Reset options to factory default values.

.. function:: delete_default_config_files()

    Delete the default config files "ezdxf.ini" in the current working and in
    the user home directory "~/.config/ezdxf", ``$XDG_CONFIG_HOME`` is supported
    if set.

.. function:: preserve_proxy_graphics(state=True)

    Enable/disable proxy graphic load/store support by setting the
    options ``load_proxy_graphics`` and ``store_proxy_graphics`` to `state`.

.. attribute:: loaded_config_files

    Read only property of loaded config files as tuple for :class:`Path`
    objects.

Core Options
------------

For all core options the section name is ``core``.


Default Dimension Text Style
++++++++++++++++++++++++++++

The default dimension text style is used by the DIMENSION renderer of `ezdxf`,
if the specified text style exist in the STYLE table. To use any of the default
style of `ezdxf` you have to setup the styles at the creation of the DXF
document: :code:`ezdxf.new(setup=True)`, or setup the `ezdxf` default styles
for a loaded DXF document:

.. code-block:: Python

    import ezdxf
    from ezdxf.tool.standard import setup_drawing

    doc = ezdxf.readfile("your.dxf")
    setup_drawing(doc)

Config file key: ``default_dimension_text_style``

Shortcut attribute:

.. attribute:: default_dimension_text_style

    (Read/Write) Get/Set default text style for DIMENSION rendering, default
    value is ``OpenSansCondensed-Light``.

Load Proxy Graphic
++++++++++++++++++

Proxy graphics are not essential for DXF files, but they can provide a simple
graphical representation for complex entities, but extra memory is needed to
store this information. You can save some memory by not loading the proxy
graphic, but the proxy graphic is lost if you write back the DXF file.

The current version of `ezdxf` uses this proxy graphic to render MLEADER
entities by the :mod:`~ezdxf.addons.drawing` add-on.

Config file key: ``load_proxy_graphics``

Shortcut attribute:

.. attribute:: load_proxy_graphics

    (Read/Write) Load proxy graphics if ``True``, default is ``True``.

Store Proxy Graphic
+++++++++++++++++++

Prevent exporting proxy graphics if set to ``False``.

Config file key: ``store_proxy_graphics``

Shortcut attribute:

.. attribute:: store_proxy_graphics

    (Read/Write)  Export proxy graphics if ``True``, default is ``True``.

Support Directories
+++++++++++++++++++

Search directories for support files:

- plot style tables, the .ctb or .stb pen assignment files
- shape font files of type .shx or .shp or .lff

.. important::

    When you add new font directories to ``support_dirs`` or new fonts to one of the
    support directories, you have to rebuild the font cache to use these fonts,
    see section :ref:`Rebuilding the Font Cache` for more information.

Config file key: ``support_dirs``

Shortcut attribute:

.. attribute:: support_dirs

    (Read/Write) Search directories as list of strings.

Use quotes for paths including spaces:

.. code-block:: ini

    [core]
    support_dirs =
        ~/dir1,
        ~/dir2,
        "~/dir 3",

Debugging Options
-----------------

For all debugging options the section name is ``core``.

Test Files
++++++++++

Path to test files. Some of the `CADKit`_ test files are used by the
integration tests, these files should be located in the
:code:`ezdxf.options.test_files_path / "CADKitSamples"` folder.

Config file key: ``test_files``

Shortcut attributes:

.. attribute:: test_files

    (Read only) Returns the path to the `ezdxf` test files as ``str``,
    expands "~" construct automatically.

.. attribute:: test_files_path

    (Read only) Path to test files as :class:`pathlib.Path` object.


Filter Invalid XDATA Group Codes
++++++++++++++++++++++++++++++++

Only a very limited set of group codes is valid in the XDATA section and
AutoCAD is very picky about that. `Ezdxf` removes invalid XDATA group codes
if this option is set to ``True``, but this needs processing time, which is
wasted if you get your DXF files from trusted sources like AutoCAD or BricsCAD.

Config file key: ``filter_invalid_xdata_group_codes``

.. attribute:: filter_invalid_xdata_group_codes

    (Read only) Filter invalid XDATA group codes, default value is ``True``.

Log Unprocessed Tags
++++++++++++++++++++

Logs unprocessed DXF tags, this helps to find new and undocumented DXF features.

Config file key: ``log_unprocessed_tags``

.. attribute:: log_unprocessed_tags

    (Read/Write) Log unprocessed DXF tags for debugging, default value is
    ``False``.

Write Fixed Meta Data for Testing
+++++++++++++++++++++++++++++++++

Write the DXF files with fixed meta data to test your DXF files by a diff-like
command, this is necessary to get always the same meta data like the saving
time stored in the HEADER section. This may not work across different `ezdxf`
versions!

Config file key: ``write_fixed_meta_data_for_testing``

.. attribute:: write_fixed_meta_data_for_testing

    (Read/Write) Enable this option to always create same meta data for testing
    scenarios, e.g. to use a diff-like tool to compare DXF documents,
    default is ``False``.

Disable C-Extension
+++++++++++++++++++

It is possible to deactivate the optional C-extensions if there are any issues
with the C-extensions. This has to be done in a default config file or by
environment variable before the first import of `ezdxf`. For ``pypy3`` the
C-extensions are always disabled, because the JIT compiled Python code is
much faster.

.. important::

    This option works only in the **default config files**, user config files which
    are loaded by :func:`ezdxf.options.read_file()` cannot disable the C-Extensions,
    because at this point the setup process of `ezdxf` is already finished!

Config file key: ``disable_c_ext``

.. attribute:: disable_c_ext

    (Read only) This option disables the C-extensions if ``True``.
    This can only be done before the first import of `ezdxf` by using a config
    file or the environment variable ``EZDXF_DISABLE_C_EXT``.

Use C-Extensions
++++++++++++++++

.. attribute:: use_c_ext

    (Read only) Shows the actual state of C-extensions usage.

.. _environment_variables:

Environment Variables
=====================

Some feature can be controlled by environment variables. Command line example
for disabling the optional C-extensions on Windows::

    C:\> set EZDXF_DISABLE_C_EXT=1

.. important::

    If you change any environment variable, you have to restart
    the Python interpreter!

EZDXF_DISABLE_C_EXT
    Set environment variable ``EZDXF_DISABLE_C_EXT`` to ``1`` or ``True`` to
    disable the usage of the C-extensions.

EZDXF_TEST_FILES
    Path to the `ezdxf` test files required by some tests, for instance the
    `CADKit`_ sample files should be located in the
    ``EZDXF_TEST_FILES/CADKitSamples`` folder. See also option
    :attr:`ezdxf.options.test_files`.

EZDXF_CONFIG_FILE
    Specifies a user config file which will be loaded automatically after the
    default config files at the first import of `ezdxf`.

.. _CADKit: https://cadkit.blogspot.com/p/sample-dxf-files.html?view=magazine
.. _ConfigParser: https://docs.python.org/3/library/configparser.html
.. _XDG Base Directory specification: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html

--- End of file: options.rst ---



--- Start of file: path.rst ---

.. module:: ezdxf.path

Path
====

This module implements a geometric :class:`Path`, supported by several render
backends, with the goal to create such paths from DXF entities like LWPOLYLINE,
POLYLINE or HATCH and send them to the render backend,
see :mod:`ezdxf.addons.drawing`.

Minimum common interface:

- matplotlib: `PathPatch`_
    - matplotlib.path.Path() codes:
    - MOVETO
    - LINETO
    - CURVE3 - quadratic Bzier-curve
    - CURVE4 - cubic Bzier-curve

- PyQt: `QPainterPath`_
    - moveTo()
    - lineTo()
    - quadTo() - quadratic Bzier-curve (converted to a cubic Bzier-curve)
    - cubicTo() - cubic Bzier-curve

- PyCairo: `Context`_
    - move_to()
    - line_to()
    - no support for quadratic Bzier-curve
    - curve_to() - cubic Bzier-curve

- SVG: `SVG-Path`_
    - "M" - absolute move to
    - "L" - absolute line to
    - "Q" - absolute quadratic Bzier-curve
    - "C" - absolute cubic Bzier-curve

ARC and ELLIPSE entities are approximated by multiple cubic Bzier-curves, which
are close enough for display rendering. Non-rational SPLINES of 3rd degree can
be represented exact as multiple cubic Bzier-curves, other B-splines will be
approximated. The XLINE and the RAY entities are not supported, because of their
infinite nature.

This :class:`Path` class is a full featured 3D object, although the backends
only support 2D paths.

.. hint::

    A :class:`Path` can not represent a point. A :class:`Path` with only a
    start point yields no vertices!


The usability of the :class:`Path` class expanded by the introduction
of the reverse conversion from :class:`Path` to DXF entities (LWPOLYLINE,
POLYLINE, LINE), and many other tools in `ezdxf` v0.16.
To emphasize this new usability, the :class:`Path` class has got its own
subpackage :mod:`ezdxf.path`.

.. glossary::

    Empty-Path
        Contains only a start point, the length of the path is 0 and the methods
        :meth:`Path.approximate`, :meth:`Path.flattening` and
        :meth:`Path.control_vertices` do not yield any vertices.

    Single-Path
        The :class:`Path` object contains only one path without gaps, the property
        :attr:`Path.has_sub_paths` is ``False`` and the method
        :meth:`Path.sub_paths` yields only this one path.

    Multi-Path
        The :class:`Path` object contains more than one path, the property
        :attr:`Path.has_sub_paths` is ``True`` and the method
        :meth:`Path.sub_paths` yields all paths within this object as single-path
        objects. It is not possible to detect the orientation of a multi-path
        object, therefore the methods :meth:`Path.has_clockwise_orientation`,
        :meth:`Path.clockwise` and :meth:`Path.counter_clockwise` raise a
        :class:`TypeError` exception.

.. warning::

    Always import from the top level :mod:`ezdxf.path`, never from the
    sub-modules

Factory Functions
-----------------

Functions to create :class:`Path` objects from other objects.

.. function:: make_path(entity: DXFEntity) -> Path

    Factory function to create a single :class:`Path` object from a DXF
    entity. Supported DXF types:

    - LINE
    - CIRCLE
    - ARC
    - ELLIPSE
    - SPLINE and HELIX
    - LWPOLYLINE
    - 2D and 3D POLYLINE
    - SOLID, TRACE, 3DFACE
    - IMAGE, WIPEOUT clipping path
    - VIEWPORT clipping path
    - HATCH as :term:`Multi-Path` object

    :param entity: DXF entity
    :param segments: minimal count of cubic Bzier-curves for elliptical arcs
        like CIRCLE, ARC, ELLIPSE, BULGE see :meth:`Path.add_ellipse`
    :param level: subdivide level for SPLINE approximation,
        see :meth:`Path.add_spline`

    :raises TypeError: for unsupported DXF types


.. autofunction:: from_hatch

.. autofunction:: from_vertices

Render Functions
----------------

Functions to create DXF entities from paths and add them to the modelspace, a
paperspace layout or a block definition.

.. autofunction:: render_hatches

.. autofunction:: render_lines

.. autofunction:: render_lwpolylines

.. autofunction:: render_mpolygons

.. autofunction:: render_polylines2d

.. autofunction:: render_polylines3d

.. autofunction:: render_splines_and_polylines

Entity Maker
------------

Functions to create DXF entities from paths.

.. autofunction:: to_hatches

.. autofunction:: to_lines

.. autofunction:: to_lwpolylines

.. autofunction:: to_mpolygons

.. autofunction:: to_polylines2d

.. autofunction:: to_polylines3d

.. autofunction:: to_splines_and_polylines

Tool Maker
----------

Functions to create construction tools.

.. autofunction:: to_bsplines_and_vertices


Utility Functions
-----------------

.. autofunction:: add_bezier3p

.. autofunction:: add_bezier4p

.. autofunction:: add_ellipse

.. autofunction:: add_spline

.. autofunction:: bbox

.. autofunction:: chamfer

.. autofunction:: chamfer2

.. autofunction:: fillet

.. autofunction:: fit_paths_into_box

.. autofunction:: have_close_control_vertices

.. autofunction:: lines_to_curve3

.. autofunction:: lines_to_curve4

.. autofunction:: polygonal_fillet

.. autofunction:: single_paths

.. autofunction:: to_multi_path

.. autofunction:: transform_paths

.. autofunction:: transform_paths_to_ocs

.. autofunction:: triangulate

Basic Shapes
------------

.. autofunction:: elliptic_transformation

.. autofunction:: gear

.. autofunction:: helix

.. autofunction:: ngon

.. autofunction:: rect

.. autofunction:: star

.. autofunction:: unit_circle

.. autofunction:: wedge

The :mod:`~ezdxf.addons.text2path` add-on provides additional functions to
create paths from text strings and DXF text entities.


The Path Class
--------------

.. class:: Path

    .. autoproperty:: end

    .. autoproperty:: has_curves

    .. autoproperty:: has_lines

    .. autoproperty:: has_sub_paths

    .. autoproperty:: is_closed

    .. autoproperty:: start

    .. autoproperty:: user_data

    .. automethod:: append_path

    .. automethod:: approximate

    .. automethod:: bbox

    .. automethod:: clockwise

    .. automethod:: clone

    .. automethod:: close

    .. automethod:: close_sub_path

    .. automethod:: control_vertices

    .. automethod:: counter_clockwise

    .. automethod:: curve3_to

    .. automethod:: curve4_to

    .. automethod:: extend_multi_path

    .. automethod:: flattening

    .. automethod:: has_clockwise_orientation

    .. automethod:: line_to

    .. automethod:: move_to

    .. automethod:: reversed

    .. automethod:: sub_paths

    .. automethod:: transform


.. _PathPatch: https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.patches.PathPatch.html#matplotlib.patches.PathPatch
.. _QPainterPath: https://doc.qt.io/qt-5/qpainterpath.html
.. _SVG-Path: https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths
.. _Context: https://pycairo.readthedocs.io/en/latest/reference/context.html

--- End of file: path.rst ---



--- Start of file: r12strict.rst ---

.. _r12strict:

.. module:: ezdxf.r12strict

r12strict
=========

.. versionadded:: 1.1

Due to ACAD release 14 the resource names, such as layer-, linetype, text style-,
dimstyle- and block names, were limited to 31 characters in length and all names were
uppercase.

Names can include the letters A to Z, the numerals 0 to 9, and the special characters,
dollar sign ``"$"``, underscore ``"_"``, hyphen ``"-"`` and the asterix ``"*"`` as
first character for special names like anonymous blocks.
Most applications do not care about that and work fine with longer names and any
characters used in names for some exceptions, but of course Autodesk applications are
very picky about that.

The function :func:`make_acad_compatible` makes DXF R12 drawings to 100% compatible to
Autodesk products and does everything at once, but the different processing steps can
be called manually.

.. important::

    This module can only process DXF R12 file and will throw a :class:`DXFVersionError`
    otherwise. For exporting any DXF document as DXF R12 use the
    :mod:`ezdxf.addons.r12export` add-on.

Usage
-----

.. code-block:: Python

    import ezdxf
    from ezdxf import r12strict

    doc = ezdxf.readfile("r12sloppy.dxf")
    r12strict.make_acad_compatible(doc)
    doc.saveas("r12strict.dxf")

Functions
---------

.. autosummary::
    :nosignatures:

    make_acad_compatible
    translate_names
    clean

.. autofunction:: make_acad_compatible

.. autofunction:: translate_names

.. autofunction:: clean

.. autoclass:: R12NameTranslator

    .. automethod:: reset

    .. automethod:: translate


--- End of file: r12strict.rst ---



--- Start of file: reactors.rst ---

.. _reactors:

Reactors
========

Persistent reactors are optional object handles of objects registering
themselves as reactors on an object. Any DXF object or DXF entity may have
reactors.

Use the high level methods of :class:`~ezdxf.entities.DXFEntity` to manage
persistent reactor handles.

- :meth:`~ezdxf.entities.DXFEntity.has_reactors`
- :meth:`~ezdxf.entities.DXFEntity.get_reactors`
- :meth:`~ezdxf.entities.DXFEntity.set_reactors`
- :meth:`~ezdxf.entities.DXFEntity.append_reactor_handle`
- :meth:`~ezdxf.entities.DXFEntity.discard_reactor_handle`

*Ezdxf* keeps these reactors only up to date, if this is absolute necessary
according to the DXF reference.

.. seealso::

    - Internals about :ref:`reactors_internals`
    - Internal Reactors management class: :class:`~ezdxf.entities.appdata.Reactors`


--- End of file: reactors.rst ---



--- Start of file: reference.rst ---

.. _reference:

Reference
=========

The `DXF Reference`_ is online available at `Autodesk`_.

Quoted from the original DXF 12 Reference which is not available on the web:

   Since the AutoCAD drawing database (.dwg file) is written in a
   compact format that changes significantly as new features are added
   to AutoCAD, we do not document its format and do not recommend that
   you attempt to write programs to read it directly. To assist in
   interchanging drawings between AutoCAD and other programs, a Drawing
   Interchange file format (DXF) has been defined. All implementations
   of AutoCAD accept this format and are able to convert it to and from
   their internal drawing file representation.

DXF Document
------------

.. toctree::
    :maxdepth: 2

    drawing/management
    drawing/drawing
    drawing/recover
    r12strict

DXF Structures
--------------

.. toctree::
    :maxdepth: 2

    sections/index
    tables/index
    blocks/index
    layouts/index
    groups
    dxfentities/index
    dxfobjects/index
    xdata
    appdata
    xdict
    reactors
    blkrefs
    const

Colors
------

.. toctree::
    :maxdepth: 1

    colors

Enums
-----

.. toctree::
    :maxdepth: 1

    enums


Math
----

.. toctree::
    :maxdepth: 2

    math/core
    math/clipping
    math/clustering
    math/linalg
    math/rtree
    math/triangulation

.. The borders between the "Construction" and the "Tools" section are blurry!

Construction
------------

.. Tools that alter the geometry of entities or create new entities.

.. toctree::
    :maxdepth: 1

    acis
    bbox
    disassemble
    edgeminer
    edgesmith
    math_construction_tools
    path
    reorder
    transform
    upright

Custom Data
-----------

.. toctree::
    :maxdepth: 1

    user_xdata
    user_record

Fonts
-----

.. toctree::
    :maxdepth: 2

    tools/fonts

Tools
-----

.. Tools that alter the visual appearance of entities or the DXF document itself.
   Tools that work with entities.

.. toctree::
    :maxdepth: 2

    tools/appsettings
    tools/comments
    tools/gfxattribs
    tasks/groupby
    tools/query
    tools/revcloud
    tasks/select
    tools/text
    tools/text_size
    tools/xclip
    tools/zoom
    render/index

**TODO:**

- ACAD_TABLE helper tools
- Dynamic Block helper tools


Global Options
--------------

.. toctree::
    :maxdepth: 1

    options

For Developers
--------------

.. toctree::
    :maxdepth: 2

    dxfinternals/index
    low_level_tools/functions
    low_level_tools/dxf_unicode_decoder
    low_level_tools/sat_crypt
    develop/index


.. _DXF Reference: http://docs.autodesk.com/ACD/2014/ENU/index.html?url=files/GUID-235B22E0-A567-4CF6-92D3-38A2306D73F3.htm,topicNumber=d30e652301
.. _Autodesk: http://usa.autodesk.com/

--- End of file: reference.rst ---



--- Start of file: render/arrows.rst ---

Arrows
======

.. module:: ezdxf.render.arrows

This module provides support for the AutoCAD standard arrow heads used in
DIMENSION, LEADER and MULTILEADER entities. Library user don't have to use the
:attr:`ARROWS` objects directly, but should know the arrow names stored in it as
attributes. The arrow names should be accessed that way:

.. code-block:: python

    import ezdxf

    arrow = ezdxf.ARROWS.closed_filled


.. attribute:: ARROWS

    Single instance of :class:`_Arrows` to work with.


.. class:: _Arrows

    Management object for standard arrows.

    .. attribute:: __acad__

        Set of AutoCAD standard arrow names.

    .. attribute:: __ezdxf__

        Set of arrow names special to `ezdxf`.

    .. attribute:: architectural_tick

        .. image:: gfx/_ARCHTICK.png

    .. attribute:: closed_filled

        .. image:: gfx/_CLOSEDFILLED.png

    .. attribute:: dot

        .. image:: gfx/_DOT.png

    .. attribute:: dot_small

        .. image:: gfx/_DOTSMALL.png

    .. attribute:: dot_blank

        .. image:: gfx/_DOTBLANK.png

    .. attribute:: origin_indicator

        .. image:: gfx/_ORIGIN.png

    .. attribute:: origin_indicator_2

        .. image:: gfx/_ORIGIN2.png

    .. attribute:: open

        .. image:: gfx/_OPEN.png

    .. attribute:: right_angle

        .. image:: gfx/_OPEN90.png

    .. attribute:: open_30

        .. image:: gfx/_OPEN30.png

    .. attribute:: closed

        .. image:: gfx/_CLOSED.png

    .. attribute:: dot_smallblank

        .. image:: gfx/_SMALL.png

    .. attribute:: none

        .. image:: gfx/_NONE.png

    .. attribute:: oblique

        .. image:: gfx/_OBLIQUE.png

    .. attribute:: box_filled

        .. image:: gfx/_BOXFILLED.png

    .. attribute:: box

        .. image:: gfx/_BOXBLANK.png

    .. attribute:: closed_blank

        .. image:: gfx/_CLOSEDBLANK.png

    .. attribute:: datum_triangle_filled

        .. image:: gfx/_DATUMFILLED.png

    .. attribute:: datum_triangle

        .. image:: gfx/_DATUMBLANK.png

    .. attribute:: integral

        .. image:: gfx/_INTEGRAL.png

    .. attribute:: ez_arrow

        .. image:: gfx/EZ_ARROW.png

    .. attribute:: ez_arrow_blank

        .. image:: gfx/EZ_ARROW_BLANK.png

    .. attribute:: ez_arrow_filled

        .. image:: gfx/EZ_ARROW_FILLED.png

    .. automethod:: is_acad_arrow

    .. automethod:: is_ezdxf_arrow

    .. automethod:: insert_arrow

    .. automethod:: render_arrow

    .. automethod:: virtual_entities


--- End of file: render/arrows.rst ---



--- Start of file: render/curves.rst ---

.. module:: ezdxf.render
    :noindex:

Spline
======

.. autoclass:: Spline

    .. automethod:: __init__

    .. automethod:: subdivide

    .. automethod:: render_as_fit_points

    .. automethod:: render_open_bspline

    .. automethod:: render_uniform_bspline

    .. automethod:: render_closed_bspline

    .. automethod:: render_open_rbspline

    .. automethod:: render_uniform_rbspline

    .. automethod:: render_closed_rbspline


R12Spline
=========

.. autoclass:: R12Spline

    .. automethod:: __init__

    .. automethod:: render

    .. automethod:: approximate


Bezier
======

.. autoclass:: Bezier

    .. automethod:: start

    .. automethod:: append

    .. automethod:: render

EulerSpiral
===========

.. autoclass:: EulerSpiral

    .. automethod:: __init__

    .. automethod:: render_polyline

    .. automethod:: render_spline


Random Paths
============

Random path generators for testing purpose.

.. autofunction:: random_2d_path

.. autofunction:: random_3d_path


--- End of file: render/curves.rst ---



--- Start of file: render/forms.rst ---

.. module:: ezdxf.render.forms

Forms
=====

    This module provides functions to create 2D and 3D forms as vertices or
    mesh objects.

    2D Forms

    - :func:`box`
    - :func:`circle`
    - :func:`ellipse`
    - :func:`euler_spiral`
    - :func:`gear`
    - :func:`ngon`
    - :func:`square`
    - :func:`star`
    - :func:`turtle`

    3D Forms

    - :func:`cone_2p`
    - :func:`cone`
    - :func:`cube`
    - :func:`cylinder`
    - :func:`cylinder_2p`
    - :func:`helix`
    - :func:`sphere`
    - :func:`torus`

    3D Form Builder

    - :func:`extrude`
    - :func:`extrude_twist_scale`
    - :func:`from_profiles_linear`
    - :func:`from_profiles_spline`
    - :func:`rotation_form`
    - :func:`sweep`
    - :func:`sweep_profile`


2D Forms
--------

    Basic 2D shapes as iterable of :class:`~ezdxf.math.Vec3`.


.. autofunction:: box

.. autofunction:: circle

.. autofunction:: ellipse

.. autofunction:: euler_spiral

.. autofunction:: gear

.. autofunction:: ngon

.. autofunction:: square

.. autofunction:: star

.. autofunction:: turtle


3D Forms
--------

Create 3D forms as :class:`~ezdxf.render.MeshTransformer` objects.

.. autofunction:: cube

.. autofunction:: cone

.. autofunction:: cone_2p

.. autofunction:: cylinder

.. autofunction:: cylinder_2p

.. autofunction:: helix

.. autofunction:: sphere

.. autofunction:: torus

3D Form Builder
---------------

.. autofunction:: extrude

.. autofunction:: extrude_twist_scale

.. autofunction:: from_profiles_linear

.. autofunction:: from_profiles_spline

.. autofunction:: rotation_form

.. autofunction:: sweep

.. autofunction:: sweep_profile


--- End of file: render/forms.rst ---



--- Start of file: render/hatching.rst ---


Hatching
========

.. module:: ezdxf.render.hatching

This module provides rendering support for hatch patterns as used in
:class:`~ezdxf.entities.Hatch` and :class:`~ezdxf.entities.MPolygon` entities.

High Level Functions
--------------------

.. autofunction:: hatch_entity

.. autofunction:: hatch_polygons

.. autofunction:: hatch_paths

Classes
-------

.. autoclass:: HatchBaseLine

    .. automethod:: hatch_line

    .. automethod:: pattern_renderer

    .. automethod:: signed_distance


.. autoclass:: HatchLine

    .. automethod:: intersect_line

    .. automethod:: intersect_cubic_bezier_curve


.. autoclass:: PatternRenderer

    .. automethod:: render


.. autoclass:: Intersection

    .. attribute:: type

        intersection type as :class:`IntersectionType` instance

    .. attribute:: p0

        (first) intersection point as :class:`~ezdxf.math.Vec2` instance

    .. attribute:: p1

        second intersection point as :class:`~ezdxf.math.Vec2` instance, only if
        :attr:`type` is COLLINEAR

.. autoclass:: IntersectionType

    .. attribute:: NONE

        no intersection

    .. attribute:: REGULAR

        regular intersection point at a polygon edge or a Bzier curve

    .. attribute:: START

        intersection point at the start vertex of a polygon edge

    .. attribute:: END

        intersection point at the end vertex of a polygon edge

    .. attribute:: COLLINEAR

        intersection is collinear to a polygon edge

.. autoclass:: Line

    .. attribute:: start

        start point as :class:`~ezdxf.math.Vec2` instance

    .. attribute:: end

        end point as :class:`~ezdxf.math.Vec2` instance


    .. attribute:: distance

        signed normal distance to the :class:`HatchBaseLine`


Helper Functions
----------------

.. autofunction:: hatch_boundary_paths

.. autofunction:: hatch_line_distances

.. autofunction:: pattern_baselines

Exceptions
----------

.. autoclass:: HatchingError

.. autoclass:: HatchLineDirectionError

.. autoclass:: DenseHatchingLinesError

--- End of file: render/hatching.rst ---



--- Start of file: render/index.rst ---

.. _render:

.. module:: ezdxf.render

Render Tools
============

The :mod:`ezdxf.render` subpackage provides helpful utilities to create complex
forms.

- create complex meshes as :class:`~ezdxf.entities.Mesh` entity.
- render complex curves like bezier curves, euler spirals or splines as
  :class:`~ezdxf.entities.Polyline` entity
- vertex generators for simple and complex forms like circle, ellipse or euler spiral

.. rubric:: Content

.. toctree::
    :maxdepth: 1

    curves
    forms
    mesh
    trace
    point
    mleader
    arrows
    hatching



--- End of file: render/index.rst ---



--- Start of file: render/mesh.rst ---

.. module:: ezdxf.render
    :noindex:

MeshBuilder
===========

The :class:`MeshBuilder` classes are helper tools to manage meshes buildup by
vertices and faces.
The vertices are stored in a vertices list as :class:`Vec3` instances.
The faces are stored as a sequence of vertex indices which is the location of
the vertex in the vertex list. A single :class:`MeshBuilder` class can contain
multiple separated meshes at the same time.

The method :meth:`MeshBuilder.render_mesh` renders the content as a single DXF
:class:`~ezdxf.entities.Mesh` entity, which supports ngons, ngons are polygons
with more than 4 vertices. This entity requires at least DXF R2000.

The method :meth:`MeshBuilder.render_polyface` renders the content as a single
DXF :class:`~ezdxf.entities.Polyface` entity, which supports only triangles and
quadrilaterals. This entity is supported by DXF R12.

The method :meth:`MeshBuilder.render_3dfaces` renders each face of the mesh as
a single  DXF :class:`~ezdxf.entities.Face3d` entity, which supports only
triangles and quadrilaterals. This entity is supported by DXF R12.

The :class:`MeshTransformer` class is often used as an interface object to
transfer mesh data between functions and moduls, like for the mesh exchange
add-on :mod:`~ezdxf.addons.meshex`.

The basic :class:`MeshBuilder` class does not support transformations.

.. class:: MeshBuilder

    .. attribute:: vertices

        List of vertices as :class:`~ezdxf.math.Vec3` or ``(x, y, z)`` tuple

    .. attribute:: faces

        List of faces as list of vertex indices,  where a vertex index is the
        index of the vertex in the :attr:`vertices` list. A face requires at
        least three vertices, :class:`~ezdxf.entities.Mesh` supports ngons,
        so the count of vertices is not limited.

    .. automethod:: add_face

    .. automethod:: add_mesh

    .. automethod:: add_vertices

    .. automethod:: bbox

    .. automethod:: copy

    .. automethod:: diagnose

    .. automethod:: face_normals

    .. automethod:: face_orientation_detector

    .. automethod:: faces_as_vertices

    .. automethod:: flip_normals

    .. automethod:: from_builder(other: MeshBuilder)

    .. automethod:: from_mesh

    .. automethod:: from_polyface

    .. automethod:: get_face_vertices

    .. automethod:: get_face_normal

    .. automethod:: merge_coplanar_faces

    .. automethod:: mesh_tessellation

    .. automethod:: normalize_faces

    .. automethod:: open_faces

    .. automethod:: optimize_vertices

    .. automethod:: render_3dfaces

    .. automethod:: render_3dsolid

    .. automethod:: render_mesh

    .. automethod:: render_normals

    .. automethod:: render_polyface

    .. automethod:: separate_meshes

    .. automethod:: subdivide

    .. automethod:: subdivide_ngons

    .. automethod:: tessellation

    .. automethod:: unify_face_normals

    .. automethod:: unify_face_normals_by_reference


MeshTransformer
===============

Same functionality as :class:`MeshBuilder` but supports inplace transformation.

.. class:: MeshTransformer

    Subclass of :class:`MeshBuilder`

    .. automethod:: transform

    .. automethod:: translate

    .. automethod:: scale

    .. automethod:: scale_uniform

    .. automethod:: rotate_x

    .. automethod:: rotate_y

    .. automethod:: rotate_z

    .. automethod:: rotate_axis

MeshVertexMerger
================

Same functionality as :class:`MeshBuilder`, but created meshes with unique
vertices and no doublets, but :class:`MeshVertexMerger` needs extra memory for
bookkeeping and also does not support transformations.
The location of the merged vertices is the location of the first vertex with the
same key.

This class is intended as intermediate object to create compact meshes and
convert them to :class:`MeshTransformer` objects to apply transformations:

.. code-block:: Python

    mesh = MeshVertexMerger()

    # create your mesh
    mesh.add_face(...)

    # convert mesh to MeshTransformer object
    return MeshTransformer.from_builder(mesh)

.. autoclass:: MeshVertexMerger

MeshAverageVertexMerger
=======================

This is an extended version of :class:`MeshVertexMerger`.
The location of the merged vertices is the average location of all vertices with
the same key, this needs extra memory and runtime in comparison to
:class:`MeshVertexMerger` and this class also does not support
transformations.

.. autoclass:: MeshAverageVertexMerger

.. autoclass:: ezdxf.render.mesh.EdgeStat

    .. attribute:: count

        how often the edge `(a, b)` is used in faces as `(a, b)` or `(b, a)`

    .. attribute:: balance

        count of edges `(a, b)` - count of edges `(b, a)` and should be 0 in
        "healthy" closed surfaces, if the balance is not 0, maybe doubled
        coincident faces exist or faces may have mixed clockwise and
        counter-clockwise vertex orders

MeshBuilder Helper Classes
==========================

.. class:: MeshDiagnose

    Diagnose tool which can be used to analyze and detect errors of
    :class:`MeshBuilder` objects like topology errors for closed surfaces.
    The object contains cached values, which do not get updated if the source
    mesh will be changed!

    .. note::

        There exist no tools in `ezdxf` to repair broken surfaces, but you can
        use the :mod:`ezdxf.addons.meshex` addon to exchange meshes with the
        open source tool `MeshLab <https://www.meshlab.net/>`_.

    Create an instance of this tool by the :meth:`MeshBuilder.diagnose` method.

    .. autoproperty:: bbox

    .. autoproperty:: edge_stats

    .. autoproperty:: euler_characteristic

    .. autoproperty:: face_normals

    .. autoproperty:: faces

    .. autoproperty:: is_closed_surface

    .. autoproperty:: is_edge_balance_broken

    .. autoproperty:: is_manifold

    .. autoproperty:: n_edges

    .. autoproperty:: n_faces

    .. autoproperty:: n_vertices

    .. autoproperty:: vertices

    .. automethod:: centroid

    .. automethod:: estimate_face_normals_direction

    .. automethod:: has_non_planar_faces

    .. automethod:: surface_area

    .. automethod:: total_edge_count

    .. automethod:: unique_edges

    .. automethod:: volume


.. autoclass:: FaceOrientationDetector

    .. attribute:: is_manifold

        ``True`` if all edges have an edge count < 3. A non-manifold mesh has
        edges with 3 or more connected faces.

    .. autoproperty:: all_reachable

    .. autoproperty:: count

    .. autoproperty:: backward_faces

    .. autoproperty:: forward_faces

    .. autoproperty:: has_uniform_face_normals

    .. autoproperty:: is_closed_surface

    .. autoproperty:: is_single_mesh

    .. automethod:: classify_faces

    .. automethod:: is_reference_face_pointing_outwards



--- End of file: render/mesh.rst ---



--- Start of file: render/mleader.rst ---

.. module:: ezdxf.render
    :noindex:

MultiLeaderBuilder
==================

These are helper classes to build :class:`~ezdxf.entities.MultiLeader` entities
in an easy way.  The :class:`MultiLeader` entity supports two kinds of content,
for each exist a specialized builder class:

- :class:`MultiLeaderMTextBuilder` for :class:`~ezdxf.entities.MText` content
- :class:`MultiLeaderBlockBuilder` for :class:`~ezdxf.entities.Block` content

The usual steps of the building process are:

    1. create entity by a factory method

        - :meth:`~ezdxf.layouts.BaseLayout.add_multileader_mtext`
        - :meth:`~ezdxf.layouts.BaseLayout.add_multileader_block`

    2. set the content

        - :meth:`MultiLeaderMTextBuilder.set_content`
        - :meth:`MultiLeaderBlockBuilder.set_content`
        - :meth:`MultiLeaderBlockBuilder.set_attribute`

    3. set properties

        - :meth:`MultiLeaderBuilder.set_arrow_properties`
        - :meth:`MultiLeaderBuilder.set_connection_properties`
        - :meth:`MultiLeaderBuilder.set_connection_types`
        - :meth:`MultiLeaderBuilder.set_leader_properties`
        - :meth:`MultiLeaderBuilder.set_mleader_style`
        - :meth:`MultiLeaderBuilder.set_overall_scaling`

    4. add one or more leader lines

        - :meth:`MultiLeaderBuilder.add_leader_line`

    5. finalize building process

        - :meth:`MultiLeaderBuilder.build`

The :ref:`tut_mleader` shows how to use these helper classes in more detail.

.. class:: MultiLeaderBuilder

    Abstract base class to build :class:`~ezdxf.entities.MultiLeader` entities.

    .. autoproperty:: context

    .. autoproperty:: multileader

    .. automethod:: add_leader_line

    .. automethod:: build

    .. automethod:: set_arrow_properties

    .. automethod:: set_connection_properties

    .. automethod:: set_connection_types

    .. automethod:: set_leader_properties

    .. automethod:: set_mleader_style

    .. automethod:: set_overall_scaling


MultiLeaderMTextBuilder
-----------------------

Specialization of :class:`MultiLeaderBuilder` to build :class:`~ezdxf.entities.MultiLeader`
with MTEXT content.

.. class:: MultiLeaderMTextBuilder

    .. automethod:: set_content

    .. automethod:: quick_leader

MultiLeaderBlockBuilder
-----------------------

Specialization of :class:`MultiLeaderBuilder` to build :class:`~ezdxf.entities.MultiLeader`
with BLOCK content.

.. class:: MultiLeaderBlockBuilder

    .. autoproperty:: block_layout

    .. autoproperty:: extents

    .. automethod:: set_content

    .. automethod:: set_attribute

Enums
-----

.. autoclass:: LeaderType

    .. attribute:: none

    .. attribute:: straight_lines

    .. attribute:: splines

.. autoclass:: ConnectionSide

    .. attribute:: left

    .. attribute:: right

    .. attribute:: top

    .. attribute:: bottom

.. autoclass:: HorizontalConnection

    .. attribute:: by_style

    .. attribute:: top_of_top_line

    .. attribute:: middle_of_top_line

    .. attribute:: middle_of_text

    .. attribute:: middle_of_bottom_line

    .. attribute:: bottom_of_bottom_line

    .. attribute:: bottom_of_bottom_line_underline

    .. attribute:: bottom_of_top_line_underline

    .. attribute:: bottom_of_top_line

    .. attribute:: bottom_of_top_line_underline_all

.. autoclass:: VerticalConnection

    .. attribute:: by_style

    .. attribute:: center

    .. attribute:: center_overline

.. autoclass:: TextAlignment

    .. attribute:: left

    .. attribute:: center

    .. attribute:: right

.. autoclass:: BlockAlignment

    .. attribute:: center_extents

    .. attribute:: insertion_point



--- End of file: render/mleader.rst ---



--- Start of file: render/point.rst ---

.. module:: ezdxf.render.point

Point Rendering
===============

Helper function to render :class:`~ezdxf.entities.Point` entities as DXF
primitives.

.. autofunction:: virtual_entities

.. seealso::

    Go to :class:`ezdxf.entities.Point` class documentation for more information
    about POINT styling modes.

--- End of file: render/point.rst ---



--- Start of file: render/trace.rst ---

.. module:: ezdxf.render.trace

Trace
=====

This module provides tools to create banded lines like LWPOLYLINE with width information.
Path rendering as quadrilaterals: :class:`~ezdxf.entities.Trace`,
:class:`~ezdxf.entities.Solid` or :class:`~ezdxf.entities.Face3d`.


.. autoclass:: TraceBuilder

    .. attribute:: abs_tol

        Absolute tolerance for floating point comparisons

    .. automethod:: append

    .. automethod:: close

    .. automethod:: faces

    .. automethod:: faces_wcs

    .. automethod:: virtual_entities

    .. automethod:: from_polyline

    .. method:: __len__

    .. method:: __getitem__

.. autoclass:: LinearTrace

    .. attribute:: abs_tol

        Absolute tolerance for floating point comparisons

    .. autoattribute:: is_started

    .. automethod:: add_station

    .. automethod:: faces

    .. automethod:: virtual_entities

.. autoclass:: CurvedTrace

    .. automethod:: faces

    .. automethod:: virtual_entities

    .. automethod:: from_arc

    .. automethod:: from_spline


--- End of file: render/trace.rst ---



--- Start of file: reorder.rst ---

Reorder
=======

.. module:: ezdxf.reorder

Tools to reorder DXF entities by handle or a special sort handle mapping.

Such reorder mappings are stored only in layouts as :class:`~ezdxf.layouts.Modelspace`,
:class:`~ezdxf.layouts.Paperspace` or :class:`~ezdxf.layouts.BlockLayout`,
and can be retrieved by the method :meth:`~ezdxf.layouts.Layout.get_redraw_order`.

Each entry in the handle mapping replaces the actual entity handle, where the
"0" handle has a special meaning, this handle always shows up at last in
ascending ordering.

.. autofunction:: ascending

.. autofunction:: descending



--- End of file: reorder.rst ---



--- Start of file: sections/blocks.rst ---

Blocks Section
==============

.. module:: ezdxf.sections.blocks

The BLOCKS section is the home all block definitions (:class:`~ezdxf.layouts.BlockLayout`)
of a DXF document.

.. warning::

    Blocks are an essential building block of the DXF format. Most blocks are referenced
    are by name, and renaming or deleting a block is not as easy as it seems,
    since there is no overall index where all block references appear, and such block
    references can also reside in custom data or even custom entities,
    therefore renaming or deleting block definitions can damage a DXF file!

.. seealso::

    DXF Internals: :ref:`blocks_section_internals` and :ref:`Block Management Structures`

.. class:: BlocksSection

    .. automethod:: __iter__

    .. automethod:: __contains__

    .. automethod:: __getitem__

    .. automethod:: __delitem__

    .. automethod:: get

    .. automethod:: new

    .. automethod:: new_anonymous_block

    .. automethod:: rename_block

    .. automethod:: delete_block

    .. automethod:: delete_all_blocks




--- End of file: sections/blocks.rst ---



--- Start of file: sections/classes.rst ---

Classes Section
===============

The CLASSES section in DXF files holds the information for application-defined classes
whose instances appear in :class:`~ezdxf.layouts.Layout` objects. As usual package user
there is no need to bother about CLASSES.

.. seealso::

    DXF Internals: :ref:`classes_section_internals`

.. module:: ezdxf.sections.classes

.. class:: ClassesSection

    .. attribute:: classes

        Storage of all :class:`~ezdxf.entities.DXFClass` objects, they are not stored in
        the entities database, because CLASS instances do not have a handle attribute.

    .. method:: register

    .. automethod:: add_class

    .. automethod:: get

    .. automethod:: add_required_classes

    .. automethod:: update_instance_counters

.. module:: ezdxf.entities
    :noindex:

.. class:: DXFClass

    Information about application-defined classes.

    .. attribute:: dxf.name

        Class DXF record name.

    .. attribute:: dxf.cpp_class_name

        C++ class name. Used to bind with software that defines object class behavior.

    .. attribute:: dxf.app_name

        Application name. Posted in Alert box when a class definition listed in this section is not currently loaded.

    .. attribute:: dxf.flags

        Proxy capabilities flag

        ======= =========================
        0       No operations allowed (0)
        1       Erase allowed (0x1)
        2       Transform allowed (0x2)
        4       Color change allowed (0x4)
        8       Layer change allowed (0x8)
        16      Linetype change allowed (0x10)
        32      Linetype scale change allowed (0x20)
        64      Visibility change allowed (0x40)
        128     Cloning allowed (0x80)
        256     Lineweight change allowed (0x100)
        512     Plot Style Name change allowed (0x200)
        895     All operations except cloning allowed (0x37F)
        1023    All operations allowed (0x3FF)
        1024    Disables proxy warning dialog (0x400)
        32768   R13 format proxy (0x8000)
        ======= =========================

    .. attribute:: dxf.instance_count

        Instance count for a custom class.

    .. attribute:: dxf.was_a_proxy

        Set to ``1`` if class was not loaded when this DXF file was created, and ``0`` otherwise.

    .. attribute:: dxf.is_an_entity

        Set to ``1`` if class was derived from the :class:`DXFGraphic` class and can reside in layouts.
        If ``0``, instances may appear only in the OBJECTS section.

    .. attribute:: key

        Unique name as ``(name, cpp_class_name)`` tuple.

--- End of file: sections/classes.rst ---



--- Start of file: sections/entities.rst ---

Entities Section
================

.. module:: ezdxf.sections.entities

The ENTITIES section is the home of all entities of the :class:`~ezdxf.layouts.Modelspace`
and the active :class:`~ezdxf.layouts.Paperspace` layout.  This is a real section in the
DXF file but in `ezdxf` the :class:`EntitySection` is just a linked entity space of
these two layouts.

.. seealso::

    DXF Internals: :ref:`entities_section_internals`

.. class:: EntitySection

    .. automethod:: __iter__

    .. automethod:: __len__



--- End of file: sections/entities.rst ---



--- Start of file: sections/header.rst ---

Header Section
==============

.. module:: ezdxf.sections.header

The drawing settings are stored in the HEADER section, which is accessible by
the :attr:`~ezdxf.document.Drawing.header` attribute of the
:class:`~ezdxf.document.Drawing` object. See the online documentation from
Autodesk for available `header variables`_.

.. seealso::

    DXF Internals: :ref:`header_section_internals`

.. class:: HeaderSection

    .. attribute:: custom_vars

       Stores the custom drawing properties in a :class:`CustomVars` object.

    .. automethod:: __len__

    .. automethod:: __contains__

    .. automethod:: varnames

    .. automethod:: get

    .. automethod:: __getitem__

    .. automethod:: __setitem__

    .. automethod:: __delitem__

    .. automethod:: reset_wcs


.. autoclass:: CustomVars

    .. attribute:: properties

        A list of custom header properties, stored as string tuples ``(tag, value)``.
        Multiple occurrence of the same custom tag is allowed, but not well
        supported by the interface. This is a standard Python list and it's safe
        to modify this list as long as you just use tuples of strings.

    .. automethod:: __len__

    .. automethod:: __iter__

    .. automethod:: clear

    .. automethod:: get

    .. automethod:: has_tag

    .. automethod:: append

    .. automethod:: replace

    .. automethod:: remove


.. _header variables: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A85E8E67-27CD-4C59-BE61-4DC9FADBE74A

--- End of file: sections/header.rst ---



--- Start of file: sections/index.rst ---

Sections
========

.. toctree::
    :maxdepth: 2

    header
    classes
    tables
    blocks
    entities
    objects


--- End of file: sections/index.rst ---



--- Start of file: sections/objects.rst ---

Objects Section
===============

.. module:: ezdxf.sections.objects

The OBJECTS section is the home of all none graphical objects of a DXF document.
The OBJECTS section is accessible by the :attr:`Drawing.objects` attribute.


Convenience methods of the :class:`~ezdxf.document.Drawing` object to create essential
structures in the OBJECTS section:

    - IMAGEDEF: :meth:`~ezdxf.document.Drawing.add_image_def`
    - UNDERLAYDEF: :meth:`~ezdxf.document.Drawing.add_underlay_def`
    - RASTERVARIABLES: :meth:`~ezdxf.document.Drawing.set_raster_variables`
    - WIPEOUTVARIABLES: :meth:`~ezdxf.document.Drawing.set_wipeout_variables`

.. seealso::

    DXF Internals: :ref:`objects_section_internals`

.. class:: ObjectsSection

    .. autoattribute:: rootdict

    .. automethod:: __len__

    .. automethod:: __iter__

    .. automethod:: __getitem__

    .. automethod:: __contains__

    .. automethod:: query

    .. automethod:: add_dictionary

    .. automethod:: add_dictionary_with_default

    .. automethod:: add_dictionary_var

    .. automethod:: add_geodata

    .. automethod:: add_image_def

    .. automethod:: add_placeholder

    .. automethod:: add_underlay_def

    .. automethod:: add_xrecord

    .. automethod:: set_raster_variables

    .. automethod:: set_wipeout_variables






--- End of file: sections/objects.rst ---



--- Start of file: sections/tables.rst ---

Tables Section
==============

.. module:: ezdxf.sections.tables

The TABLES section is the home of all TABLE objects of a DXF document.

.. seealso::

    DXF Internals: :ref:`tables_section_internals`

.. class:: TablesSection

    .. attribute:: layers

        :class:`~ezdxf.sections.table.LayerTable` maintaining the
        :class:`~ezdxf.entities.Layer` objects

    .. attribute:: linetypes

        :class:`~ezdxf.sections.table.LinetypeTable` maintaining the
        :class:`~ezdxf.entities.Linetype` objects

    .. attribute:: styles

        :class:`~ezdxf.sections.table.TextstyleTable` maintaining the
        :class:`~ezdxf.entities.Textstyle` objects

    .. attribute:: dimstyles

        :class:`~ezdxf.sections.table.DimStyleTable` maintaining the
        :class:`~ezdxf.entities.DimStyle` objects

    .. attribute:: appids

        :class:`~ezdxf.sections.table.AppIDTable` maintaining the
        :class:`~ezdxf.entities.AppID` objects

    .. attribute:: ucs

        :class:`~ezdxf.sections.table.UCSTable` maintaining the
        :class:`~ezdxf.entities.UCSTable` objects

    .. attribute:: views

        :class:`~ezdxf.sections.table.ViewTable` maintaining the
        :class:`~ezdxf.entities.View` objects

    .. attribute:: viewports

        :class:`~ezdxf.sections.table.ViewportTable` maintaining the
        :class:`~ezdxf.entities.VPort` objects

    .. attribute:: block_records

        :class:`~ezdxf.sections.table.BlockRecordTable` maintaining the
        :class:`~ezdxf.entities.BlockRecord` objects




--- End of file: sections/tables.rst ---



--- Start of file: setup.rst ---


Setup & Dependencies
====================

The primary goal is to keep the dependencies of the `core` package as small
as possible. The add-ons are not part of the core package and can therefore
use as many packages as needed. The only requirement for these packages is an
easy way to install them on `Windows`, `Linux` and `macOS`, preferably as::

    pip3 install ezdxf

The packages `pyparsing`_, `numpy`_, `fontTools`_ and `typing_extensions`_ are the hard
dependency and will be installed automatically by `pip3`!

The minimal required Python version is determined by the latest release version
of `numpy`_.

Basic Installation
------------------

The most common case is the installation by `pip3` including the optional
C-extensions from `PyPI`_ as binary wheels::

    pip3 install ezdxf

Installation with Extras
------------------------

To use all features of the drawing add-on, add the ``[draw]`` tag::

    pip3 install ezdxf[draw]

=========== ===================================================
Tag         Additional Installed Packages
=========== ===================================================
``[draw]``  `Matplotlib`_, `PySide6`_, `PyMuPDF`_, `Pillow`_
``[dev]``   ``[draw]`` + setuptools, wheel, Cython, pytest (full development setup)
=========== ===================================================

If `PySide6`_ is not available on your system, use `PyQt5`_ by this options:

=========== ===================================================
Tag         Additional Installed Packages
=========== ===================================================
``[draw5]`` `Matplotlib`_, `PyQt5`_, `PyMuPDF`_, `Pillow`_ 
``[dev5]``  ``[draw5]`` + setuptools, wheel, Cython, pytest (full development setup)
=========== ===================================================

PySide6 Issue
-------------

Maybe `PySide6`_ won't launch on Debian based distributions and shows this error message:

.. code-block:: Text

    qt.qpa.plugin: Could not load the Qt platform plugin "xcb" in "" even though it was found.
    ...

This may fix the issue:

.. code-block:: Text

    sudo apt-get install libxcb-cursor0


Binary Wheels
-------------

Ezdxf includes some C-extensions, which will be deployed
automatically at each release to `PyPI`_ as binary wheels to `PyPI`:

- `Windows`: only amd64 packages
- `Linux`: manylinux and musllinux packages for x86_64 & aarch64
- `macOS`: x86_64, arm64 and universal packages

The wheels are created by the continuous integration (CI) service provided by
`GitHub`_ and the build container `cibuildwheel`_ provided by `PyPA`_ the Python
Packaging Authority.
The `workflows`_ are kept short and simple, so my future me will understand what's
going on and they are maybe also helpful for other developers which do not touch
CI services every day.

The C-extensions are disabled for `pypy3`_, because the JIT compiled code of pypy
is much faster than the compiled C-extensions.

Disable C-Extensions
--------------------

It is possible to disable the C-Extensions by setting the
environment variable ``EZDXF_DISABLE_C_EXT`` to ``1`` or ``true``::

    set EZDXF_DISABLE_C_EXT=1

or on Linux::

    export EZDXF_DISABLE_C_EXT=1

This is has to be done **before** anything from `ezdxf` is imported! If you are
working in an interactive environment, you have to restart the interpreter.


Installation from GitHub
------------------------

Install the latest development version by `pip3` from `GitHub`_::

    pip3 install git+https://github.com/mozman/ezdxf.git@master

Build and Install from Source
-----------------------------

This is only required if you want the compiled C-extensions, the `ezdxf`
installation by `pip` from the source code package works without the C-extension
but is slower. There are binary wheels available on `PyPi`_ which included the
compiled C-extensions.

Windows
+++++++

Make a build directory and a virtual environment::

    mkdir build
    cd build
    py -m venv .venv
    .venv/Scripts/activate.bat


A working C++ compiler setup is required to compile the C-extensions from source
code. Windows users need the build tools from
Microsoft: https://visualstudio.microsoft.com/de/downloads/

Download and install the required Visual Studio Installer of the community
edition and choose the option: `Visual Studio Build Tools 20..`

Install required packages to build and install ezdxf with C-extensions::

    pip3 install setuptools wheel cython

Clone the `GitHub`_ repository::

    git clone https://github.com/mozman/ezdxf.git

Build and install ezdxf from source code::

    cd ezdxf
    pip3 install .

Check if the installation was successful::

    python3 -m ezdxf -V

The `ezdxf` command should run without a preceding `python3 -m`, but calling the
launcher through the interpreter guarantees to call the version which was
installed in the venv if there exist a global installation of `ezdxf` like in
my development environment.

The output should look like this::

    ezdxf 0.17.2b4 from D:\Source\build\.venv\lib\site-packages\ezdxf
    Python version: 3.10.1 (tags/v3.10.1:2cd268a, Dec  6 2021, 19:10:37) [MSC v.1929 64 bit (AMD64)]
    using C-extensions: yes
    using Matplotlib: no

To install optional packages go to section: `Install Optional Packages`_

To run the included tests go to section: `Run the Tests`_

WSL & Ubuntu
++++++++++++

I use sometimes the Windows Subsystem for Linux (`WSL`_) with `Ubuntu`_ 20.04 LTS
for some tests (how to install `WSL`_).

By doing as fresh install on `WSL & Ubuntu`, I encountered an additional
requirement, the `build-essential` package adds the required C++ support and the
`python3.10-dev` package the required headers, change `3.10` to the Python version you
are using::

    sudo apt install build-essential python3.10-dev

The system Python 3 interpreter has the version 3.8 (in 2021), but I will show
in a later section how to install an additional newer Python version from the
source code::

    cd ~
    mkdir build
    cd build
    python3 -m venv .venv
    source .venv/bin/activate

Install `Cython` and `wheel` in the venv to get the C-extensions compiled::

    pip3 install cython wheel

Clone the `GitHub`_ repository::

    git clone https://github.com/mozman/ezdxf.git

Build and install ezdxf from source code::

    cd ezdxf
    pip3 install .

Check if the installation was successful::

    python3 -m ezdxf -V

The output should look like this::

    ezdxf 0.17.2b4 from /home/mozman/src/.venv/lib/python3.8/site-packages/ezdxf
    Python version: 3.8.10 (default, Nov 26 2021, 20:14:08)
    [GCC 9.3.0]
    using C-extensions: yes
    using Matplotlib: no

To install optional packages go to section: `Install Optional Packages`_

To run the included tests go to section: `Run the Tests`_

Raspberry Pi OS
+++++++++++++++

Testing platform is a `Raspberry Pi`_ 400 and the OS is the `Raspberry Pi`_ OS
which runs on 64bit hardware but is a 32bit OS. The system Python 3
interpreter comes in version 3.7 (in 2021), but I will show in a later
section how to install an additional newer Python version from the source code.

Install the build requirements, `Matplotlib`_ and the `PyQt5`_ bindings
from the distribution repository::

    sudo apt install python3-pip python3-matplotlib python3-pyqt5

Installing `Matplotlib`_ and the `PyQt5`_ bindings by `pip` from `piwheels`_
in the venv worked, but the packages showed errors at import, seems to be an
packaging error in the required `numpy`_ package.
`PySide6`_ is the preferred Qt binding but wasn't available on `Raspberry Pi`_
OS at the time of writing this - `PyQt5`_ is supported as fallback.

Create the venv with access to the system site-packages for using `Matplotlib`_
and the Qt bindings from the system installation::

    cd ~
    mkdir build
    cd build
    python3 -m venv --system-site-packages .venv
    source .venv/bin/activate

Install `Cython` and  `wheel` in the venv to get the C-extensions compiled::

    pip3 install cython wheel

Clone the `GitHub`_ repository::

    git clone https://github.com/mozman/ezdxf.git

Build and install ezdxf from source code::

    cd ezdxf
    pip3 install .

Check if the installation was successful::

    python3 -m ezdxf -V

The output should look like this::

    ezdxf 0.17.2b4 from /home/pi/src/.venv/lib/python3.7/site-packages/ezdxf
    Python version: 3.7.3 (default, Jan 22 2021, 20:04:44)
    [GCC 8.3.0]
    using C-extensions: yes
    using Matplotlib: yes

To run the included tests go to section: `Run the Tests`_

Manjaro on Raspberry Pi
+++++++++++++++++++++++

Because the (very well working) `Raspberry Pi`_ OS is only a 32bit OS, I searched
for a 64bit alternative like `Ubuntu`_, which just switched to version 21.10 and
always freezes at the installation process! So I tried `Manjaro`_ as rolling
release, which I used prior in a virtual machine and wasn't really happy,
because there is always something to update. Anyway the distribution
looks really nice and has Python 3.9.9 installed.

Install build requirements and optional packages by the system packager
`pacman`::

    sudo pacman -S python-pip python-matplotlib python-pyqt5

Create and activate the venv::

    cd ~
    mkdir build
    cd build
    python3 -m venv --system-site-packages .venv
    source .venv/bin/activate

The rest is the same procedure as for the `Raspberry Pi OS`_::

    pip3 install cython wheel
    git clone https://github.com/mozman/ezdxf.git
    cd ezdxf
    pip3 install .
    python3 -m ezdxf -V

To run the included tests go to section: `Run the Tests`_

Ubuntu Server 21.10 on Raspberry Pi
+++++++++++++++++++++++++++++++++++

I gave the `Ubuntu`_ Server 21.10 a chance after the desktop version failed to
install by a nasty bug and it worked well.
The distribution comes with Python 3.9.4 and after installing some
requirements::

    sudo apt install build-essential python3-pip python3.9-venv

The remaining process is like on `WSL & Ubuntu`_ except for the newer Python
version. Installing `Matplotlib`_ by `pip` works as expected and is maybe useful
even on a headless server OS to create SVG and PNG from DXF files.
`PySide6`_ is not available by `pip` and the installation of `PyQt5`_ starts from
the source code package which I stopped because this already didn't finished
on `Manjaro`_, but the installation of the `PyQt5`_ bindings by `apt` works::

    sudo apt install python3-pyqt5

Use the ``--system-site-packages`` option for creating the venv to get access to
the `PyQt5`_ package.

Install Optional Packages
-------------------------

Install the optional dependencies by `pip` only for `Windows`_ and
`WSL & Ubuntu`_, for `Raspberry Pi OS`_ and `Manjaro on Raspberry Pi`_ install
these packages by the system packager::

    pip3 install matplotlib PySide6

Run the Tests
-------------

This is the same procedure for all systems, assuming you are still in
the build directory `build/ezdxf` and `ezdxf` is now installed in the venv.

Install the test dependencies and run the tests::

    pip3 install pytest
    python3 -m pytest tests integration_tests

Build Documentation
-------------------

Assuming you are still in the build directory `build/ezdxf` of the previous
section.

Install Sphinx::

    pip3 install Sphinx sphinx-rtd-theme

Build the HTML documentation::

    cd docs
    make html

The output is located in `build/ezdxf/docs/build/html`.

Python from Source
------------------

Debian based systems have often very outdated software installed and
sometimes there is no easy way to install a newer Python version.
This is a brief summery how I installed Python 3.9.9 on the `Raspberry Pi`_ OS,
for more information go to the source of the recipe: `Real Python`_

Install build requirements::

    sudo apt-get update
    sudo apt-get upgrade

    sudo apt-get install -y make build-essential libssl-dev zlib1g-dev \
       libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \
       libncurses5-dev libncursesw5-dev xz-utils tk-dev

Make a build directory::

    cd ~
    mkdir build
    cd build

Download and unpack the source code from `Python.org`_, replace 3.9.9 by
your desired version::

    wget https://www.python.org/ftp/python/3.9.9/Python-3.9.9.tgz
    tar -xvzf Python-3.9.9.tgz
    cd Python-3.9.9/

Configure the build process, use a prefix to the directory where the
interpreter should be installed::

    ./configure --prefix=/opt/python3.9.9 --enable-optimizations

Build & install the Python interpreter. The `-j` option simply tells `make` to
split the building into parallel steps to speed up the compilation, my
`Raspberry Pi`_ 400 has 4 cores so 4 seems to be a good choice::

    make -j 4
    sudo make install

The building time was ~25min and the new Python 3.9.9 interpreter is now
installed as `/opt/python3.9.9/bin/python3`.

At the time there were no system packages for `Matplotlib`_ and `PyQt5`_ for
this new Python version available, so there is no benefit of using the option
``--system-site-packages`` for building the venv::

    cd ~/build
    /opt/python3.9.9/bin/python3 -m venv py39
    source py39/bin/activate

I have not tried to build `Matplotlib`_ and `PyQt5`_ by myself and the
installation by `pip` from `piwheels`_ did not work, in this case the `drawing` add-on
will not work.

Proceed with the `ezdxf` installation from source as shown for the  `Raspberry Pi OS`_.

.. _Real Python:  https://realpython.com/installing-python/#how-to-build-python-from-source-code
.. _python.org: https://www.python.org
.. _piwheels: https://piwheels.org
.. _Matplotlib: https://matplotlib.org
.. _Manjaro: https://www.manjaro.org
.. _Ubuntu: https://ubuntu.com
.. _Raspberry Pi: https://www.raspberrypi.com
.. _wsl: https://docs.microsoft.com/en-us/windows/wsl/install
.. _pyqt5: https://pypi.org/project/PyQt5/
.. _pyside6: https://pypi.org/project/PySide6/
.. _pillow: https://pypi.org/project/Pillow/
.. _PyMuPDF: https://pypi.org/project/PyMuPDF/
.. _numpy: https://pypi.org/project/numpy/
.. _fontTools: https://pypi.org/project/fonttools/
.. _pyparsing: https://pypi.org/project/pyparsing/
.. _typing_extensions: https://pypi.org/project/typing_extensions/
.. _pypi: https://pypi.org/project/ezdxf
.. _pypy3: https://www.pypy.org
.. _pypa: https://www.pypa.io/en/latest/
.. _cibuildwheel: https://github.com/pypa/cibuildwheel
.. _github: https://github.com
.. _workflows: https://github.com/mozman/ezdxf/tree/master/.github/workflows

--- End of file: setup.rst ---



--- Start of file: tables/appid_table_entry.rst ---

AppID
=====

.. module:: ezdxf.entities
    :noindex:

Defines an APPID (`DXF Reference`_). These table entries maintain a set of names
for all registered applications.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFEntity`
DXF type                 ``'APPID'``
Factory function         :meth:`Drawing.appids.new`
======================== ==========================================

.. class:: AppID

    .. attribute:: dxf.owner

        Handle to owner (:class:`~ezdxf.sections.table.Table`).

    .. attribute:: dxf.name

        User-supplied (or application-supplied) application name (for extended data).

    .. attribute:: dxf.flags

        Standard flag values (bit-coded values):

        === =========================================================
        16  If set, table entry is externally dependent on an xref
        32  If both this bit and bit 16 are set, the externally dependent xref
            has been successfully resolved
        64  If set, the table entry was referenced by at least one entity in the
            drawing the last time the drawing was edited. (This flag is only for
            the benefit of AutoCAD)
        === =========================================================

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-6E3140E9-E560-4C77-904E-480382F0553E

--- End of file: tables/appid_table_entry.rst ---



--- Start of file: tables/blockrecord_table_entry.rst ---

BlockRecord
===========

.. module:: ezdxf.entities
    :noindex:

BLOCK_RECORD (`DXF Reference`_) is the core management structure for
:class:`~ezdxf.layouts.BlockLayout` and :class:`~ezdxf.layouts.Layout`.
This is an internal DXF structure managed by `ezdxf`, package users don't have
to care about it.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFEntity`
DXF type                 ``'BLOCK_RECORD'``
Factory function         :meth:`Drawing.block_records.new`
======================== ==========================================



.. class:: BlockRecord

    .. attribute:: dxf.owner

        Handle to owner (:class:`~ezdxf.sections.table.Table`).

    .. attribute:: dxf.name

        Name of associated BLOCK.

    .. attribute:: dxf.layout

        Handle to associated :class:`~ezdxf.entities.layout.DXFLayout`, if
        paperspace layout or modelspace else "0"

    .. attribute:: dxf.explode

        1 for BLOCK references can be exploded else 0

    .. attribute:: dxf.scale

        1 for BLOCK references can be scaled else 0

    .. attribute:: dxf.units

        BLOCK insert units

        === ===================
        0   Unitless
        1   Inches
        2   Feet
        3   Miles
        4   Millimeters
        5   Centimeters
        6   Meters
        7   Kilometers
        8   Microinches
        9   Mils
        10  Yards
        11  Angstroms
        12  Nanometers
        13  Microns
        14  Decimeters
        15  Decameters
        16  Hectometers
        17  Gigameters
        18  Astronomical units
        19  Light years
        20  Parsecs
        21  US Survey Feet
        22  US Survey Inch
        23  US Survey Yard
        24  US Survey Mile
        === ===================


    .. autoproperty:: is_active_paperspace

    .. autoproperty:: is_any_paperspace

    .. autoproperty:: is_any_layout

    .. autoproperty:: is_block_layout

    .. autoproperty:: is_modelspace

    .. autoproperty:: is_xref


Internal Structure
------------------

Do not change this structures, this is just an information for experienced
developers!

The BLOCK_RECORD is the owner of all the entities in a layout and stores them
in an :class:`~ezdxf.entitydb.EntitySpace` object (:attr:`BlockRecord.entity_space`).
For each layout exist a BLOCK definition in the BLOCKS section, a reference to
the :class:`~ezdxf.entities.Block` entity is stored in :attr:`BlockRecord.block`.

:class:`~ezdxf.layouts.Modelspace` and :class:`~ezdxf.layouts.Paperspace`
layouts require an additional :class:`~ezdxf.entities.DXFLayout` object
in the OBJECTS section.

.. seealso::

    More information about :ref:`Block Management Structures` and
    :ref:`Layout Management Structures`.

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A1FD1934-7EF5-4D35-A4B0-F8AE54A9A20A

--- End of file: tables/blockrecord_table_entry.rst ---



--- Start of file: tables/dimstyle_table_entry.rst ---

DimStyle
========

.. module:: ezdxf.entities
    :noindex:

.. image:: ../dxfinternals/tables/gfx/dimvars1.svg
    :align: center
    :width: 800px

.. image:: ../dxfinternals/tables/gfx/dimvars2.svg
    :align: center
    :width: 800px

DIMSTYLE (`DXF Reference`_) defines the appearance of :class:`Dimension` entities.
Each of this dimension variables starting with ``"dim..."`` can be overridden
for any :class:`Dimension` entity individually.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFEntity`
DXF type                 ``'DIMSTYLE'``
Factory function         :meth:`Drawing.dimstyles.new`
======================== ==========================================

.. class:: DimStyle

    .. attribute:: dxf.owner

        Handle to owner (:class:`~ezdxf.sections.table.Table`).

    .. attribute:: dxf.name

        Dimension style name.

    .. attribute:: dxf.flags

        Standard flag values (bit-coded values):

        ======= ================================================================
        16      If set, table entry is externally dependent on an xref
        32      If both this bit and bit 16 are set, the externally dependent
                XREF has been successfully resolved
        64      If set, the table entry was referenced by at least one entity in
                the drawing the last time the drawing was edited. (This flag is
                only for the benefit of AutoCAD)
        ======= ================================================================

    .. attribute:: dxf.dimpost

        Prefix/suffix for primary units dimension values.

    .. attribute:: dxf.dimapost

        Prefix/suffix for alternate units dimensions.

    .. attribute:: dxf.dimblk

        Block type to use for both arrowheads as name string.

    .. attribute:: dxf.dimblk1

        Block type to use for first arrowhead as name string.

    .. attribute:: dxf.dimblk2

        Block type to use for second arrowhead as name string.

    .. attribute:: dxf.dimscale

        Global dimension feature scale factor. (default=1)

    .. attribute:: dxf.dimasz

        Dimension line and arrowhead size. (default=0.25)

    .. attribute:: dxf.dimexo

        Distance from origin points to extension lines. (default imperial=0.0625,
        default metric=0.625)

    .. attribute:: dxf.dimdli

        Incremental spacing between baseline dimensions. (default imperial=0.38,
        default metric=3.75)

    .. attribute:: dxf.dimexe

        Extension line distance beyond dimension line. (default imperial=0.28,
        default metric=2.25)

    .. attribute:: dxf.dimrnd

        Rounding value for decimal dimensions. (default=0)

        Rounds all dimensioning distances to the specified value, for instance,
        if DIMRND is set to 0.25, all distances round to the nearest 0.25 unit.
        If you set DIMRND to 1.0, all distances round to the nearest integer.

    .. attribute:: dxf.dimdle

        Dimension line extension beyond extension lines. (default=0)

    .. attribute:: dxf.dimtp

        Upper tolerance value for tolerance dimensions. (default=0)

    .. attribute:: dxf.dimtm

        Lower tolerance value for tolerance dimensions. (default=0)

    .. attribute:: dxf.dimtxt

        Size of dimension text. (default imperial=0.28, default metric=2.5)

    .. attribute:: dxf.dimcen

        Controls placement of center marks or centerlines. (default imperial=0.09,
        default metric=2.5)

    .. attribute:: dxf.dimtsz

        Controls size of dimension line tick marks drawn instead of arrowheads.
        (default=0)

    .. attribute:: dxf.dimaltf

        Alternate units dimension scale factor. (default=25.4)

    .. attribute:: dxf.dimlfac

        Scale factor for linear dimension values. (default=1)

    .. attribute:: dxf.dimtvp

        Vertical position of text above or below dimension line if
        :attr:`~DimStyle.dxf.dimtad` is 0. (default=0)

    .. attribute:: dxf.dimtfac

        Scale factor for fractional or tolerance text size. (default=1)

    .. attribute:: dxf.dimgap

        Gap size between dimension line and dimension text. (default
        imperial=0.09, default metric=0.625)

    .. attribute:: dxf.dimaltrnd

        Rounding value for alternate dimension units. (default=0)

    .. attribute:: dxf.dimtol

        Toggles creation of appended tolerance dimensions. (default imperial=1,
        default metric=0)

    .. attribute:: dxf.dimlim

        Toggles creation of limits-style dimension text. (default=0)

    .. attribute:: dxf.dimtih

        Orientation of text inside extension lines. (default imperial=1, default
        metric=0)

    .. attribute:: dxf.dimtoh

        Orientation of text outside extension lines. (default imperial=1,
        default metric=0)

    .. attribute:: dxf.dimse1

        Toggles suppression of first extension line. (default=0)

    .. attribute:: dxf.dimse2

        Toggles suppression of second extension line. (default=0)

    .. attribute:: dxf.dimtad

        Sets vertical text placement relative to dimension line. (default
        imperial=0, default metric=1)

        === =====
        0   center
        1   above
        2   outside, handled like above by `ezdxf`
        3   JIS, handled like above by `ezdxf`
        4   below
        === =====

    .. attribute:: dxf.dimzin

        Zero suppression for primary units dimensions. (default imperial=0,
        default metric=8)

        Values 0-3 affect feet-and-inch dimensions only.

        === ====================================================================
        0   Suppresses zero feet and precisely zero inches
        1   Includes zero feet and precisely zero inches
        2   Includes zero feet and suppresses zero inches
        3   Includes zero inches and suppresses zero feet
        4   Suppresses leading zeros in decimal dimensions (for example, 0.5000
            becomes .5000)
        8   Suppresses trailing zeros in decimal dimensions (for example,
            12.5000 becomes 12.5)
        12  Suppresses both leading and trailing zeros (for example, 0.5000
            becomes .5)
        === ====================================================================

    .. attribute:: dxf.dimazin

        Controls zero suppression for angular dimensions. (default=0)

        === ====================================================================
        0   Displays all leading and trailing zeros
        1   Suppresses leading zeros in decimal dimensions (for example, 0.5000
            becomes .5000)
        2   Suppresses trailing zeros in decimal dimensions (for example,
            12.5000 becomes 12.5)
        3   Suppresses leading and trailing zeros (for example, 0.5000 becomes .5)
        === ====================================================================

    .. attribute:: dxf.dimalt

        Enables or disables alternate units dimensioning. (default=0)

    .. attribute:: dxf.dimaltd

        Controls decimal places for alternate units dimensions. (default
        imperial=2, default metric=3)

    .. attribute:: dxf.dimtofl

        Toggles forced dimension line creation. (default imperial=0, default
        metric=1)

    .. attribute:: dxf.dimsah

        Toggles appearance of arrowhead blocks. (default=0)

    .. attribute:: dxf.dimtix

        Toggles forced placement of text between extension lines. (default=0)

    .. attribute:: dxf.dimsoxd

        Suppresses dimension lines outside extension lines. (default=0)

    .. attribute:: dxf.dimclrd

        Dimension line, arrowhead, and leader line color. (default=0)

    .. attribute:: dxf.dimclre

        Dimension extension line color. (default=0)

    .. attribute:: dxf.dimclrt

        Dimension text color. (default=0)

    .. attribute:: dxf.dimadec

        Controls the number of decimal places for angular dimensions.

    .. attribute:: dxf.dimunit

        Obsolete, now use DIMLUNIT AND DIMFRAC

    .. attribute:: dxf.dimdec

        Decimal places for dimension values. (default imperial=4, default metric=2)

    .. attribute:: dxf.dimtdec

        Decimal places for primary units tolerance values. (default imperial=4,
        default metric=2)

    .. attribute:: dxf.dimaltu

        Units format for alternate units dimensions. (default=2)

    .. attribute:: dxf.dimalttd

        Decimal places for alternate units tolerance values. (default imperial=4,
        default metric=2)

    .. attribute:: dxf.dimaunit

        Unit format for angular dimension values. (default=0)

    .. attribute:: dxf.dimfrac

        Controls the fraction format used for architectural and fractional
        dimensions. (default=0)

    .. attribute:: dxf.dimlunit

        Specifies units for all nonangular dimensions. (default=2)

    .. attribute:: dxf.dimdsep

        Specifies a single character to use as a decimal separator. (default
        imperial = ".", default metric = ",") This is an integer value,
        use :code:`ord(".")` to write value.

    .. attribute:: dxf.dimtmove

        Controls the format of dimension text when it is moved. (default=0)

        === =====
        0   Moves the dimension line with dimension text
        1   Adds a leader when dimension text is moved
        2   Allows text to be moved freely without a leader
        === =====

    .. attribute:: dxf.dimjust

        Horizontal justification of dimension text. (default=0)

        === =====
        0   Center of dimension line
        1   Left side of the dimension line, near first extension line
        2   Right side of the dimension line, near second extension line
        3   Over first extension line
        4   Over second extension line
        === =====

    .. attribute:: dxf.dimsd1

        Toggles suppression of first dimension line. (default=0)

    .. attribute:: dxf.dimsd2

        Toggles suppression of second dimension line. (default=0)

    .. attribute:: dxf.dimtolj

        Vertical justification for dimension tolerance text. (default=1)

        === ====================================================
        0   Align with bottom line of dimension text
        1   Align vertical centered to dimension text
        2   Align with top line of dimension text
        === ====================================================

    .. attribute:: dxf.dimtzin

        Zero suppression for tolerances values, see :attr:`DimStyle.dxf.dimzin`

    .. attribute:: dxf.dimaltz

        Zero suppression for alternate units dimension values. (default=0)

    .. attribute:: dxf.dimalttz

        Zero suppression for alternate units tolerance values. (default=0)

    .. attribute:: dxf.dimfit

        Obsolete, now use DIMATFIT and DIMTMOVE

    .. attribute:: dxf.dimupt

        Controls user placement of dimension line and text. (default=0)

    .. attribute:: dxf.dimatfit

        Controls placement of text and arrowheads when there is insufficient
        space between the extension lines. (default=3)

    .. attribute:: dxf.dimtxsty

        Text style used for dimension text by name.

    .. attribute:: dxf.dimtxsty_handle

        Text style used for dimension text by handle of STYLE entry.
        (use :attr:`DimStyle.dxf.dimtxsty` to get/set text style by name)

    .. attribute:: dxf.dimldrblk

        Specify arrowhead used for leaders by name.

    .. attribute:: dxf.dimldrblk_handle

        Specify arrowhead used for leaders by handle of referenced block.
        (use :attr:`DimStyle.dxf.dimldrblk` to get/set arrowhead by name)

    .. attribute:: dxf.dimblk_handle

        Block type to use for both arrowheads, handle of referenced block.
        (use :attr:`DimStyle.dxf.dimblk` to get/set arrowheads by name)

    .. attribute:: dxf.dimblk1_handle

        Block type to use for first arrowhead, handle of referenced block.
        (use :attr:`DimStyle.dxf.dimblk1` to get/set arrowhead by name)

    .. attribute:: dxf.dimblk2_handle

        Block type to use for second arrowhead, handle of referenced block.
        (use :attr:`DimStyle.dxf.dimblk2` to get/set arrowhead by name)

    .. attribute:: dxf.dimlwd

        Lineweight value for dimension lines. (default=-2, BYBLOCK)

    .. attribute:: dxf.dimlwe

        Lineweight value for extension lines. (default=-2, BYBLOCK)

    .. attribute:: dxf.dimltype

        Specifies the linetype used for the dimension line as linetype name,
        requires DXF R2007+

    .. attribute:: dxf.dimltype_handle

        Specifies the linetype used for the dimension line as handle to LTYPE
        entry, requires DXF R2007+ (use :attr:`DimStyle.dxf.dimltype` to get/set
        linetype by name)

    .. attribute:: dxf.dimltex1

        Specifies the linetype used for the extension line 1 as linetype name,
        requires DXF R2007+

    .. attribute:: dxf.dimlex1_handle

        Specifies the linetype used for the extension line 1 as handle to LTYPE
        entry, requires DXF R2007+ (use :attr:`DimStyle.dxf.dimltex1` to get/set
        linetype by name)

    .. attribute:: dxf.dimltex2

        Specifies the linetype used for the extension line 2 as linetype name,
        requires DXF R2007+

    .. attribute:: dxf.dimlex2_handle

        Specifies the linetype used for the extension line 2 as handle to LTYPE
        entry, requires DXF R2007+ (use :attr:`DimStyle.dxf.dimltex2` to get/set
        linetype by name)

    .. attribute:: dxf.dimfxlon

        Extension line has fixed length if set to 1, requires DXF R2007+

    .. attribute:: dxf.dimfxl

        Length of extension line below dimension line if fixed
        (:attr:`DimStyle.dxf.dimtfxlon` == 1), :attr:`DimStyle.dxf.dimexen`
        defines the length above the dimension line, requires DXF R2007+

    .. attribute:: dxf.dimtfill

        Text fill 0=off; 1=background color; 2=custom color (see
        :attr:`DimStyle.dxf.dimtfillclr`), requires DXF R2007+

    .. attribute:: dxf.dimtfillclr

        Text fill custom color as color index (1-255), requires DXF R2007+

    .. attribute:: dxf.dimarcsym

        Display arc symbol, supported only by :class:`ArcDimension`:

        === ====================================================
        0   arc symbol preceding the measurement text
        1   arc symbol above the measurement text
        2   disable arc symbol
        === ====================================================


    .. automethod:: copy_to_header

    .. automethod:: set_arrows

    .. automethod:: set_tick

    .. automethod:: set_text_align

    .. automethod:: set_text_format

    .. automethod:: set_dimline_format

    .. automethod:: set_extline_format

    .. automethod:: set_extline1

    .. automethod:: set_extline2

    .. automethod:: set_tolerance

    .. automethod:: set_limits

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-F2FAD36F-0CE3-4943-9DAD-A9BCD2AE81DA

--- End of file: tables/dimstyle_table_entry.rst ---



--- Start of file: tables/index.rst ---

Tables
======

.. toctree::
   :maxdepth: 1

   tables
   layer_table_entry
   style_table_entry
   linetype_table_entry
   dimstyle_table_entry
   vport_table_entry
   view_table_entry
   appid_table_entry
   ucs_table_entry
   blockrecord_table_entry


--- End of file: tables/index.rst ---



--- Start of file: tables/layer_table_entry.rst ---

Layer
=====

.. module:: ezdxf.entities
    :noindex:

LAYER (`DXF Reference`_) definition, defines attribute values for entities on
this layer for their attributes set to ``BYLAYER``.

.. important::

    A layer assignment is just an attribute of a DXF entity, it's not an entity
    container, the entities are stored in layouts and blocks and the assigned layer is
    not important for that.

    Deleting a layer entry does not delete the entities which reference this layer!

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFEntity`
DXF type                 ``'LAYER'``
Factory function         :meth:`Drawing.layers.new`
======================== ==========================================

.. seealso::

    Basic concepts of :ref:`layer_concept` and :ref:`tut_layers`

.. class:: Layer

    .. attribute:: dxf.handle

        DXF handle (feature for experts)

    .. attribute:: dxf.owner

        Handle to owner (:class:`~ezdxf.sections.table.LayerTable`).

    .. attribute:: dxf.name

        Layer name, case insensitive and can not contain any of this characters:
        ``<>/\":;?*|=``` (str)

    .. attribute:: dxf.flags

        Layer flags (bit-coded values, feature for experts)

        === ==========================================
        1   Layer is frozen; otherwise layer is thawed; use :meth:`is_frozen`,
            :meth:`freeze` and :meth:`thaw`
        2   Layer is frozen by default in new viewports
        4   Layer is locked; use :meth:`is_locked`, :meth:`lock`, :meth:`unlock`
        16  If set, table entry is externally dependent on an xref
        32  If both this bit and bit 16 are set, the externally dependent xref
            has been successfully resolved
        64  If set, the table entry was referenced by at least one entity in the
            drawing the last time the drawing was edited. (This flag is for the
            benefit of AutoCAD commands. It can be ignored by most programs that
            read DXF files and need not be set by programs that write DXF files)
        === ==========================================

    .. attribute:: dxf.color

        Layer color, but use property :attr:`Layer.color` to get/set color value,
        because color is negative for layer status `off` (int)

    .. attribute:: dxf.true_color

        Layer true color value as int, use property :attr:`Layer.rgb` to set/get
        true color value as (r, g, b) tuple.

        (requires DXF R2004)

    .. attribute:: dxf.linetype

        Name of line type (str)

    .. attribute:: dxf.plot

        Plot flag (int). Whether entities belonging to this layer should be drawn
        when the document is exported (plotted) to pdf. Does not affect
        visibility inside the CAD application itself.

        === ============================
        1   plot layer (default value)
        0   don't plot layer
        === ============================

    .. attribute:: dxf.lineweight

        Line weight in mm times 100 (e.g. 0.13mm = 13). Smallest line weight is
        13 and biggest line weight is 200, values outside this range prevents
        AutoCAD from loading the file.

        :code:`ezdxf.lldxf.const.LINEWEIGHT_DEFAULT` for using global default
        line weight.

        (requires DXF R13)

    .. attribute:: dxf.plotstyle_handle

        Handle to plot style name?

        (requires DXF R13)

    .. attribute:: dxf.material_handle

        Handle to default :class:`~ezdxf.entities.Material`.

        (requires DXF R13)

    .. attribute:: rgb

        Get/set DXF attribute :attr:`dxf.true_color` as (r, g, b) tuple,
        returns ``None`` if attribute :attr:`dxf.true_color` is not set.

        .. code-block:: python

            layer.rgb = (30, 40, 50)
            r, g, b = layer.rgb

        This is the recommend method to get/set RGB values, when ever possible
        do not use the DXF low level attribute :attr:`dxf.true_color`.

    .. attribute:: color

        Get/set layer color, preferred method for getting the layer color,
        because :attr:`dxf.color` is negative for layer status `off`.

    .. attribute:: description

        Get/set layer description as string

    .. attribute:: transparency

        Get/set layer transparency as float value in the range from 0 to 1.
        0 for no transparency (opaque) and 1 for 100% transparency.

    .. automethod:: is_frozen

    .. automethod:: freeze

    .. automethod:: thaw

    .. automethod:: is_locked

    .. automethod:: lock

    .. automethod:: unlock

    .. automethod:: is_off

    .. automethod:: is_on

    .. automethod:: on

    .. automethod:: off

    .. method:: get_color() -> int

        Use property :attr:`Layer.color` instead.

    .. method:: set_color(value: int) -> None

        Use property :attr:`Layer.color` instead.

    .. automethod:: rename

    .. automethod:: get_vp_overrides() -> LayerOverrides

LayerOverrides
--------------

.. class:: LayerOverrides

    This object stores the layer attribute overridden in :class:`Viewport`
    entities,  where each :class:`Viewport` can have individual layer attribute
    overrides.

    Layer attributes which can be overridden:

        - ACI color
        - true color (rgb)
        - linetype
        - lineweight
        - transparency

    Get the override object for a certain layer by the :meth:`Layer.get_vp_overrides`
    method.

    It is important to write changes back by calling :meth:`commit`, otherwise
    the changes are lost.

    .. important::

        The implementation of this feature as DXF structures is not documented
        by the DXF reference, so if you encounter problems or errors,
        **ALWAYS** provide the DXF files, otherwise it is not possible to help.

    .. automethod:: has_overrides

    .. automethod:: commit

    .. automethod:: get_color

    .. automethod:: set_color

    .. automethod:: get_rgb

    .. automethod:: set_rgb

    .. automethod:: get_transparency

    .. automethod:: set_transparency

    .. automethod:: get_linetype

    .. automethod:: set_linetype

    .. automethod:: get_lineweight

    .. automethod:: set_lineweight

    .. automethod:: discard


.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-D94802B0-8BE8-4AC9-8054-17197688AFDB


--- End of file: tables/layer_table_entry.rst ---



--- Start of file: tables/linetype_table_entry.rst ---

Linetype
========

.. module:: ezdxf.entities
    :noindex:

Defines a linetype (`DXF Reference`_).

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFEntity`
DXF type                 ``'LTYPE'``
Factory function         :meth:`Drawing.linetypes.new`
======================== ==========================================

.. seealso::

    :ref:`tut_linetypes`

    DXF Internals: :ref:`ltype_table_internals`

.. class:: Linetype

    .. attribute:: dxf.name

        Linetype name (str).

    .. attribute:: dxf.owner

        Handle to owner (:class:`~ezdxf.sections.table.Table`).

    .. attribute:: dxf.description

        Linetype description (str).

    .. attribute:: dxf.length

        Total pattern length in drawing units (float).

    .. attribute:: dxf.items

        Number of linetype elements (int).

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-F57A316C-94A2-416C-8280-191E34B182AC

--- End of file: tables/linetype_table_entry.rst ---



--- Start of file: tables/style_table_entry.rst ---

Style
=====

.. module:: ezdxf.entities
    :noindex:

.. important::

    DXF is not a layout preserving data format like PDF. It is more similar to
    the MS Word format. Many applications can open MS Word documents, but the
    displayed or printed document does not look perfect like the result of
    MS Word.

    The final rendering of DXF files is highly dependent on the interpretation
    of DXF entities by the rendering engine, and the DXF reference does not
    provide any guidelines for rendering entities. The biggest visual
    differences of CAD applications are the text renderings, therefore
    the only way to get the exact same result is to use the same CAD
    application.

    The DXF format does not and **can not** embed TTF fonts like the PDF format!

The :class:`Textstyle` entity defines a text style (`DXF Reference`_), and can
be used by the entities: :class:`Text`, :class:`Attrib`, :class:`Attdef`,
:class:`MText`, :class:`Dimension`, :class:`Leader` and :class:`MultiLeader`.

Example to create a new text style "Arial" and to apply this text style:

.. code-block:: Python

    doc.styles.add("Arial", font="Arial.ttf")
    msp = doc.modelspace()
    msp.add_text("my text", dxfattribs={"style": "Arial"})


The settings stored in the :class:`Textstyle` entity are the default
text style values used by CAD applications if the text settings are not
stored in the text entity itself.
But not all setting are substituted by the default value.
The :attr:`height` or :attr:`width` attribute must be stored in the
text entities itself in order to influence the appearance of the text.
It is `recommended` that you do not rely on the default settings in the
:class:`Textstyle` entity, set all attributes in the text entity itself if
supported.

Font Settings
-------------

Just a few settings are available exclusive by the :class:`Textstyle` entity:

The most important setting is the :attr:`font` attribute, this attribute
defines the rendering font as raw TTF file name, e.g. "Arial.ttf" or
"OpenSansCondensed-Light.ttf", this file name is often **not** the name
displayed in GUI application and you have to digg down into the fonts folder
e.g. ("C:\\Windows\\Fonts") to get the real file name for the TTF font.
Do not include the path!

.. image:: ../gfx/font_properties.png
    :align: center

AutoCAD supports beyond the legacy SHX fonts **only** TTF fonts.
The SHX font format is not documented and only available in some CAD
applications. The `ezdxf` :mod:`~ezdxf.addons.drawing` add-on replaces the
SHX fonts by TTF fonts, which look similar to the SHX fonts, unfortunately the
license of these fonts is unclear, therefore they can not be packaged with `ezdxf`.
They are installed automatically if you use an Autodesk product like `TrueView`_,
or search the internet at you own risk for these TTF fonts.

The extended font data can provide extra information for the font, it is stored
in the XDATA section, not well documented and not widely supported.

.. important::

    The DXF format does not and **can not** embed TTF fonts like the PDF format!

    You need to make sure that the CAD application is properly configured to
    have access to the system fonts. The DXF format has no setting where the CAD
    application should search for fonts, and does not guarantee that the text
    rendering on other computers or operating systems looks the same as on your
    current system on which you created the DXF.

The second exclusive setting is the vertical text flag in :attr:`Textstyle.flags`.
The vertical text style is enabled for `all` entities using the text style.
Vertical text works only for SHX fonts and is not supported for TTF fonts
(in AutoCAD) and is works only for the single line entities :class:`Text`
and :class:`Attrib`.
Most CAD applications beside AutoCAD and BricsCAD do not support vertical text
rendering and even AutoCAD and BricsCAD have problems with vertical text
rendering in some circumstances. Using the vertical text feature is not
recommended.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFEntity`
DXF type                 ``'STYLE'``
Factory function         :meth:`Drawing.styles.new`
======================== ==========================================

.. seealso::

    :ref:`tut_text` and DXF internals for :ref:`dimstyle_table_internals`.

.. class:: Textstyle

    .. autoproperty:: is_backward

    .. autoproperty:: is_upside_down

    .. autoproperty:: is_vertical_stacked

    .. autoproperty:: is_shape_file

    .. attribute:: dxf.handle

        DXF handle (feature for experts).

    .. attribute:: dxf.owner

        Handle to owner (:class:`~ezdxf.sections.table.TextstyleTable`).

    .. attribute:: dxf.name

        Style name (str)

    .. attribute:: dxf.flags

        Style flags (feature for experts).

        === =======================================================
        1   If set, this entry describes a shape
        4   Vertical text
        16  If set, table entry is externally dependent on an xref
        32  If both this bit and bit 16 are set, the externally dependent xref
            has been successfully resolved
        64  If set, the table entry was referenced by at least one entity in the
            drawing the last time the drawing was edited. (This flag is only for
            the benefit of AutoCAD)commands. It can be ignored by most programs
            that read DXF files and need not be set by programs that write DXF
            files)
        === =======================================================

    .. attribute:: dxf.height

        Fixed height in drawing units as float value, 0 for not fixed.

    .. attribute:: dxf.width

        Width factor as float value, default value is 1.

    .. attribute:: dxf.oblique

        Oblique (slanting) angle in degrees as float value, default value is 0
        for no slanting.

    .. attribute:: dxf.generation_flags

        Text generations flags as int value.

        === ===================================
        2   text is backward (mirrored along the x-axis)
        4   text is upside down (mirrored about the base line)
        === ===================================

    .. attribute:: dxf.last_height

        Last height used in drawing units as float value.

    .. attribute:: dxf.font

        Raw font file name as string without leading path, e.g.
        "Arial.ttf" for TTF fonts or the SHX font name like
        "TXT" or "TXT.SHX".

    .. attribute:: dxf.bigfont

        Big font name as string, blank if none. No documentation how to use
        this feature, maybe just a legacy artifact.

    .. autoproperty:: has_extended_font_data

    .. automethod:: get_extended_font_data

    .. automethod:: set_extended_font_data

    .. automethod:: discard_extended_font_data

    .. automethod:: make_font


.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-EF68AF7C-13EF-45A1-8175-ED6CE66C8FC9

.. _TrueView: https://www.autodesk.com/products/dwg/viewers#

--- End of file: tables/style_table_entry.rst ---



--- Start of file: tables/tables.rst ---

Table Classes
=============

.. module:: ezdxf.sections.table

Generic Table Class
-------------------

.. class:: Table

    Generic collection of table entries. Table entry names are case insensitive:
    "Test" == "TEST".

    .. automethod:: key

    .. automethod:: has_entry

    .. automethod:: __contains__

    .. automethod:: __len__

    .. automethod:: __iter__

    .. automethod:: new

    .. automethod:: get

    .. automethod:: remove

    .. automethod:: duplicate_entry

Layer Table
-----------

.. class:: LayerTable

    Subclass of :class:`Table`.

    Collection of :class:`~ezdxf.entities.Layer` objects.

    .. automethod:: add

Linetype Table
--------------

.. class:: LinetypeTable

    Subclass of :class:`Table`.

    Collection of :class:`~ezdxf.entities.Linetype` objects.

    .. automethod:: add

Style Table
-----------

.. class:: TextstyleTable

    Subclass of :class:`Table`.

    Collection of :class:`~ezdxf.entities.Textstyle` objects.

    .. automethod:: add

    .. automethod:: add_shx

    .. automethod:: get_shx

    .. automethod:: find_shx

    .. automethod:: discard_shx


DimStyle Table
--------------



.. class:: DimStyleTable

    Subclass of :class:`Table`.

    Collection of :class:`~ezdxf.entities.DimStyle` objects.

    .. automethod:: add

AppID Table
-----------

.. class:: AppIDTable

    Subclass of :class:`Table`.

    Collection of :class:`~ezdxf.entities.AppID` objects.

    .. automethod:: add

UCS Table
---------

.. class:: UCSTable

    Subclass of :class:`Table`.

    Collection of :class:`~ezdxf.entities.UCSTableEntry` objects.

    .. automethod:: add

View Table
----------

.. class:: ViewTable

    Subclass of :class:`Table`.

    Collection of :class:`~ezdxf.entities.View` objects.

    .. automethod:: add

Viewport Table
--------------

.. class:: ViewportTable

    The viewport table stores the modelspace viewport configurations. A viewport
    configuration is a tiled view of multiple viewports or just one viewport.
    In contrast to other tables the viewport table can have multiple entries
    with the same name, because all viewport entries of a multi-viewport
    configuration are having the same name - the viewport configuration name.

    The name of the actual displayed viewport configuration is "\*ACTIVE".

    Duplication of table entries is not supported: :meth:`duplicate_entry`
    raises :class:`NotImplementedError`

    .. automethod:: add

    .. automethod:: get_config(self, name: str) -> List[VPort]

    .. automethod:: delete_config



Block Record Table
------------------

.. class:: BlockRecordTable

    Subclass of :class:`Table`.

    Collection of :class:`~ezdxf.entities.BlockRecord` objects.

    .. automethod:: add

--- End of file: tables/tables.rst ---



--- Start of file: tables/ucs_table_entry.rst ---

UCS
====

.. module:: ezdxf.entities
    :noindex:

Defines an named or unnamed user coordinate system (`DXF Reference`_) for usage in CAD applications. This UCS table
entry does not interact with `ezdxf` in any way, to do coordinate transformations by `ezdxf` use the
:class:`ezdxf.math.UCS` class.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFEntity`
DXF type                 ``'UCS'``
Factory function         :meth:`Drawing.ucs.new`
======================== ==========================================

.. seealso::

    :ref:`ucs` and :ref:`ocs`

.. class:: UCSTableEntry

    .. attribute:: dxf.owner

        Handle to owner (:class:`~ezdxf.sections.table.Table`).

    .. attribute:: dxf.name

        UCS name (str).

    .. attribute:: dxf.flags

        Standard flags (bit-coded values):

        === ========================================================
        16  If set, table entry is externally dependent on an xref
        32  If both this bit and bit 16 are set, the externally dependent xref
            has been successfully resolved
        64  If set, the table entry was referenced by at least one entity in the
            drawing the last time the drawing was edited. (This flag is only for
            the benefit of AutoCAD)
        === ========================================================

    .. attribute:: dxf.origin

        Origin  as (x, y, z) tuple

    .. attribute:: dxf.xaxis

        X-axis direction as (x, y, z) tuple

    .. attribute:: dxf.yaxis

        Y-axis direction as (x, y, z) tuple

    .. automethod:: ucs

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-1906E8A7-3393-4BF9-BD27-F9AE4352FB8B


--- End of file: tables/ucs_table_entry.rst ---



--- Start of file: tables/view_table_entry.rst ---

View
====

.. module:: ezdxf.entities
    :noindex:

The View table (`DXF Reference`_) stores named views of the model or paperspace
layouts. This stored views makes parts of the drawing or some view points of the
model in a CAD applications more accessible. This views have no influence to the
drawing content or to the generated output by exporting PDFs or plotting on paper
sheets, they are just for the convenience of CAD application users.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFEntity`
DXF type                 ``'VIEW'``
Factory function         :meth:`Drawing.views.new`
======================== ==========================================

.. seealso::

    DXF Internals: :ref:`view_table_internals`

.. class:: View

    .. attribute:: dxf.owner

        Handle to owner (:class:`~ezdxf.sections.table.Table`).

    .. attribute:: dxf.name

        Name of view.

    .. attribute:: dxf.flags

        Standard flag values (bit-coded values):

        === =========================================================
        1   If set, this is a paper space view
        16  If set, table entry is externally dependent on an xref
        32  If both this bit and bit 16 are set, the externally dependent xref
            has been successfully resolved
        64  If set, the table entry was referenced by at least one entity in the
            drawing the last time the drawing was edited. (This flag is only for
            the benefit of AutoCAD)
        === =========================================================

    .. attribute:: dxf.height

        View height (in DCS)

    .. attribute:: dxf.width

        View width (in DCS)

    .. attribute:: dxf.center_point

        View center point (in DCS)

    .. attribute:: dxf.direction_point

        View direction from target (in WCS)

    .. attribute:: dxf.target_point

        Target point (in WCS)

    .. attribute:: dxf.lens_length

        Lens length

    .. attribute:: dxf.front_clipping

        Front clipping plane (offset from target point)

    .. attribute:: dxf.back_clipping

        Back clipping plane (offset from target point)

    .. attribute:: dxf.view_twist

        Twist angle in degrees.

    .. attribute:: dxf.view_mode

        View mode (see VIEWMODE system variable)

    .. attribute:: dxf.render_mode

        === =================================
        0   2D Optimized (classic 2D)
        1   Wireframe
        2   Hidden line
        3   Flat shaded
        4   Gouraud shaded
        5   Flat shaded with wireframe
        6   Gouraud shaded with wireframe
        === =================================

    .. attribute:: dxf.ucs

        1 if there is a UCS associated to this view; 0 otherwise

    .. attribute:: dxf.ucs_origin

        UCS origin as (x, y, z) tuple (appears only if :attr:`ucs` is set to 1)

    .. attribute:: dxf.ucs_xaxis

        UCS x-axis as (x, y, z) tuple (appears only if :attr:`ucs` is set to 1)

    .. attribute:: dxf.ucs_yaxis

        UCS y-axis as (x, y, z) tuple (appears only if :attr:`ucs` is set to 1)

    .. attribute:: dxf.ucs_ortho_type

        Orthographic type of UCS (appears only if :attr:`ucs` is set to 1)

        === =======================
        0   UCS is not orthographic
        1   Top
        2   Bottom
        3   Front
        4   Back
        5   Left
        6   Right
        === =======================

    .. attribute:: dxf.elevation

        UCS elevation

    .. attribute:: dxf.ucs_handle

        Handle of :class:`~ezdxf.entities.UCSTable` if UCS is a named UCS. If not
        present, then UCS is unnamed (appears only if :attr:`ucs` is set to 1)

    .. attribute:: dxf.base_ucs_handle

        Handle of :class:`~ezdxf.entities.UCSTable` of base UCS if UCS is
        orthographic. If not present and :attr:`ucs_ortho_type` is non-zero,
        then base UCS is taken to be WORLD (appears only if :attr:`ucs` is
        set to 1)

    .. attribute:: dxf.camera_plottable

        1 if the camera is plottable

    .. attribute:: dxf.background_handle

        Handle to background object (optional)

    .. attribute:: dxf.live_selection_handle

        Handle to live section object (optional)

    .. attribute:: dxf.visual_style_handle

        Handle to visual style object (optional)

    .. attribute:: dxf.sun_handle

        Sun hard ownership handle.

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-CF3094AB-ECA9-43C1-8075-7791AC84F97C


--- End of file: tables/view_table_entry.rst ---



--- Start of file: tables/vport_table_entry.rst ---

VPort
=====

.. module:: ezdxf.entities
    :noindex:

The viewport table (`DXF Reference`_) stores the modelspace viewport
configurations. So this entries just modelspace viewports, not paperspace
viewports, for paperspace viewports see the :class:`Viewport` entity.

======================== ==========================================
Subclass of              :class:`ezdxf.entities.DXFEntity`
DXF type                 ``'VPORT'``
Factory function         :meth:`Drawing.viewports.new`
======================== ==========================================

.. seealso::

    DXF Internals: :ref:`vport_table_internals`

.. class:: VPort

    Subclass of :class:`DXFEntity`

    Defines a viewport configurations for the modelspace.

    .. attribute:: dxf.owner

        Handle to owner (:class:`~ezdxf.sections.table.ViewportTable`).

    .. attribute:: dxf.name

        Viewport name

    .. attribute:: dxf.flags

        Standard flag values (bit-coded values):

        === ==============================================================
        16  If set, table entry is externally dependent on an xref
        32  If both this bit and bit 16 are set, the externally dependent xref
            has been successfully resolved
        64  If set, the table entry was referenced by at least one entity in the
            drawing the last time the drawing was edited. (This flag is only for
            the benefit of AutoCAD)
        === ==============================================================

    .. attribute:: dxf.lower_left

        Lower-left corner of viewport

    .. attribute:: dxf.upper_right

        Upper-right corner of viewport

    .. attribute:: dxf.center

        View center point (in :ref:`DCS`)

    .. attribute:: dxf.snap_base

        Snap base point (in :ref:`DCS`)

    .. attribute:: dxf.snap_spacing

        Snap spacing X and Y

    .. attribute:: dxf.grid_spacing

        Grid spacing X and Y

    .. attribute:: dxf.direction

        View direction from target point (in :ref:`WCS`)

    .. attribute:: dxf.target

        View target point (in :ref:`WCS`)

    .. attribute:: dxf.height

        View height

    .. attribute:: dxf.aspect_ratio

    .. attribute:: dxf.lens_length

        Lens focal length in mm

    .. attribute:: dxf.front_clipping

        Front clipping plane (offset from target point)

    .. attribute:: dxf.back_clipping

        Back clipping plane (offset from target point)

    .. attribute:: dxf.snap_rotation

        Snap rotation angle in degrees

    .. attribute:: dxf.view_twist

        View twist angle in degrees

    .. attribute:: dxf.status

    .. attribute:: dxf.view_mode

    .. attribute:: dxf.circle_zoom

    .. attribute:: dxf.fast_zoom

    .. attribute:: dxf.ucs_icon

       - bit 0: 0=hide, 1=show
       - bit 1: 0=display in lower left corner, 1=display at origin

    .. attribute:: dxf.snap_on

    .. attribute:: dxf.grid_on

    .. attribute:: dxf.snap_style

    .. attribute:: dxf.snap_isopair

    .. automethod:: reset_wcs

.. _DXF Reference: http://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-8CE7CC87-27BD-4490-89DA-C21F516415A9


--- End of file: tables/vport_table_entry.rst ---



--- Start of file: tasks/add_blockrefs.rst ---

.. _add_blockrefs:

Add Block References
====================

Blocks are collections of DXF entities which can be placed multiple times as block 
references in different layouts and other block definitions.  
A block reference is represented by the INSERT entity.

Add Block Reference
-------------------

Add a block reference to the modelspace for a block definition "BlockName"::

    my_block_ref = msp.add_blockref('BlockName', location, dxfattribs={
        'xscale': 1.0,
        'yscale': 1.0,
        'zscale': 1.0,
        'rotation': angle,
    })

Non-uniform scaling is supported by CAD applications. The rotations angle is in degrees 
(circle=360 degrees).

- :meth:`ezdxf.layouts.BaseLayout.add_blockref`

Add Block Attribute
-------------------

To avoid confusion, it's important to distinguish block attributes (ATTRIB entities) 
from DXF attributes. Block attributes are text annotations linked to a block reference. 
They have their own location and can be attached to any block reference, even without a 
corresponding attribute definition (ATTDEF) in the block layout.

Add a block attribute to :code:`my_block_ref`::

    my_attribute = my_block_ref.add_attrib("MY_TAG", "VALUE_STR")
    my_attribute.set_placement(location)


- "MY_TAG": a unique identifier or label for the attribute, unique in the context of 
  the block reference
- "VALUE_STR": the text content displayed by the attribute

Block attributes are a subtype of the TEXT entity. This means they inherit placement and 
editing functionalities from the TEXT class.

- :meth:`ezdxf.entities.Insert.add_attrib`
- :meth:`ezdxf.entities.Text.set_placement`


Add Block Attribute from Template
---------------------------------

Block definitions can include pre-defined templates for attributes using ATTDEF entities. 
The :meth:`~ezdxf.entities.Insert.add_auto_attribs` method simplifies adding these 
attributes to block references. It takes a dictionary argument where:

- Keys: the attribute tags (e.g. "MY_TAG").
- Values: the content for each attribute (e.g. "VALUE_STR").

The :meth:`add_auto_attribs` method automatically attaches attributes (ATTRIB entities) 
to the block reference. These attributes inherit relevant DXF properties (layer, color, 
text style, etc.) from the corresponding ATTDEF entities within the block definition.

The method also ensures that the relative position of each attribute within the block 
reference mirrors the position of its corresponding ATTDEF entity relative to the 
block origin::

    my_block_ref.add_auto_attrib({"MY_TAG": "VALUE_STR"})


- :meth:`ezdxf.entities.Insert.add_auto_attribs`

.. seealso::

    **Tasks:**

    - :ref:`add_dxf_entities`
    - :ref:`copy_or_move_entities`
    - :ref:`delete_dxf_entities`

    **Tutorials:**

    - :ref:`tut_blocks`
    - :ref:`tut_getting_data`
    - :ref:`tut_simple_drawings`

    **Basics:**

    - :ref:`modelspace_concept`
    - :ref:`paperspace_concept`
    - :ref:`block_concept`

    **Classes:**

    - :class:`ezdxf.layouts.BlockLayout`
    - :class:`ezdxf.entities.BlockRecord`
    - :class:`ezdxf.entities.Block`
    - :class:`ezdxf.entities.Insert`
    - :class:`ezdxf.entities.Attrib`
    - :class:`ezdxf.entities.AttDef`
    - :class:`ezdxf.entities.Text`
    


--- End of file: tasks/add_blockrefs.rst ---



--- Start of file: tasks/add_custom_data.rst ---

.. _add_custom_data:

Add Custom and Extended Data
============================

DXF supports storing custom data through various mechanisms.

Header Variables
----------------

Custom data can be stored in the HEADER section of a DXF file. Integer values are stored 
in variables named $USERI1 to $USERI5, while floating-point values are stored in 
variables named $USERR1 to $USERR5.

Example::

    doc.header["$USERI1"] = 17

XDATA Section
-------------

The XDATA section is a container for extended data associated with an entity. It's 
essentially a way to store additional information beyond the standard DXF properties for 
that particular entity. The XDATA section is divided into sub-sections, each associated 
with an AppID.

It's important that the AppID is registered in the AppID table::

    doc.appids.add("YOUR_ID")

- :meth:`ezdxf.sections.table.AppIDTable.add`

Example::

    point = msp.add_point((10, 10))
    point.set_xdata("YOUR_ID", (1040, 3.1415))

- :meth:`ezdxf.entities.DXFEntity.set_xdata`

Extension Dictionaries
----------------------

Each DXF entity can have an extension dictionary to attach custom data. 
The extension dictionary is a :class:`~ezdxf.entities.Dictionary` entity which stores 
references to other DXF entities in a key/value storage, mostly :class:`~ezdxf.entities.Dictionary` 
and :class:`~ezdxf.entities.XRecord` entities.

Example::

    point = msp.add_point((10, 10))
    xdict = point.new_extension_dict()

- :meth:`ezdxf.entities.DXFEntity.new_extension_dict`

Custom Data as XRECORD
----------------------

The XRECORD is used to store arbitrary data. It is composed of DXF group codes ranging 
from 1 through 369. This object is similar in concept to XDATA but is not limited by 
size or order.

Example::

    point = msp.add_point((10, 10))
    xdict = point.new_extension_dict()
    xrecord = xdict.add_xrecord("MyData")
    xrecord.extend([(1, "MyText"), (40, 3.1415)])

- :meth:`ezdxf.entities.xdict.ExtensionDict.add_xrecord`
- :meth:`ezdxf.entities.xdict.ExtensionDict.add_dictionary`
- :meth:`ezdxf.entities.xdict.ExtensionDict.add_dictionary_var`

.. seealso::

    **Tasks:**

    - :ref:`get_extended_data`
    - :ref:`modify_extended_data`
    - :ref:`delete_extended_data`
    
    **Tutorials:**

    - :ref:`tut_custom_data`

    **Basics:**
    
    - :ref:`xdata_internals`
    - :ref:`extension_dictionary`
    - :ref:`dxf_tags_internals`

    **Classes:**
    
    - :class:`ezdxf.entities.xdata.XData`
    - :class:`ezdxf.entities.xdict.ExtensionDict`
    - :class:`ezdxf.entities.XRecord`
    - :class:`ezdxf.entities.Dictionary`
    - :class:`ezdxf.entities.DictionaryVar`

    **Helper-Classes:**

    - :class:`ezdxf.entities.xdata.XDataUserList`
    - :class:`ezdxf.entities.xdata.XDataUserDict`
    - :class:`ezdxf.urecord.UserRecord`
    - :class:`ezdxf.urecord.BinaryRecord`
    

--- End of file: tasks/add_custom_data.rst ---



--- Start of file: tasks/add_dxf_entities.rst ---

.. _add_dxf_entities:

Add DXF Entities
================

Layout Factory Methods
----------------------

Recommended way to create DXF entities.

For all supported entities exist at least one factory method in the
:class:`ezdxf.layouts.BaseLayout` class.
All factory methods have the prefix: ``add_...``

.. code-block:: Python

    import ezdxf

    doc = ezdxf.new()
    msp = doc.modelspace()
    msp.add_line((0, 0, 0), (3, 0, 0), dxfattribs={"color": 2})

.. _thematic_factory_method_index:

Thematic Index of Layout Factory Methods
----------------------------------------

DXF Primitives
++++++++++++++

- :meth:`~ezdxf.layouts.BaseLayout.add_3dface`
- :meth:`~ezdxf.layouts.BaseLayout.add_arc`
- :meth:`~ezdxf.layouts.BaseLayout.add_circle`
- :meth:`~ezdxf.layouts.BaseLayout.add_ellipse`
- :meth:`~ezdxf.layouts.BaseLayout.add_hatch`
- :meth:`~ezdxf.layouts.BaseLayout.add_helix`
- :meth:`~ezdxf.layouts.BaseLayout.add_image`
- :meth:`~ezdxf.layouts.BaseLayout.add_leader`
- :meth:`~ezdxf.layouts.BaseLayout.add_line`
- :meth:`~ezdxf.layouts.BaseLayout.add_lwpolyline`
- :meth:`~ezdxf.layouts.BaseLayout.add_mesh`
- :meth:`~ezdxf.layouts.BaseLayout.add_mline`
- :meth:`~ezdxf.layouts.BaseLayout.add_mpolygon`
- :meth:`~ezdxf.layouts.BaseLayout.add_multileader_mtext`
- :meth:`~ezdxf.layouts.BaseLayout.add_multileader_block`
- :meth:`~ezdxf.layouts.BaseLayout.add_point`
- :meth:`~ezdxf.layouts.BaseLayout.add_polyface`
- :meth:`~ezdxf.layouts.BaseLayout.add_polyline2d`
- :meth:`~ezdxf.layouts.BaseLayout.add_polyline3d`
- :meth:`~ezdxf.layouts.BaseLayout.add_polymesh`
- :meth:`~ezdxf.layouts.BaseLayout.add_ray`
- :meth:`~ezdxf.layouts.BaseLayout.add_shape`
- :meth:`~ezdxf.layouts.BaseLayout.add_solid`
- :meth:`~ezdxf.layouts.BaseLayout.add_trace`
- :meth:`~ezdxf.layouts.BaseLayout.add_wipeout`
- :meth:`~ezdxf.layouts.BaseLayout.add_xline`

Text Entities
+++++++++++++

- :meth:`~ezdxf.layouts.BaseLayout.add_attdef`
- :meth:`~ezdxf.layouts.BaseLayout.add_mtext_dynamic_auto_height_columns`
- :meth:`~ezdxf.layouts.BaseLayout.add_mtext_dynamic_manual_height_columns`
- :meth:`~ezdxf.layouts.BaseLayout.add_mtext_static_columns`
- :meth:`~ezdxf.layouts.BaseLayout.add_mtext`
- :meth:`~ezdxf.layouts.BaseLayout.add_text`

Spline Entity
+++++++++++++

- :meth:`~ezdxf.layouts.BaseLayout.add_cad_spline_control_frame`
- :meth:`~ezdxf.layouts.BaseLayout.add_open_spline`
- :meth:`~ezdxf.layouts.BaseLayout.add_rational_spline`
- :meth:`~ezdxf.layouts.BaseLayout.add_spline_control_frame`
- :meth:`~ezdxf.layouts.BaseLayout.add_spline`

Block References and Underlays
++++++++++++++++++++++++++++++

- :meth:`~ezdxf.layouts.BaseLayout.add_arrow_blockref`
- :meth:`~ezdxf.layouts.BaseLayout.add_auto_blockref`
- :meth:`~ezdxf.layouts.BaseLayout.add_blockref`
- :meth:`~ezdxf.layouts.BaseLayout.add_underlay`

Viewport Entity
+++++++++++++++

Only available in paper space layouts.

- :meth:`~ezdxf.layouts.BaseLayout.add_viewport`

Dimension Entities
++++++++++++++++++

Linear Dimension

- :meth:`~ezdxf.layouts.BaseLayout.add_aligned_dim`
- :meth:`~ezdxf.layouts.BaseLayout.add_linear_dim`
- :meth:`~ezdxf.layouts.BaseLayout.add_multi_point_linear_dim`

Radius and Diameter Dimension

- :meth:`~ezdxf.layouts.BaseLayout.add_diameter_dim_2p`
- :meth:`~ezdxf.layouts.BaseLayout.add_diameter_dim`
- :meth:`~ezdxf.layouts.BaseLayout.add_radius_dim_2p`
- :meth:`~ezdxf.layouts.BaseLayout.add_radius_dim_cra`
- :meth:`~ezdxf.layouts.BaseLayout.add_radius_dim`

Angular Dimension

- :meth:`~ezdxf.layouts.BaseLayout.add_angular_dim_2l`
- :meth:`~ezdxf.layouts.BaseLayout.add_angular_dim_3p`
- :meth:`~ezdxf.layouts.BaseLayout.add_angular_dim_arc`
- :meth:`~ezdxf.layouts.BaseLayout.add_angular_dim_cra`

Arc Dimension

- :meth:`~ezdxf.layouts.BaseLayout.add_arc_dim_3p`
- :meth:`~ezdxf.layouts.BaseLayout.add_arc_dim_arc`
- :meth:`~ezdxf.layouts.BaseLayout.add_arc_dim_cra`

Ordinate Dimension

- :meth:`~ezdxf.layouts.BaseLayout.add_ordinate_dim`
- :meth:`~ezdxf.layouts.BaseLayout.add_ordinate_x_dim`
- :meth:`~ezdxf.layouts.BaseLayout.add_ordinate_y_dim`


Miscellaneous
+++++++++++++

- :meth:`~ezdxf.layouts.BaseLayout.add_entity`
- :meth:`~ezdxf.layouts.BaseLayout.add_foreign_entity`
- :meth:`~ezdxf.layouts.BaseLayout.add_arrow`

ACIS Entities
+++++++++++++

The creation of the required :term:`ACIS` data has do be done by an external library!

- :meth:`~ezdxf.layouts.BaseLayout.add_3dsolid`
- :meth:`~ezdxf.layouts.BaseLayout.add_body`
- :meth:`~ezdxf.layouts.BaseLayout.add_extruded_surface`
- :meth:`~ezdxf.layouts.BaseLayout.add_lofted_surface`
- :meth:`~ezdxf.layouts.BaseLayout.add_region`
- :meth:`~ezdxf.layouts.BaseLayout.add_revolved_surface`
- :meth:`~ezdxf.layouts.BaseLayout.add_surface`
- :meth:`~ezdxf.layouts.BaseLayout.add_swept_surface`

.. seealso::

    Layout base class: :class:`~ezdxf.layouts.BaseLayout`

Factory Functions
-----------------

Alternative way to create DXF entities for advanced `ezdxf` users.

The :mod:`ezdxf.entities.factory` module provides the
:func:`~ezdxf.entities.factory.new` function to create new DXF entities by
their DXF name and a dictionary of DXF attributes. This will bypass the
validity checks in the factory methods of the :class:`~ezdxf.layouts.BaseLayout`
class.

This new created entities are virtual entities which are not assigned to any
DXF document nor to any layout. Add the entity to a layout (and document) by
the layout method :meth:`~ezdxf.layouts.BaseLayout.add_entity`.

.. code-block:: Python

    import ezdxf
    from ezdxf.entities import factory

    doc = ezdxf.new()
    msp = doc.modelspace()
    line = factory.new(
        "LINE",
        dxfattribs={
            "start": (0, 0, 0),
            "end": (3, 0, 0),
            "color": 2,
        },
    )
    msp.add_entity(line)

Direct Object Instantiation
---------------------------

For advanced developers with knowledge about the internal design of `ezdxf`.

Import the entity classes from sub-package :mod:`ezdxf.entities` and instantiate
them. This will bypass the validity checks in the factory methods of the
:class:`~ezdxf.layouts.BaseLayout` class and maybe additional required setup
procedures for some entities - **study the source code!**.

.. warning::

    A refactoring of the internal `ezdxf` structures will break your code.

This new created entities are virtual entities which are not assigned to any
DXF document nor to any layout. Add the entity to a layout (and document) by
the layout method :meth:`~ezdxf.layouts.BaseLayout.add_entity`.

.. code-block:: Python

    import ezdxf
    from ezdxf.entities import Line

    doc = ezdxf.new()
    msp = doc.modelspace()
    line = Line.new(
        dxfattribs={
            "start": (0, 0, 0),
            "end": (3, 0, 0),
            "color": 2,
        }
    )
    msp.add_entity(line)


--- End of file: tasks/add_dxf_entities.rst ---



--- Start of file: tasks/add_layouts.rst ---

.. _add_layouts:

Add Layouts and Blocks
======================

Layouts are containers for DXF entities like LINE or CIRCLE. 
There exist three layouts types:

- :ref:`modelspace_concept`
- :ref:`paperspace_concept`
- :ref:`block_concept`

Modelspace
----------

The :class:`~ezdxf.layouts.Modelspace` is unique.
It is not possible to create another one.

Paperspace Layout
-----------------

All DXF versions can have multiple paperspace layouts expect DXF R12.

Add a new paperspace layout to a DXF document::

    doc.layouts.new("MyLayout")

The layout name is the name shown on the tab in CAD applications and has to be unique, 
otherwise a :class:`DXFValueError` will be raised. 

It is possible to add multiple paperspace layouts to all DXF versions, but `ezdxf` 
exports for DXF R12 only the active paperspace layout.  Any paperspace layout can be 
set as the active paperspace layout by the method: :meth:`ezdxf.layouts.Layouts.set_active_layout`.

- :meth:`ezdxf.layouts.Layouts.new`

Block Definition
----------------

Add a new block definition to a DXF document::

    doc.blocks.new("MyLayout")

The block name has to be unique, otherwise a :class:`DXFValueError` will be raised. 

Add an anonymous block definition::

    my_block = doc.blocks.new_anonymous_block()
    # store the block name, so you can create block references to this block
    block_name = my_block.name

Anonymous blocks are used internally and do not show up in the insert dialog for block 
references in CAD applications.

- :meth:`ezdxf.sections.blocks.BlocksSection.new`
- :meth:`ezdxf.sections.blocks.BlocksSection.new_anonymous_block`

.. seealso::

    **Tasks:**

    - :ref:`get_layouts`
    - :ref:`delete_layouts`
    - :ref:`add_dxf_entities`
    - :ref:`copy_or_move_entities`
    - :ref:`delete_dxf_entities`
    - :ref:`add_blockrefs`

    **Tutorials:**

    - :ref:`tut_getting_data`
    - :ref:`tut_blocks`
    - :ref:`tut_simple_drawings`
    - :ref:`tut_psp_viewports`

    **Basics:**

    - :ref:`layout`
    - :ref:`modelspace_concept`
    - :ref:`paperspace_concept`
    - :ref:`block_concept`

    **Classes:**

    - :class:`ezdxf.layouts.BaseLayout` - parent of all layouts
    - :class:`ezdxf.layouts.Layout` - parent of modelspace & paperspace
    - :class:`ezdxf.layouts.Modelspace`
    - :class:`ezdxf.layouts.Paperspace`
    - :class:`ezdxf.layouts.BlockLayout`
    - :class:`ezdxf.layouts.Layouts` - layout manager (:attr:`Drawing.layouts` attribute)
    - :class:`ezdxf.sections.blocks.BlocksSection` - blocks manager (:attr:`Drawing.blocks` attribute)


--- End of file: tasks/add_layouts.rst ---



--- Start of file: tasks/add_resources.rst ---

.. _add_resource_table_entries:

Add Resource Table Entries
==========================

All resources require a unique name in their category (names are case-insensitive).

Layer 
-----

A layer in a DXF document is a category that controls visual properties (like color and 
linetype) for associated entities. It acts like a grouping tag, not a container.

Add a new layer to a DXF document::

    doc.layers.add("MY_NEW_LAYER", color=1, linetype="DASHED")

DXF entities reference layers, but layers themselves don't directly contain entities. 
Instead, each entity has a :attr:`dxf.layer` attribute that specifies the layer by name 
it belongs to.

- :meth:`ezdxf.sections.table.LayerTable.add`

Linetype
--------

The linetype defines the rendering pattern of linear graphical entities like LINE, ARC, 
CIRCLE and so on. 

Add a new linetype to a DXF document::

    doc.linetypes.add("DOTTED", pattern=[0.2, 0.0, -0.2])

- :meth:`ezdxf.sections.table.LinetypeTable.add`

Text Style
----------

The text style defines the rendering font for text based entities like TEXT, ATTRIB and 
MTEXT.

Add a new text style to a DXF document::

    doc.styles.add("ARIAL", font="arial.ttf")

- :meth:`ezdxf.sections.table.TextstyleTable.add`

Dimension Style
---------------

The dimension style defines the initial properties for the DIMENSION entity.

Add a new dimension style to a DXF document::

    doc.dimstyles.add("EZDXF")

- :meth:`ezdxf.sections.table.DimStyleTable.add`

AppID
-----

The XDATA section of DXF entities is grouped by AppIDs and these ids require an entry in 
the :class:`AppIDTable` otherwise the DXF file in invalid (for AutoCAD)::

    doc.appids.add("EZDXF")

- :meth:`ezdxf.sections.table.AppIDTable.add`

.. seealso::

    **Tutorials:**

    - :ref:`tut_layers`
    - :ref:`tut_linetypes`
    - :ref:`tut_text`
    - :ref:`tut_mtext`
    - :ref:`tut_common_graphical_attributes`

    **Basics:**

    - :ref:`layer_concept`
    - :ref:`linetypes`
    - :ref:`lineweights`
    - :ref:`aci`
    - :ref:`true color`
    - :ref:`font resources`

    **Classes:**

    - :class:`ezdxf.entities.Layer`
    - :class:`ezdxf.entities.Linetype`
    - :class:`ezdxf.entities.Textstyle`
    - :class:`ezdxf.entities.DimStyle`
    - :class:`ezdxf.entities.Appid`
    - :mod:`ezdxf.fonts.fonts`


--- End of file: tasks/add_resources.rst ---



--- Start of file: tasks/copy_move_entities.rst ---

.. _copy_or_move_entities:

Copy or Move DXF Entities
=========================

TODO

Duplicate DXF Entities
----------------------

TODO

Move DXF Entities between Layouts
---------------------------------

TODO


--- End of file: tasks/copy_move_entities.rst ---



--- Start of file: tasks/delete_dxf_attributes.rst ---

.. _delete_dxf_attributes:

Delete DXF Attributes from Entities
===================================

All DXF attributes of an entity are grouped in the namespace attribute :attr:`dxf`. 
You can delete a DXF attribute by the `del` operator:

.. code-block:: Python

    line = msp.add_line((0, 0), (1, 0))
    line.dxf.layer = "MyLayer"
    del line.dxf.layer

    assert line.dxf.layer == "0"  # the default layer for all entities

The `del` operator raises an :class:`DXFAttributeError` if the attribute doesn't exist 
or isn't supported.  The :meth:`discard` method ignores these errors:

.. code-block:: Python

    line.dxf.discard('text')  # doesn't raise an exception

.. seealso::

    **Tasks**

    - :ref:`Common graphical DXF attributes`
    - :ref:`get_dxf_attributes`
    - :ref:`modify_dxf_attributes`

    **Tutorials:**
   
    - :ref:`tut_common_graphical_attributes`


--- End of file: tasks/delete_dxf_attributes.rst ---



--- Start of file: tasks/delete_dxf_entities.rst ---

.. _delete_dxf_entities:

Delete DXF Entities
===================

TODO

Delete Entities from Layouts
----------------------------

TODO

Delete Block Reference Attributes
---------------------------------

TODO



--- End of file: tasks/delete_dxf_entities.rst ---



--- Start of file: tasks/delete_extended_data.rst ---

.. _delete_extended_data:

Delete Extended Data
====================

TODO

.. seealso::

    **Tasks:**

    - :ref:`add_custom_data`
    - :ref:`get_extended_data`
    - :ref:`modify_extended_data`
    
    **Tutorials:**

    - :ref:`tut_custom_data`

    **Basics:**
    
    - :ref:`xdata_internals`
    - :ref:`extension_dictionary`
    - :ref:`dxf_tags_internals`

    **Classes:**
    
    - :class:`ezdxf.entities.xdata.XData`
    - :class:`ezdxf.entities.xdict.ExtensionDict`
    - :class:`ezdxf.entities.XRecord`
    - :class:`ezdxf.entities.Dictionary`
    - :class:`ezdxf.entities.DictionaryVar`

    **Helper-Classes:**

    - :class:`ezdxf.entities.xdata.XDataUserList`
    - :class:`ezdxf.entities.xdata.XDataUserDict`
    - :class:`ezdxf.urecord.UserRecord`
    - :class:`ezdxf.urecord.BinaryRecord`
    

--- End of file: tasks/delete_extended_data.rst ---



--- Start of file: tasks/delete_layouts.rst ---

.. _delete_layouts:

Delete Layouts and Blocks
=========================

Modelspace
----------

This is not possible.

Paperspace Layouts
------------------

Delete a paperspace layout and it's entities.

.. code-block::

    name = "MyLayout"
    try:
        doc.layouts.delete(name)
    except ezdxf.DXFKeyError:
        print(f"layout '{name}' not found")
    except ezdxf.DXFValueError:
        print(f"layout '{name}' cannot be deleted")
        # modelspace or last remaining paperspace layout

Block Definitions
-----------------

Delete a block definition:

.. code-block::

    try:
        doc.blocks.delete_block(name, safe=True)
    except ezdxf.DXFBlockInUseError:
        print(f"cannot delete block '{name}'")

Raises a :class:`DXFBlockInUseError` exception if the block is referenced by an INSERT
entity or if it is an anonymous/special block.

Purge/delete unused (unreferenced) block definitions:

.. versionadded:: 1.3.5

.. code-block::

    from ezdxf import blkrefs

    ...

    for name in blkrefs.find_unreferenced_blocks(doc)
        doc.blocks.delete_block(name, safe=False)

.. seealso::

    **Tasks:**

    - :ref:`add_layouts`
    - :ref:`get_layouts`
    - :ref:`add_blockrefs`
    - :ref:`delete_dxf_entities`

    **Tutorials:**

    - :ref:`tut_blocks`

    **Basics:**

    - :ref:`layout`
    - :ref:`modelspace_concept`
    - :ref:`paperspace_concept`
    - :ref:`block_concept`

    **Classes:**

    - :class:`ezdxf.layouts.Layouts`
    - :class:`ezdxf.document.Drawing`

    **Modules:**

    - :mod:`ezdxf.blkrefs`


--- End of file: tasks/delete_layouts.rst ---



--- Start of file: tasks/delete_resources.rst ---

.. _delete_resources:

Delete Resource Table Entries
=============================

TODO

Layer 
-----

TODO

Linetype
--------

TODO

Text Style
----------

TODO

Dimension Style
---------------

TODO


--- End of file: tasks/delete_resources.rst ---



--- Start of file: tasks/explode_blocks.rst ---

.. _explode_block_references:

Explode Block References
========================

TODO



--- End of file: tasks/explode_blocks.rst ---



--- Start of file: tasks/explode_entities.rst ---

.. _explode_dxf_entities:

Explode DXF Entities
====================

TODO

POINT
-----

TODO

POLYLINE & LWPOLYLINE
---------------------

TODO

MESH
----

TODO

INSERT (Block References)
-------------------------

:ref:`explode_block_references`

DIMENSION
---------

TODO

MLEADER
-------

TODO

MLINE
-----

TODO

ACAD_TABLE
----------

TODO

Proxy Graphic
-------------

TODO


--- End of file: tasks/explode_entities.rst ---



--- Start of file: tasks/flatten_entities.rst ---

.. _flatten_entities:

Flatten DXF Entities
====================

TODO

--- End of file: tasks/flatten_entities.rst ---



--- Start of file: tasks/get_dxf_attributes.rst ---

.. _get_dxf_attributes:

Get DXF Attributes From Entities
================================

All DXF attributes of an entity are grouped in the namespace attribute :attr:`dxf`:

.. code-block:: Python

    e.dxf.layer  # layer of the entity as string
    e.dxf.color  # color of the entity as integer

The :attr:`dxf` namespace attribute has a :meth:`get` method, which can return a 
default value if the attribute doesn't exist:

.. code-block:: Python

    e.dxf.get('color', 9)

The attribute has to be supported by the DXF type otherwise a :class:`DXFAttributeError` 
will be raised.  You can check if an DXF attribute is supported by the method 
:meth:`dxf.is_supported`:

.. code-block:: Python

    line = msp.add_line((0, 0), (1, 0))
    assert line.dxf.is_supported("text") is False

Optional DXF Attributs
----------------------

Many DXF attributes are optional, you can check if an attribute exists by the 
:meth:`hasattrib` method:

.. code-block:: Python

    assert line.dxf.hasattrib("linetype") is False

Default Values
--------------

Some DXF attributes have default values and this default value will be returned if the 
DXF attribute doesn't exist:

.. code-block:: Python

    assert line.dxf.linetype == "BYLAYER"

.. seealso::

    **Tasks:**

    - :ref:`Common graphical DXF attributes`    
    - :ref:`modify_dxf_attributes`
    - :ref:`delete_dxf_attributes`

    **Tutorials:**
   
    - :ref:`tut_common_graphical_attributes`
    - :ref:`tut_getting_data`





--- End of file: tasks/get_dxf_attributes.rst ---



--- Start of file: tasks/get_entity_content.rst ---


.. _get_entity_content:

Get Content From DXF Entities
=============================

TEXT Entity
-----------

The content of the TEXT entity is stored in a single DXF attribute :attr:`Text.dxf.text` 
and has an empty string as default value:

.. code-block:: Python

    for text in msp.query("TEXT"):
        print(text.dxf.text)

The :meth:`~ezdxf.entities.Text.plain_text` method returns the content of the TEXT 
entity without formatting codes.

.. seealso::

    **Classes**

    - :class:`ezdxf.entities.Text`

    **Tutorials**

    - :ref:`tut_text`

MTEXT Entity
------------

The content of the MTEXT entity is stored in multiple DXF attributes. The content can be 
accessed by the read/write property :attr:`~ezdxf.entities.MText.text` and the DXF attribute 
:attr:`MText.dxf.text` and has an empty string as default value:

.. code-block:: Python

    for mtext in msp.query("MTEXT"):
        print(mtext.text)
        # is the same as:
        print(mtext.dxf.text)

.. important::

    The line ending character ``\n`` will be replaced automatically by the MTEXT line 
    ending ``\P``.

The :meth:`~ezdxf.entities.MText.plain_text` method returns the content of the MTEXT 
entity without inline formatting codes.

.. seealso::

    **Classes**

    - :class:`ezdxf.entities.MText`
    - :class:`ezdxf.tools.text.MTextEditor`

    **Tutorials**

    - :ref:`tut_mtext`

MLEADER Entity
--------------

The content of MLEADER entities is stored in the :attr:`MultiLeader.context` object.  
The MLEADER contains text content if the :attr:`context.mtext` attribute is not ``None`` 
and block content if the :attr:`context.block` attribute is not ``None``

.. seealso::

    **Classes**

    - :class:`ezdxf.entities.MultiLeader`
    - :class:`ezdxf.entities.MLeaderContext`
    - :class:`ezdxf.entities.MTextData`
    - :class:`ezdxf.entities.BlockData`
    - :class:`ezdxf.entities.AttribData`

    **Tutorials**

    - :ref:`tut_mleader`

Text Content
~~~~~~~~~~~~

.. code-block:: Python

    for mleader in msp.query("MLEADER MULTILEADER"):
        mtext = mleader.context.mtext
        if mtext:
            print(mtext.insert)  # insert location
            print(mtext.default_content)  # text content

The text content supports the same formatting features as the MTEXT entity.

Block Content
~~~~~~~~~~~~~

The INSERT (block reference) attributes are stored in :attr:`MultiLeader.context.block` 
as :class:`~ezdxf.entities.BlockData`.

.. code-block:: Python

    for mleader in msp.query("MLEADER MULTILEADER"):
        block = mleader.context.block
        if block:
            print(block.insert)  # insert location


The ATTRIB attributes are stored outside the context object in :attr:`MultiLeader.block_attribs` 
as :class:`~ezdxf.entities.AttribData`.

.. code-block:: Python

    for mleader in msp.query("MLEADER MULTILEADER"):
        for attrib in mleader.block_attribs:
            print(attrib.text)  # text content of the ATTRIB entity


DIMENSION Entity
----------------

Get real measurement determined by definition points:

.. code-block:: Python

    for dimension in msp.query("DIMENSION"):
        print(str(dimension))
        print(f"Dimension Type: {dimension.dimtype}")
        print(f"Measurement: {dimension.get_measurement()}")

==== ============================== ===
Type Dimension Type                 Measurement
==== ============================== ===
0    Linear and Rotated Dimension   length in drawing units
1    Aligned Dimension              length in drawing units
2    Angular Dimension              angle in degree
3    Diameter Dimension             length in drawing units
4    Radius Dimension               length in drawing units
5    Angular 3P Dimension           angle in degree
6    Ordinate Dimension             feature location as :class:`~ezdxf.math.Vec3`
==== ============================== ===

Get measurement text. This is how the measurement text was rendered into the associated
geometry block by the CAD application as the DIMENSION entity was created:

.. code-block:: Python

    for dimension in msp.query("DIMENSION"):
        print(str(dimension))
        print(f"Measurement Text: {dimension.dxf.text}")

======== ===
Text     Measurement text rendered by CAD application
======== ===
``"<>"`` actual measurement
``""``   (empty string) actual measurement
``" "``  (space) measurement text is suppressed
other    measurement text entered by the CAD user
======== ===

Get measurement text from text entities in the associated geometry block. This is the
actual measurement text displayed by CAD applications:

.. code-block:: Python

    for dimension in msp.query("DIMENSION"):
        print(str(dimension))
        block = dimension.get_geometry_block()
        if block is None:
            print("Geometry block not found.")
            continue
        for entity in block.query("TEXT MTEXT"):
            print(f"{str(entity)}: {entity.dxf.text}")

.. seealso::

    **Tutorials:**

    - :ref:`tut_linear_dimension`

    **Classes:**

    - :class:`ezdxf.entities.Dimension`

ACAD_TABLE Entity
-----------------

The helper function :func:`read_acad_table_content` returns the content of an ACAD_TABLE
entity as list of table rows. If the count of table rows or table columns is missing the
complete content is stored in the first row. All cells contain strings.

.. code-block:: Python

    from ezdxf.entities.acad_table import read_acad_table_content

    ...

    for acad_table in msp.query("ACAD_TABLE"):
        content = read_acad_table_content(acad_table)
        for n, row in enumerate(content):
            for m, value in enumerate(row):
                print(f"cell [{n}, {m}] = '{value}'")

.. important::

    The ACAD_TABLE entity has only limited support to preserve the entity. There is no
    support for adding a new ACAD_TABLE entity or modifying it's content.

INSERT Entity - Block References
--------------------------------

Get Block Attributes
~~~~~~~~~~~~~~~~~~~~

Get a block attribute by tag:

.. code-block:: Python

    diameter = insert.get_attrib('diameter')
    if diameter is not None:
        print(f"diameter = {diameter.dxf.text}")

Iterate over all block attributes:

.. code-block:: Python

    for attrib in insert.attribs:
        print(f"{attrib.dxf.tag} = {attrib.dxf.text}")

.. important::

    Do not confuse block attributes and DXF entity attributes, these are different
    concepts!

Get Block Entities
~~~~~~~~~~~~~~~~~~

Get block entities as virtual DXF entities from an :class:`~ezdxf.entities.Insert` entity:

.. code-block:: Python

    for insert in msp.query("INSERT"):
        for entity in insert.virtual_entities():
            print(str(entity))

Get Transformation Matrix
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: Python

    m = insert.matrix44()

This transformation matrix transforms the virtual block entities from the block reference
coordinate system into the :ref:`WCS`.

.. seealso::

    **Tasks:**

    - :ref:`add_blockrefs`
    - :ref:`explode_block_references`

    **Tutorials:**

    - :ref:`tut_blocks`

    **Basics:**

    - :ref:`block_concept`

    **Classes:**

    - :class:`ezdxf.entities.Insert`
    - :class:`ezdxf.entities.Attrib`
    - :class:`ezdxf.entities.AttDef`
    - :class:`ezdxf.math.Matrix44`


--- End of file: tasks/get_entity_content.rst ---



--- Start of file: tasks/get_entity_type.rst ---

.. _get_entity_type:

Get DXF Entity Type
===================

The :meth:`~ezdxf.entities.DXFEntity.dxftype` method returns the entity type as defined 
by the DXF reference as an uppercase string.

.. code-block:: Python

    e = msp.add_line((0, 0), (1, 0))
    assert e.dxftype() == "LINE"

.. seealso::

    - `DXF Reference`_ for DXF R2018

.. _DXF Reference: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-235B22E0-A567-4CF6-92D3-38A2306D73F3

--- End of file: tasks/get_entity_type.rst ---



--- Start of file: tasks/get_extended_data.rst ---

.. _get_extended_data:

Get Extended Data from DXF Entities
===================================

HEADER Variables
----------------

.. code-block:: Python

    i1 = doc.header["$USERI1"]  # integer
    r1 = doc.header["$USERR1"]  # float


XDATA Section
-------------

The structure of XDATA is arbitrary and only some structures used by AutoCAD are
documented in the DXF reference. Use the :ref:`browse_command` command to explore these
structures directly in DXF files.

.. code-block:: Python

    my_app_id = "MY_APP_1"
    if line.has_xdata(my_app_id):
        tags = line.get_xdata(my_app_id)
        print(f"{str(line)} has {len(tags)} tags of XDATA for AppID {my_app_id!r}")
        for tag in tags:
            print(tag)

- :meth:`ezdxf.entities.DXFEntity.get_xdata`

Extension Dictionaries
----------------------

Like XDATA the structure of extension dictionaries is arbitrary and not documented by
the DXF reference.

.. code-block:: Python

    for line in msp.query("LINE"):
        if line.has_extension_dict:
            # get the extension dictionary
            xdict = line.get_extension_dict()

- :meth:`ezdxf.entities.DXFEntity.get_extension_dict`

.. seealso::

    **Tasks:**

    - :ref:`add_custom_data`
    - :ref:`modify_extended_data`
    - :ref:`delete_extended_data`
    
    **Tutorials:**

    - :ref:`tut_custom_data`

    **Basics:**
    
    - :ref:`xdata_internals`
    - :ref:`extension_dictionary`
    - :ref:`dxf_tags_internals`

    **Classes:**
    
    - :class:`ezdxf.entities.xdata.XData`
    - :class:`ezdxf.entities.xdict.ExtensionDict`
    - :class:`ezdxf.entities.XRecord`
    - :class:`ezdxf.entities.Dictionary`
    - :class:`ezdxf.entities.DictionaryVar`

    **Helper-Classes:**

    - :class:`ezdxf.entities.xdata.XDataUserList`
    - :class:`ezdxf.entities.xdata.XDataUserDict`
    - :class:`ezdxf.urecord.UserRecord`
    - :class:`ezdxf.urecord.BinaryRecord`
    

--- End of file: tasks/get_extended_data.rst ---



--- Start of file: tasks/get_layouts.rst ---

.. _get_layouts:

Get Layouts and Blocks
======================

Layouts and blocks contain all the graphical entities likes LINE, CIRCLE and so on.

Get all paperspace and modelspace layout names in arbitrary order:

.. code-block::

    layout_names = doc.layout_names()

Get all paperspace and modelspace layout names in tab-order of CAD applications:

.. code-block::

    layout_names = doc.layout_names_in_taborder()

Modelspace
----------

Each DXF document has one and only one :ref:`modelspace_concept` layout.

The :meth:`~ezdxf.document.Drawing.modelspace` method of the :class:`~ezdxf.document.Drawing`
class returns the :class:`~ezdxf.layouts.Modelspace` object.

.. code-block::

    msp = doc.modelspace()

Paperspace Layouts
------------------

Each DXF document has one or more :ref:`paperspace_concept` layout. DXF R12 supports
only one paperspace layout.

Get the active (default) paperspace layout:

.. code-block::

    psp = doc.paperspace()

Get a paperspace layout by name:

.. code-block::

    psp = doc.paperspace("Layout0")

The `name` argument is the name shown in the tabs of CAD applications.

Block Layouts
-------------

:ref:`block_concept` are collections of DXF entities which can be placed multiple times
as block references in different layouts and other block definitions.


Iterate over all block definitions:

.. code-block::

    for block in doc.blocks:
        print(block.name)

Get block definition by name:

.. code-block::

    block = doc.blocks.get("MyBlock")
    if block is None:
        print("block not found.")

Count block references:

.. code-block::

    from ezdxf import blkrefs

    ...

    counter = blkrefs.BlockReferenceCounter(doc)

    count = counter.by_name("MyBlock")
    print(f"MyBlock is referenced {count} times."

Find unused (unreferenced) block definitions:

.. versionadded:: 1.3.5

.. code-block::

    from ezdxf import blkrefs

    ...

    for name in blkrefs.find_unreferenced_blocks(doc)
        block = doc.blocks.get(name)

.. seealso::

    **Tasks:**

    - :ref:`add_layouts`
    - :ref:`delete_layouts`
    - :ref:`add_blockrefs`
    - :ref:`delete_dxf_entities`

    **Tutorials:**

    - :ref:`tut_blocks`

    **Basics:**

    - :ref:`layout`
    - :ref:`modelspace_concept`
    - :ref:`paperspace_concept`
    - :ref:`block_concept`

    **Classes:**

    - :class:`ezdxf.layouts.Modelspace`
    - :class:`ezdxf.layouts.Paperspace`
    - :class:`ezdxf.layouts.BlockLayout`
    - :class:`ezdxf.sections.blocks.BlocksSection`
    - :class:`ezdxf.document.Drawing`

    **Modules:**

    - :mod:`ezdxf.blkrefs`



--- End of file: tasks/get_layouts.rst ---



--- Start of file: tasks/groupby.rst ---

.. _groupby_function:

.. module:: ezdxf.groupby

Groupby Function
================

.. seealso::

    Tutorial: :ref:`using_groupby`

.. autofunction:: groupby




--- End of file: tasks/groupby.rst ---



--- Start of file: tasks/index.rst ---

.. _tasks:

Tasks
=====

These topics provide brief overviews of how to complete specific tasks, but they're not 
comprehensive tutorials.  For a deeper understanding, explore the beginner's guide, 
explanations of basic concepts, in-depth tutorials, the reference guide, example code, 
and even the source code itself.

Add Data
--------

.. toctree::
    :maxdepth: 2

    add_dxf_entities
    add_layouts
    add_blockrefs
    add_resources
    add_custom_data

Query Data
----------

.. toctree::
    :maxdepth: 2

    query
    groupby
    select
    get_entity_type
    get_dxf_attributes
    get_entity_content
    get_extended_data
    get_layouts

Modify Data
-----------

.. toctree::
    :maxdepth: 2

    modify_dxf_attributes
    modify_resources
    modify_entity_geometry
    transform_entities_and_layouts
    copy_move_entities
    modify_block_references
    modify_entity_content
    modify_header_variables
    modify_extended_data

Delete Data
-----------

.. toctree::
    :maxdepth: 2

    delete_dxf_attributes
    delete_dxf_entities
    delete_resources
    delete_layouts
    delete_extended_data


Explode Entities
----------------

.. toctree::
    :maxdepth: 2

    explode_entities
    explode_blocks
    flatten_entities


--- End of file: tasks/index.rst ---



--- Start of file: tasks/modify_block_references.rst ---

.. _modify_block_references:

Modify Block References
=======================

TODO

Modify Block attributes
-----------------------

TODO

Clip Block References
---------------------

TODO


--- End of file: tasks/modify_block_references.rst ---



--- Start of file: tasks/modify_dxf_attributes.rst ---

.. _modify_dxf_attributes:

Modify DXF Attributes of Entities
=================================

All DXF attributes of an entity are grouped in the namespace attribute :attr:`dxf`. 
You can modify/set a DXF attribute by assignment:

.. code-block:: Python

    e.dxf.layer = "MyLayer"
    e.dxf.color = 9

... or by the :meth:`set` method:

.. code-block:: Python

    e.dxf.set('color', 9)

The attribute has to be supported by the DXF type otherwise a :class:`DXFAttributeError` 
will be raised.  You can check if an DXF attribute is supported by the method 
:meth:`dxf.is_supported`:

.. code-block:: Python

    line = msp.add_line((0, 0), (1, 0))
    assert line.dxf.is_supported("text") is False


.. seealso::
    
    **Tasks**

    - :ref:`Common graphical DXF attributes`
    - :ref:`get_dxf_attributes`
    - :ref:`delete_dxf_attributes`

    **Tutorials:**
   
    - :ref:`tut_common_graphical_attributes`


--- End of file: tasks/modify_dxf_attributes.rst ---



--- Start of file: tasks/modify_entity_content.rst ---

.. _modify_entity_content:

Modify Entity Content
=====================

TODO

TEXT Entity
-----------

TODO

MTEXT Entity
------------

TODO

DIMENSION  Entity
-----------------

Delete the existing DIMENSION and create a new one.

MLEADER Entity
--------------

Delete the existing MLEADER and create a new one.

ACAD_TABLE Entity
-----------------

Not supported.



--- End of file: tasks/modify_entity_content.rst ---



--- Start of file: tasks/modify_entity_geometry.rst ---

.. _modify_entity_geometry:

Modify Geometry of DXF Entities
================================

TODO

LINE 
----

TODO

CIRCLE
------

TODO

ARC
---

TODO

ELLIPSE
-------

TODO

SPLINE
------

TODO

LWPOLYLINE
----------

TODO

POLYLINE
--------

TODO

MESH
----

TODO

HATCH
-----

TODO

DIMENSION
---------

Delete the existing DIMENSION and create a new one.

MLEADER
-------

Delete the existing MLEADER and create a new one.

ACAD_TABLE
----------

Not supported.



--- End of file: tasks/modify_entity_geometry.rst ---



--- Start of file: tasks/modify_extended_data.rst ---

.. _modify_extended_data:

Modify Extended Data
====================

TODO

.. seealso::

    **Tasks:**

    - :ref:`add_custom_data`
    - :ref:`get_extended_data`
    - :ref:`delete_extended_data`
    
    **Tutorials:**

    - :ref:`tut_custom_data`

    **Basics:**
    
    - :ref:`xdata_internals`
    - :ref:`extension_dictionary`
    - :ref:`dxf_tags_internals`

    **Classes:**
    
    - :class:`ezdxf.entities.xdata.XData`
    - :class:`ezdxf.entities.xdict.ExtensionDict`
    - :class:`ezdxf.entities.XRecord`
    - :class:`ezdxf.entities.Dictionary`
    - :class:`ezdxf.entities.DictionaryVar`

    **Helper-Classes:**

    - :class:`ezdxf.entities.xdata.XDataUserList`
    - :class:`ezdxf.entities.xdata.XDataUserDict`
    - :class:`ezdxf.urecord.UserRecord`
    - :class:`ezdxf.urecord.BinaryRecord`
    

--- End of file: tasks/modify_extended_data.rst ---



--- Start of file: tasks/modify_header_variables.rst ---

.. _modify_header_variables:

Modify Header Variables
=======================

TODO


--- End of file: tasks/modify_header_variables.rst ---



--- Start of file: tasks/modify_resources.rst ---

.. _modify_resources:

Modify Resource Table Entries
=============================

TODO

Layer 
-----

TODO

Linetype
--------

TODO

Text Style
----------

TODO

Dimension Style
---------------

TODO



--- End of file: tasks/modify_resources.rst ---



--- Start of file: tasks/query.rst ---

.. Task section

.. module:: ezdxf.query
    :noindex:

.. _query entities:

Query Entities
==============

DXF entities can be selected from layouts or arbitrary entity-sequences based on their 
DXF type and attributes.  Create new queries be the :func:`new` function or by the 
:meth:`~ezdxf.layouts.BaseLayout.query` methods implemented by all layouts.

.. seealso::

    - Tutorial: :ref:`tut_getting_data`
    - Reference: :mod:`ezdxf.query` module

Entity Query String
-------------------

The query string is the combination of two queries, first the required entity query and 
second the optional attribute query, enclosed in square brackets, append ``'i'`` after 
the closing square bracket to ignore case for strings.


.. _query result:

Query Result
------------

The :class:`EntityQuery` class is the return type of all :meth:`query` methods.
:class:`EntityQuery` contains all DXF entities of the source collection,
which matches one name of the entity query AND the whole attribute query.
If a DXF entity does not have or support a required attribute, the corresponding
attribute search term is ``False``.

Select all LINE and CIRCLE entities with layer  == "construction"::

    result = msp.query('LINE CIRCLE[layer=="construction"]')

This result is always empty, because the LINE entity has no text attribute::

    result = msp.query('LINE[text ? ".*"]')

Select all entities except those with layer  == "construction" and color < 7::

    result = msp.query('*[!(layer=="construction" & color<7)]')

Ignore case, selects all entities with layer == "construction", "Construction", "ConStruction" ...::

    result = msp.query('*[layer=="construction"]i')

.. _extended query features:

Extended EntityQuery Features
-----------------------------

The :class:`EntityQuery` container supports the full Sequence protocol::

    result = msp.query(...)
    first = result[0]
    last = result[-1]

Slices return a new :class:`EntityQuery` container::

    sequence = result[1:-2]

The :meth:`__getitem__` function accepts also a DXF attribute name and returns all 
entities which support this attribute, this is the base for supporting queries by 
relational operators. More on that later.

The :meth:`__setitem__` method assigns a DXF attribute to all supported
entities in the :class:`EntityQuery` container:

.. code-block:: Python

    result = msp.query(...)
    result["layer"] = "MyLayer"

Entities which do not support an attribute are silently ignored:

.. code-block:: Python

    result = msp.query(...)
    result["center"] = (0, 0)  # set center only of CIRCLE and ARC entities

The :meth:`__delitem__` method discards DXF attributes from all entities in
the :class:`EntityQuery` container:

.. code-block:: Python

    result = msp.query(...)
    # reset the layer attribute from all entities in container result to the
    # default layer "0"
    del result["layer"]

Descriptors for DXF Attributes
------------------------------

For some basic DXF attributes exist descriptors in the :class:`EntityQuery` class:

- :attr:`layer`: layer name as string
- :attr:`color`: :ref:`ACI`, see :mod:`ezdxf.colors`
- :attr:`linetype`: linetype as string
- :attr:`ltscale`: linetype scaling factor as float value
- :attr:`lineweight`: :ref:`Lineweights`
- :attr:`invisible`: 0 if visible 1 if invisible, 0 is the default value
- :attr:`true_color`: true color as int value, see :mod:`ezdxf.colors`, has no default value
- :attr:`transparency`: transparency as int value, see :mod:`ezdxf.colors`, has no default value

A descriptor simplifies the attribute access through the :class:`EntityQuery`
container and has auto-completion support from IDEs:

.. code-block:: Python

    result = msp.query(...)
    # set attribute of all entities in result
    result.layer = "MyLayer"
    # delete attribute from all entities in result
    del result.layer
    # and for selector usage, see following section
    assert len(result.layer == "MyLayer") == 1

.. _relational selection operators:

Relational Selection Operators
------------------------------

The attribute selection by :meth:`__getitem__` allows further selections by
relational operators:

.. code-block:: Python

    msp.add_line((0, 0), (1, 0), dxfattribs={"layer": "MyLayer})
    lines = msp.query("LINE")
    # select all entities on layer "MyLayer"
    entities = lines["layer"] == "MyLayer"
    assert len(entities) == 1

    # or select all entities except the entities on layer "MyLayer"
    entities = lines["layer"] != "MyLayer"

These operators work only with real DXF attributes, for instance the :attr:`rgb`
attribute of graphical entities is not a real DXF attribute either the
:attr:`vertices` of the LWPOLYLINE entity.

The selection by relational operators is case insensitive by default, because
all names of DXF table entries are handled case insensitive. But if required
the selection mode can be set to case sensitive:

.. code-block:: Python

    lines = msp.query("LINE")
    # use case sensitive selection: "MyLayer" != "MYLAYER"
    lines.ignore_case = False
    entities = lines["layer"] == "MYLAYER"
    assert len(entities) == 0

    # the result container has the default setting:
    assert entities.ignore_case is True

Supported selection operators are:

  - ``==`` equal "value"
  - ``!=`` not equal "value"
  - ``<`` lower than "value"
  - ``<=`` lower or equal than "value"
  - ``>`` greater than "value"
  - ``>=`` greater or equal than "value"

The relational operators <, >, <= and >= are not supported for vector-based
attributes such as `center` or `insert` and raise a :class:`TypeError`.

.. note::

    These operators are selection operators and not logic operators, therefore
    the logic operators ``and``, ``or`` and ``not`` are **not** applicable.
    The methods :meth:`~EntityQuery.union`, :meth:`~EntityQuery.intersection`,
    :meth:`~EntityQuery.difference` and :meth:`~EntityQuery.symmetric_difference`
    can be used to combine selection. See section `Query Set Operators`_ and
    `Build Custom Filters`_.

.. _regular expression selection:

Regular Expression Selection
----------------------------

The :meth:`EntityQuery.match` method returns all entities where the selected DXF
attribute matches the given regular expression. This methods work only on string
based attributes, raises :class:`TypeError` otherwise.

From here on I use only descriptors for attribute selection if possible.

.. code-block:: Python

    msp.add_line((0, 0), (1, 0), dxfattribs={"layer": "Lay1"})
    msp.add_line((0, 0), (1, 0), dxfattribs={"layer": "Lay2"})
    lines = msp.query("LINE")

    # select all entities at layers starting with "Lay",
    # selection is also case insensitive by default:
    assert len(lines.layer.match("^Lay.*")) == 2

.. _build custom filters:

Build Custom Filters
--------------------

The method :class:`EntityQuery.filter` can be used to build operators for
none-DXF attributes or for complex logic expressions.

Find all MTEXT entities in modelspace containing "SearchText".
All :class:`~ezdxf.entities.MText` entities have a :attr:`text` attribute, no
need for a safety check:

.. code-block:: Python

    mtext = msp.query("MTEXT").filter(lambda e: "SearchText" in e.text)

This filter checks the non-DXF attribute :attr:`rgb`. The filter has to
check if the :attr:`rgb` attributes exist to avoid exceptions, because not all
entities in modelspace may have the :attr:`rgb` attribute e.g. the
:class:`DXFTagStorage` entities which preserve unknown DXF entities:

.. code-block:: Python

    result = msp.query().filter(
        lambda e: hasattr(e, "rgb") and e.rgb == (0, 0, 0)
    )

Build 1-pass logic filters for complex queries, which would require otherwise
multiple passes:

.. code-block:: Python

    result = msp.query().filter(lambda e: e.dxf.color < 7 and e.dxf.layer == "0")

Combine filters for more complex operations. The first filter passes only
valid entities and the second filter does the actual check:

.. code-block:: Python

    def validator(entity):
        return True  # if entity is valid and has all required attributes

    def check(entity):
        return True  # if entity passes the attribute checks

    result = msp.query().filter(validator).filter(check)

.. _query set operators:

Query Set Operators
-------------------

The ``|`` operator or :meth:`EntityQuery.union` returns a new
:class:`EntityQuery` with all entities from both queries. All entities are
unique - no duplicates. This operator acts like the logical ``or`` operator.

.. code-block:: Python

    entities = msp.query()
    # select all entities with color < 2 or color > 7
    result = (entities.color < 2 ) | (entities.color > 7)

The ``&`` operator or :meth:`EntityQuery.intersection` returns a new
:class:`EntityQuery` with entities common to `self` and `other`. This operator
acts like the logical ``and`` operator.

.. code-block:: Python

    entities = msp.query()
    # select all entities with color > 1 and color < 7
    result = (entities.color > 1) & (entities.color < 7)

The ``-`` operator or :meth:`EntityQuery.difference` returns a new
:class:`EntityQuery` with all entities from `self` that are not in `other`.

.. code-block:: Python

    entities = msp.query()
    # select all entities with color > 1 and not layer == "MyLayer"
    result = (entities.color > 1) - (entities.layer != "MyLayer")

The ``^`` operator or :meth:`EntityQuery.symmetric_difference` returns a new
:class:`EntityQuery` with entities in either `self` or `other` but not both.

.. code-block:: Python

    entities = msp.query()
    # select all entities with color > 1 or layer == "MyLayer", exclusive
    # entities with color > 1 and layer == "MyLayer"
    result = (entities.color > 1) ^ (entities.layer == "MyLayer")



--- End of file: tasks/query.rst ---



--- Start of file: tasks/select.rst ---


.. module:: ezdxf.select

Selection Tools
===============


The :mod:`ezdxf.select` module provides entity selection capabilities, allowing users to 
select entities based on various shapes such as windows, points, circles, polygons, and 
fences.

The selection functions :func:`bbox_inside` and :func:`bbox_outside` work similarly to the 
inside and outside selection tools in CAD applications but the selection is based on the 
bounding box of the DXF entities rather than their actual geometry.

The :func:`bbox_overlap` function works similarly to crossing selection in CAD applications. 
Entities that are outside the selection shape but whose bounding box overlapps the 
selection shape are included in the selection. This is not the case with crossing 
selection in CAD applications.

The selection functions accept any iterable of DXF entities as input and return an 
:class:`ezdxf.query.EntityQuery` container, that provides further selection tools 
based on entity type and DXF attributes.

Usage
-----

Select all entities from the modelspace inside a window defined by two opposite vertices:

.. code-block:: Python

    import ezdxf
    from ezdxf import select

    doc = ezdxf.readfile("your.dxf")
    msp = doc.modelspace()

    # Define a window for selection
    window = select.Window((0, 0), (10, 10))

    # Select entities inside the window from modelspace
    selected_entities = select.bbox_inside(window, msp)

    # Iterate over selected entities
    for entity in selected_entities:
        print(entity)

.. seealso::

    - :ref:`tut_entity_selection`

Selection Functions
-------------------

The following selection functions are implemented:

    - :func:`bbox_inside`
    - :func:`bbox_outside`
    - :func:`bbox_overlap`
    - :func:`bbox_chained`
    - :func:`bbox_crosses_fence`
    - :func:`point_in_bbox`


.. autofunction:: bbox_inside

.. autofunction:: bbox_outside

.. autofunction:: bbox_overlap

.. autofunction:: bbox_chained

.. autofunction:: bbox_crosses_fence

.. autofunction:: point_in_bbox


Selection Shapes
----------------

The following selection shapes are implemented:

- :class:`Window`
- :class:`Circle`
- :class:`Polygon`


.. autoclass:: Window

.. autoclass:: Circle

.. autoclass:: Polygon

Planar Search Index
-------------------

.. versionadded:: 1.4
    
.. autoclass:: PlanarSearchIndex

    .. automethod:: detection_point_in_circle

    .. automethod:: detection_point_in_rect

    .. automethod:: detection_points

--- End of file: tasks/select.rst ---



--- Start of file: tasks/transform_entities_and_layouts.rst ---

.. _transform_entities_and_layouts:

Transform Entities and Layouts
==============================

TODO

Transform DXF Entities
----------------------

TODO

Transform Layouts
-----------------

TODO


--- End of file: tasks/transform_entities_and_layouts.rst ---



--- Start of file: tools/appsettings.rst ---


.. _ezdxf_appsettings:

Application Settings
====================

.. module:: ezdxf.appsettings

This is a high-level module for working with CAD application settings and behaviors.
None of these settings have any influence on the behavior of `ezdxf`, since
`ezdxf` only takes care of the content of the DXF file and not of the way it is
presented to the user.

.. important::

    You need to understand that these settings work at the application level,
    `ezdxf` cannot force an application to do something in a certain way!
    The functionality of this module has been tested with Autodesk TrueView and
    BricsCAD, other applications may show different results or ignore the
    settings.

Set Current Properties
----------------------

The current properties are used by the CAD application to create new entities,
these settings do not affect how `ezdxf` creates new entities.

The module :mod:`ezdxf.gfxattribs` provides the class :meth:`~ezdxf.gfxattribs.GfxAttribs`,
which can load the current graphical entity settings from the HEADER section
for creating new entities by `ezdxf`: :meth:`~ezdxf.gfxattribs.GfxAttribs.load_from_header`

.. autofunction:: set_current_layer

.. autofunction:: set_current_color

.. autofunction:: set_current_linetype

.. autofunction:: set_current_lineweight

.. autofunction:: set_current_linetype_scale

.. autofunction:: set_current_textstyle

.. autofunction:: set_current_dimstyle

.. autofunction:: set_current_dimstyle_attribs

.. autofunction:: set_lineweight_display_style


Restore the WCS
---------------

.. autofunction:: restore_wcs

Update Extents
--------------

.. autofunction:: update_extents

Show Lineweight
---------------

.. autofunction:: show_lineweight


--- End of file: tools/appsettings.rst ---



--- Start of file: tools/comments.rst ---

Load DXF Comments
=================

.. module:: ezdxf.comments

.. autofunction:: from_stream

.. autofunction:: from_file

--- End of file: tools/comments.rst ---



--- Start of file: tools/fonts.rst ---

Fonts
=====

.. module:: ezdxf.fonts.fonts

The module :mod:`ezdxf.fonts.fonts` manages the internal usage of fonts and
has no relation how the DXF formats manages text styles.

.. seealso::

    The :class:`~ezdxf.entities.Textstyle` entity, the DXF way to define fonts.


.. versionadded:: 1.1

Since `ezdxf` v1.1 text rendering is done by the `fontTools`_ package.
Support for stroke fonts, these are the basic vector fonts included in CAD
applications, like .shx, .shp or .lff fonts was also added.

None of the required font files (.ttf, .ttc, .otf, .shx, .shp or .lff) are included in
`ezdxf` as they are copyrighted or, in the case of the LibreCAD font format (.lff),
licensed under the "GPL v2 and later".


Font Locations
--------------

TrueType Fonts
~~~~~~~~~~~~~~

The font manager searches the following directories recursively for .ttf, .ttc and .otf
font files.

- Windows:
    - ~/AppData/Local/Microsoft/Windows/Fonts
    - <SystemRoot>/Fonts

- Linux and other \*nix like systems:
    - /usr/share/fonts
    - /usr/local/share/fonts
    - ~/.fonts
    - ~/.local/share/fonts
    - ~/.local/share/texmf/fonts

- macOS:
    - /Library/Fonts
    - /System/Library/Fonts

The `fc-list` command on Linux shows all available fonts and their location.

The default font is selected in the following order, if none of them is available on
your system - install one of them, the open source fonts can be found in the github
repository in the folder `ezdxf/fonts`_.

- Arial.ttf
- DejaVuSansCondensed.ttf
- DejaVuSans.ttf
- LiberationSans-Regular.ttf
- OpenSans-Regular.ttf

Basic Stroke Fonts
~~~~~~~~~~~~~~~~~~

There is no universal way to find the basic stroke fonts of CAD applications on a
system, beside scanning all drives. Set the paths to the stroke fonts in your config
file manually to tell `ezdxf` where to search for them, all paths are search recursively,
see also option :attr:`ezdxf.options.support_dirs`:

.. code-block:: ini

    [core]
    support_dirs =
        "C:\Program Files\Bricsys\BricsCAD V23 en_US\Fonts",
        ~/shx_fonts,
        ~/shp_fonts,
        ~/lff_fonts,

The .shx fonts can be found on the internet but be aware that they are not free as all
websites claim. The LibreCAD font files (.llf) can be downloaded from their github
repository: https://github.com/LibreCAD/LibreCAD/tree/master/librecad/support/fonts

.. important::

    When you add new font directories to ``support_dirs`` or new fonts to one of the
    support directories, you have to rebuild the font cache to use these fonts,
    see section :ref:`Rebuilding the Font Cache` for more information.

Font Caching
------------

The fonts available on a system are cached automatically, the cache has to be rebuild
by the :func:`build_system_font_cache` function to recognize new installed fonts or when
you add new font directories to the config file.

The cache is stored in the users home directory "~/.cache/ezdxf" or the directory
specified by the environment variable "XDG_CACHE_HOME".

.. _Rebuilding the Font Cache:

Rebuilding the Font Cache
-------------------------

When you add new fonts to your system or add a font directory to the support directories 
in the config file you have to rebuild the font-cache of `ezdxf` to
recognize these new fonts:

.. code-block:: Python

    import ezdxf
    from ezdxf.fonts import fonts

    fonts.build_system_font_cache()

or call the `ezdxf` launcher to do that::

    ezdxf --fonts

Functions
---------

.. autofunction:: make_font

.. autofunction:: get_font_face

.. autofunction:: find_font_face

.. autofunction:: find_font_file_name

.. autofunction:: find_best_match

.. autofunction:: get_entity_font_face

.. autofunction:: get_font_measurements

.. autofunction:: build_system_font_cache()

.. autofunction:: load

.. autofunction:: sideload_ttf

Classes
-------

.. autoclass:: AbstractFont

    .. attribute:: name

        The font filename e.g. "LiberationSans-Regular.ttf"

    .. attribute:: font_render_type

        The font type, see enum :class:`FontRenderType`

    .. attribute:: measurement

        The :class:`FontMeasurements` data.

    .. automethod:: text_width

    .. automethod:: text_width_ex

    .. automethod:: text_path

    .. automethod:: text_path_ex

    .. automethod:: space_width


.. autoclass:: MonospaceFont

.. autoclass:: TrueTypeFont

.. autoclass:: ShapeFileFont

.. autoclass:: LibreCadFont


.. _font_anatomy:

Font Anatomy
------------

- A Visual Guide to the Anatomy of Typography: https://visme.co/blog/type-anatomy/
- Anatomy of a Character: https://www.fonts.com/content/learning/fontology/level-1/type-anatomy/anatomy

.. _font_properties:

Font Properties
---------------

DXF to store fonts in the :class:`~ezdxf.entities.Textstyle` entity as TTF file name e.g.
"LiberationSans-Regular.ttf".

The :class:`FontFace` class can be used to specify a font in a more generic way:

family
    font name e.g. "Liberation Sans" or "Arial", may a generic font family name, either "serif",
    "sans-serif" or "monospace"

style
    "Regular", "Italic", "Oblique", "Bold", "BoldOblique", ...

width
    (usWidthClass) A numeric value in the range 0-9

    === ==================
    1   UltraCondensed
    2   ExtraCondensed
    3   Condensed
    4   SemiCondensed
    5   Normal or Medium
    6   SemiExpanded
    7   Expanded
    8   ExtraExpanded
    9   UltraExpanded
    === ==================

weight
    (usWeightClass) A numeric value in the range 0-1000

    === =============
    100 Thin
    200 ExtraLight
    300 Light
    400 Normal
    500 Medium
    600 SemiBold
    700 Bold
    800 ExtraBold
    900 Black
    === =============

.. seealso::

    - W3C: https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/

.. class:: FontRenderType

    Enumeration of font render type.

    .. attribute:: STROKE

        Basic stroke font, can only be rendered as linear paths.

    .. attribute:: OUTLINE

        TrueType or similar font, can be rendered as filled paths or as outline strokes.


.. autoclass:: FontFace

    .. attribute:: filename

        font file name without parent directories as string, e.g. "arial.ttf"

    .. attribute:: family

        Family name as string, the default value is "sans-serif"

    .. attribute:: style

        Font style as string, the default value is "Regular"

    .. attribute:: weight

        Font weight as int in the renge from 0-1000, the default value is 400 (Normal)

    .. autoproperty:: weight_str

    .. attribute:: width

        Font width (stretch) as int in the range from 1-9, the default value is 5 (Normal)

    .. autoproperty:: width_str

    .. autoproperty:: is_italic

    .. autoproperty:: is_oblique

    .. autoproperty:: is_bold


.. class:: FontMeasurements

    See `Font Anatomy`_ for more information.

    .. attribute:: baseline

    .. attribute:: cap_height

    .. attribute:: x_height

    .. attribute:: descender_height

    .. automethod:: scale

    .. automethod:: scale_from_baseline

    .. automethod:: shift

    .. autoproperty:: cap_top

    .. autoproperty:: x_top

    .. autoproperty:: bottom

    .. autoproperty:: total_height


.. _ezdxf/fonts: https://github.com/mozman/ezdxf/tree/master/fonts
.. _fontTools: https://pypi.org/project/fonttools/

--- End of file: tools/fonts.rst ---



--- Start of file: tools/gfxattribs.rst ---

GfxAttribs
==========

.. module:: ezdxf.gfxattribs

The :mod:`ezdxf.gfxattribs` module provides the :class:`GfxAttribs` class to
create valid attribute dictionaries for the most often used DXF attributes
supported by all graphical DXF entities. The advantage of using this class
is auto-completion support by IDEs and an instant validation of the attribute
values.

.. code-block:: Python

    import ezdxf
    from ezdxf.gfxattribs import GfxAttribs

    doc = ezdxf.new()
    msp = doc.modelspace()

    attribs = GfxAttribs(layer="MyLayer", color=ezdxf.colors.RED)
    line = msp.add_line((0, 0), (1, 0), dxfattribs=attribs)
    circle = msp.add_circle((0, 0), radius=1.0, dxfattribs=attribs)

    # Update DXF attributes of existing entities:
    attribs = GfxAttribs(layer="MyLayer2", color=ezdxf.colors.BLUE)

    # Convert GfxAttribs() to dict(), but this method cannot reset
    # attributes to the default values like setting layer to "0".
    line.update_dxf_attribs(dict(attribs))

    # Using GfxAttribs.asdict(default_values=True), can reset attributes to the
    # default values like setting layer to "0", except for true_color and
    # transparency, which do not have default values, their absence is the
    # default value.
    circle.update_dxf_attribs(attribs.asdict(default_values=True))

    # Remove true_color and transparency by assigning None
    attribs.transparency = None  # reset to transparency by layer!
    attribs.rgb = None


Validation features:

- **layer** - string which can not contain certain characters: ``<>/\":;?*=```
- **color** - :ref:`ACI` value as integer in the range from 0 to 257
- **rgb** - true color value as (red, green, blue) tuple, all channel values as
  integer values in the range from 0 to 255
- **linetype** - string which can not contain certain characters: ``<>/\":;?*=```,
  does not check if the linetype exists
- **lineweight** - integer value in the range from 0 to 211, see :ref:`lineweights`
  for valid values
- **transparency** - float value in the range from 0.0 to 1.0 and -1.0 for transparency by block
- **ltscale** - float value > 0.0


.. autoclass:: GfxAttribs

    .. autoproperty:: layer

    .. autoproperty:: color

    .. autoproperty:: rgb

    .. autoproperty:: linetype

    .. autoproperty:: lineweight

    .. autoproperty:: transparency

    .. autoproperty:: ltscale

    .. automethod:: __str__

    .. automethod:: __repr__

    .. automethod:: __iter__

    .. automethod:: asdict

    .. automethod:: items

    .. automethod:: load_from_header

    .. automethod:: write_to_header

    .. automethod:: from_entity

    .. automethod:: from_dict



--- End of file: tools/gfxattribs.rst ---



--- Start of file: tools/query.rst ---

.. reference - usage is documented in tasks - "Query data"

.. module:: ezdxf.query

Query Module
============

.. seealso::

    - :ref:`tut_getting_data`
    - Usage of extended query features: :ref:`query entities`

The new() Function
++++++++++++++++++

.. autofunction:: ezdxf.query.new

.. _entity query string:

Entity Query String
-------------------

.. code-block::

    QueryString := EntityQuery ("[" AttribQuery "]" "i"?)*

The query string is the combination of two queries, first the required entity query and 
second the optional attribute query, enclosed in square brackets, append ``'i'`` after 
the closing square bracket to ignore case for strings.

Entity Query
++++++++++++

The entity query is a whitespace separated list of DXF entity names or the special name 
``'*'``. Where ``'*'`` means all DXF entities, exclude some entity types by appending 
their names with a preceding ``!`` (e.g. all entities except LINE = ``'* !LINE'``). 
All DXF names have to be uppercase.

Attribute Query
+++++++++++++++

The *optional* attribute query is a boolean expression, supported operators are:

  - not (!): !term is true, if term is false
  - and (&): term & term is true, if both terms are true
  - or (|): term | term is true, if one term is true
  - and arbitrary nested round brackets
  - append (i) after the closing square bracket to ignore case for strings

Attribute selection is a term: "name comparator value", where name is a DXF
entity attribute in lowercase, value is a integer, float or double quoted string,
valid comparators are:

  - ``==`` equal "value"
  - ``!=`` not equal "value"
  - ``<`` lower than "value"
  - ``<=`` lower or equal than "value"
  - ``>`` greater than "value"
  - ``>=`` greater or equal than "value"
  - ``?`` match regular expression "value"
  - ``!?`` does not match regular expression "value"


EntityQuery Class
-----------------

.. class:: EntityQuery

    The :class:`EntityQuery` class is a result container, which is filled with DXF 
    entities matching the query string. It is possible to add entities to the container 
    (extend), remove entities from the container and to filter the container. 
    Supports the standard Python Sequence methods and protocols.  
    Does not remove automatically destroyed entities (entities deleted by calling method 
    :meth:`destroy`), the method :meth:`purge` has to be called explicitly to remove the 
    destroyed entities.

    .. autoattribute:: first

    .. autoattribute:: last

    .. automethod:: __len__

    .. automethod:: __getitem__

    .. automethod:: __setitem__

    .. automethod:: __delitem__

    .. automethod:: __eq__

    .. automethod:: __ne__

    .. automethod:: __lt__

    .. automethod:: __le__

    .. automethod:: __gt__

    .. automethod:: __ge__

    .. automethod:: match

    .. automethod:: __or__

    .. automethod:: __and__

    .. automethod:: __sub__

    .. automethod:: __xor__

    .. automethod:: __iter__

    .. automethod:: purge

    .. automethod:: extend

    .. automethod:: remove

    .. automethod:: query

    .. automethod:: groupby

    .. automethod:: filter

    .. automethod:: union

    .. automethod:: intersection

    .. automethod:: difference

    .. automethod:: symmetric_difference





--- End of file: tools/query.rst ---



--- Start of file: tools/revcloud.rst ---

.. module:: ezdxf.revcloud

Revision Cloud
==============

The module :mod:`ezdxf.revcloud` provides functions to render revision clouds 
similar to the REVCLOUD command in CAD applications.

.. versionadded:: 1.3.0

..  autofunction:: points

..  autofunction:: add_entity

..  autofunction:: is_revcloud


Usage:

.. code-block::


    import ezdxf
    from ezdxf.render import revcloud

    doc = ezdxf.new()
    msp = doc.modelspace()
    revcloud.add_entity(msp, [(0, 0), (1, 0), (1, 1), (0, 1)], segment_length=0.1)
    doc.saveas("revcloud.dxf")

.. figure:: gfx/revcloud.png



--- End of file: tools/revcloud.rst ---



--- Start of file: tools/text.rst ---

.. _Text Tools:

Text Tools
==========

.. module:: ezdxf.tools.text

MTextEditor
-----------

.. autoclass:: MTextEditor

    .. attribute:: text

        The MTEXT content as a simple string.

    .. automethod:: append

    .. automethod:: __iadd__

    .. automethod:: __str__

    .. automethod:: clear

    .. automethod:: font

    .. automethod:: height

    .. automethod:: scale_height

    .. automethod:: width_factor

    .. automethod:: char_tracking_factor

    .. automethod:: oblique

    .. automethod:: color

    .. automethod:: aci

    .. automethod:: rgb

    .. automethod:: underline

    .. automethod:: overline

    .. automethod:: strike_through

    .. automethod:: group

    .. automethod:: stack

    .. automethod:: paragraph

    .. automethod:: bullet_list

Constants stored in the :class:`MTextEditor` class:

=================== ==========
NEW_LINE            ``'\P'``
NEW_PARAGRAPH       ``'\P'``
NEW_COLUMN          ``'\N``
UNDERLINE_START     ``'\L'``
UNDERLINE_STOP      ``'\l'``
OVERSTRIKE_START    ``'\O'``
OVERSTRIKE_STOP     ``'\o'``
STRIKE_START        ``'\K'``
STRIKE_STOP         ``'\k'``
ALIGN_BOTTOM        ``'\A0;'``
ALIGN_MIDDLE        ``'\A1;'``
ALIGN_TOP           ``'\A2;'``
NBSP                ``'\~'``
TAB                 ``'^I'``
=================== ==========

.. autoclass:: ParagraphProperties(indent=0, left=0, right=0, align=DEFAULT, tab_stops=[])

    .. automethod:: tostring


.. class:: ezdxf.lldxf.const.MTextParagraphAlignment

    .. attribute:: DEFAULT

    .. attribute:: LEFT

    .. attribute:: RIGHT

    .. attribute:: CENTER

    .. attribute:: JUSTIFIED

    .. attribute:: DISTRIBUTED


Single Line Text
----------------

.. autoclass:: TextLine

    .. autoproperty:: width

    .. autoproperty:: height

    .. automethod:: stretch

    .. automethod:: font_measurements

    .. automethod:: baseline_vertices

    .. automethod:: corner_vertices

    .. automethod:: transform_2d

Functions
---------

.. autofunction:: caret_decode

.. autofunction:: estimate_mtext_content_extents

.. autofunction:: estimate_mtext_extents

.. autofunction:: fast_plain_mtext

.. autofunction:: is_text_vertical_stacked

.. autofunction:: is_upside_down_text_angle

.. autofunction:: leading

.. autofunction:: plain_mtext

.. autofunction:: plain_text

.. autofunction:: safe_string

.. autofunction:: text_wrap

.. autofunction:: upright_text_angle


--- End of file: tools/text.rst ---



--- Start of file: tools/text_size.rst ---

.. _Text Size Tools:

Text Size Tools
===============

.. module:: ezdxf.tools.text_size


.. class:: ezdxf.tools.text_size.TextSize

    A frozen dataclass as return type for the :func:`text_size` function.

    .. attribute:: width

        The text width in drawing units (float).

    .. attribute:: cap_height

        The font cap-height in drawing units (float).

    .. attribute:: total_height

        The font total-height = cap-height + descender-height in drawing units (float).

.. autofunction:: text_size


.. class:: ezdxf.tools.text_size.MTextSize

    A frozen dataclass as return type for the :func:`mtext_size` function.

    .. attribute:: total_width

        The total width in drawing units (float)

    .. attribute:: total_height

        The total height in drawing units (float), same as ``max(column_heights)``.

    .. attribute:: column_width

        The width of a single column in drawing units (float)

    .. attribute:: gutter_width

        The space between columns in drawing units (float)

    .. attribute:: column_heights

        A tuple of columns heights (float) in drawing units. Contains at least
        one column height and the column height is 0 for an empty column.

    .. attribute:: column_count

        The count of columns (int).

.. autofunction:: mtext_size

.. autofunction:: estimate_mtext_extents


--- End of file: tools/text_size.rst ---



--- Start of file: tools/xclip.rst ---

.. _xclip_module:

.. module:: ezdxf.xclip

XClip Module
============

.. versionadded:: 1.2

The :class:`XClip` class can set or remove the clipping path of external references or 
block references.

The clipping boundary determines the portion of an XREF or block instance that is hidden, 
either outside or inside the boundary (inside = inverted clipping path).  The visibility 
of the clipping boundary is controlled by the $XCLIPFRAME header variable.

The :class:`XClip` class supports only 2D clippings path and cannot create inverted 
clipping paths.

.. figure:: gfx/cropped-block-reference.png


There exist two coordinate systems for the clipping path polygon:

    - BLOCK coordinate system: the BLOCK coordinates are relative to the BLOCK origin
    - WCS coordinate system: the WCS coordinates are relative to the origin of the of 
      the coodintate system where the block reference (INSERT entity) is inserted

The :class:`XClip` class provides methods to set and get the 
clipping path for both variants and returns a :class:`ClippingPath` object.

The clipping polygon can be set visible/invisible when the header variable 
$XCLIPFRAME is not 0, otherwise the clipping polygon is always invisible.

Remove the clipping path by the :meth:`XClip.discard_clipping_path` method, does not 
raise an exception when no clipping path exist.

.. seealso::

    example script: `clipping_insert.py`_ in the ``/examples/blocks`` folder

.. autoclass:: XClip

    .. autoproperty:: has_clipping_path

    .. autoproperty:: is_clipping_enabled

    .. autoproperty:: is_inverted_clip

    .. automethod:: disable_clipping

    .. automethod:: enable_clipping

    .. automethod:: get_spatial_filter

    .. automethod:: get_xclip_frame_policy

    .. automethod:: get_block_clipping_path

    .. automethod:: get_wcs_clipping_path

    .. automethod:: set_block_clipping_path

    .. automethod:: set_wcs_clipping_path

    .. automethod:: discard_clipping_path


.. autoclass:: ClippingPath

.. _clipping_insert.py: https://github.com/mozman/ezdxf/blob/master/examples/blocks/clipping_insert.py

--- End of file: tools/xclip.rst ---



--- Start of file: tools/zoom.rst ---

Zoom Layouts
============

.. module:: ezdxf.zoom

These functions mimic the ZOOM commands in CAD applications.

Zooming means resetting the current viewport limits to new values.
The coordinates for the functions :func:`center` and :func:`window` are
drawing units for the model space and paper space units for paper space layouts.
The modelspace units in :attr:`Drawing.units` are ignored.

The extents detection for the functions :func:`entities` and :func:`extents`
is done by the :mod:`ezdxf.bbox` module. Read the associated documentation to
understand the limitations of the :mod:`ezdxf.bbox` module.
Tl;dr The extents detection is **slow** and **not accurate**.

Because the ZOOM operations in CAD applications are not that precise, then
zoom functions of this module uses the fast bounding box calculation mode
of the :mod:`bbox` module, which means the argument `flatten` is always
``False`` for :func:`~ezdxf.bbox.extents` function calls.

The region displayed by CAD applications also depends on the aspect ratio of
the application window, which is not available to `ezdxf`, therefore the
viewport size is just an educated guess of an aspect ratio of 2:1 (16:9 minus
top toolbars and the bottom status bar).

.. warning::

    All zoom functions replace the current viewport configuration by a single
    window configuration.

Example to reset the main CAD viewport of the model space to the extents of its
entities:

.. code-block:: Python

    import ezdxf
    from ezdxf import zoom

    doc = ezdxf.new()
    msp = doc.modelspace()
    ... # add your DXF entities

    zoom.extents(msp)
    doc.saveas("your.dxf")

.. autofunction:: center

.. autofunction:: objects

.. autofunction:: extents

.. autofunction:: window


--- End of file: tools/zoom.rst ---



--- Start of file: transform.rst ---

.. _transform:

.. module:: ezdxf.transform

Transform
=========

.. versionadded:: 1.1

This module provides functions to apply transformations to multiple DXF
entities inplace or to virtual copies of that entities in a convenient and safe way:

.. code-block:: Python

    import math

    import ezdxf
    from ezdxf import transform

    doc = ezdxf.readfile("my.dxf")
    msp = doc.modelspace()

    log = transform.inplace(msp, m=transform.Matrix44.rotate_z(math.pi/2))

    # or more simple
    log = transform.z_rotate(msp, math.pi/2)

All functions handle errors by collecting them in an logging object without raising
an error.
The input `entities` are an iterable of :class:`~ezdxf.entities.DXFEntity`, which can be
any layout, :class:`~ezdxf.query.EntityQuery` or just a list/sequence of entities and
virtual entities are supported as well.

.. autosummary::
    :nosignatures:

    inplace
    copies
    translate
    scale_uniform
    scale
    x_rotate
    y_rotate
    z_rotate
    axis_rotate

.. autofunction:: inplace

.. autofunction:: copies

.. autofunction:: translate

.. autofunction:: scale_uniform

.. autofunction:: scale

.. autofunction:: x_rotate

.. autofunction:: y_rotate

.. autofunction:: z_rotate

.. autofunction:: axis_rotate

.. attribute:: MIN_SCALING_FACTOR

    Minimal scaling factor: 1e-12

.. class:: Error

    .. attribute:: NONE

        No error, same as a boolean ``False``, this allows check :code:`if error: ...`

    .. attribute:: COPY_NOT_SUPPORTED

        Entity without copy support.

    .. attribute:: TRANSFORMATION_NOT_SUPPORTED

        Entity without transformation support.


    .. attribute:: NON_UNIFORM_SCALING_ERROR

        Circular arcs (CIRCLE, ARC, bulges in POLYLINE and LWPOLYLINE entities)
        cannot be scaled non-uniformly.

    .. attribute:: INSERT_TRANSFORMATION_ERROR

        INSERT entities cannot represent a non-orthogonal target coordinate system.
        Maybe exploding the INSERT entities (recursively) beforehand can solve this
        issue, see function :func:`ezdxf.disassemble.recursive_decompose`.

    .. attribute:: VIRTUAL_ENTITY_NOT_SUPPORTED

        Transformation not supported for virtual entities e.g. non-uniform scaling for
        CIRCLE, ARC or POLYLINE with bulges

.. autoclass:: Logger

    A :class:`Sequence` of errors as :class:`Logger.Entry` instances.

    .. class:: Entry

        Named tuple representing a logger entry.

        .. attribute:: error

            :class:`Error` enum

        .. attribute:: msg

            error message as string

        .. attribute:: entity

            DXF entity which causes the error

    .. automethod:: __len__

    .. automethod:: __getitem__

    .. automethod:: __iter__

    .. automethod:: messages


--- End of file: transform.rst ---



--- Start of file: tutorials/angular_dimension.rst ---


.. _tut_angular_dimension:

Tutorial for Angular Dimensions
===============================

Please read the :ref:`tut_linear_dimension` before, if you haven't.

.. note::

    `Ezdxf` does not consider all DIMSTYLE variables, so the
    rendering results are different from CAD applications.

.. _tut_angular_dim_style:

Dimension Style "EZ_CURVED"
---------------------------

All factory methods to create angular dimensions uses the dimension style
"EZ_CURVED" for curved dimension lines which is defined as:

- angle unit is decimal degrees, :attr:`dimaunit` = 0
- measurement text height = 0.25 (drawing scale = 1:100)
- measurement text location is above the dimension line
- closed filled arrow and arrow size :attr:`dimasz` = 0.25
- :attr:`dimazin` = 2, suppresses trailing zeros (e.g. 12.5000 becomes 12.5)

This DIMENSION style only exist if the argument `setup` is ``True`` for creating
a new DXF document by :meth:`ezdxf.new`.
Every dimension style which does not exist will be replaced by the dimension
style "Standard" at DXF export by :meth:`save` or :meth:`saveas`
(e.g. dimension style setup was not initiated).

Add all `ezdxf` specific resources (line types, text- and dimension styles)
to an existing DXF document:

.. code-block:: Python

    import ezdxf
    from ezdxf.tools.standards import setup_drawing

    doc = ezdxf.readfile("your.dxf")
    setup_drawing(doc, topics="all")

Factory Methods to Create Angular Dimensions
--------------------------------------------

Defined by Center, Radius and Angles
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first example shows an angular dimension defined by the center point, radius,
start- and end angles:

.. code-block:: Python

    import ezdxf

    # Create a DXF R2010 document:
    # Use argument setup=True to setup the default dimension styles.
    doc = ezdxf.new("R2010", setup=True)

    # Add new entities to the modelspace:
    msp = doc.modelspace()

    # Add an angular DIMENSION defined by the center point, start- and end angles,
    # the measurement text is placed at the default location above the dimension
    # line:
    dim = msp.add_angular_dim_cra(
        center=(5, 5),  # center point of the angle
        radius= 7,  # distance from center point to the start of the extension lines
        start_angle=60,  # start angle in degrees
        end_angle=120,  # end angle in degrees
        distance=3,  # distance from start of the extension lines to the dimension line
        dimstyle="EZ_CURVED",  # default angular dimension style
    )

    # Necessary second step to create the BLOCK entity with the dimension geometry.
    # Additional processing of the DIMENSION entity could happen between adding
    # the entity and the rendering call.
    dim.render()
    doc.saveas("angular_dimension_cra.dxf")

The return value `dim` is **not** a dimension entity, instead a
:class:`~ezdxf.entities.DimStyleOverride` object is
returned, the dimension entity is stored as :attr:`dim.dimension`.

.. image:: gfx/dim_angular_cra.png

Angle by 2 Lines
~~~~~~~~~~~~~~~~

The next example shows an angular dimension for an angle defined by two lines:

.. code-block:: Python

    import ezdxf

    doc = ezdxf.new(setup=True)
    msp = doc.modelspace()

    # Setup the geometric parameters for the DIMENSION entity:
    base = (5.8833, -6.3408)  # location of the dimension line
    p1 = (2.0101, -7.5156)  # start point of 1st leg
    p2 = (2.7865, -10.4133)  # end point of 1st leg
    p3 = (6.7054, -7.5156)  # start point of 2nd leg
    p4 = (5.9289, -10.4133)  # end point of 2nd leg

    # Draw the lines for visualization, not required to create the
    # DIMENSION entity:
    msp.add_line(p1, p2)
    msp.add_line(p3, p4)

    # Add an angular DIMENSION defined by two lines, the measurement text is
    # placed at the default location above the dimension line:
    dim = msp.add_angular_dim_2l(
        base=base,  # defines the location of the dimension line
        line1=(p1, p2),  # start leg of the angle
        line2=(p3, p4),  # end leg of the angle
        dimstyle="EZ_CURVED",  # default angular dimension style
    )

    # Necessary second step to create the dimension line geometry:
    dim.render()
    doc.saveas("angular_dimension_2l.dxf")

The example above creates an angular :class:`~ezdxf.entities.Dimension` entity
to measures the angle between two lines (`line1` and `line2`).

The `base` point defines the location of the dimension line (arc), any point on
the dimension line is valid. The points `p1` and `p2` define the first leg of
the angle, `p1` also defines the start point of the first extension line.
The points `p3` and `p4` define the second leg of the angle and point `p3` also
defines the start point of the second extension line.

The measurement of the DIMENSION entity is the angle enclosed by the first and
the second leg and where the dimension line passes the `base` point.

.. image:: gfx/dim_angular_2l.png

Angle by 3 Points
~~~~~~~~~~~~~~~~~

The next example shows an angular dimension defined by three points,
a center point and the two end points of the angle legs:

.. code-block:: Python

    import ezdxf

    doc = ezdxf.new(setup=True)
    msp = doc.modelspace()

    msp.add_angular_dim_3p(
        base=(0, 7),  # location of the dimension line
        center=(0, 0),  # center point
        p1=(-3, 5),  # end point of 1st leg = start angle
        p2=(3, 5),  # end point of 2nd leg = end angle
    ).render()

.. image:: gfx/dim_angular_3p.png

Angle from ConstructionArc
~~~~~~~~~~~~~~~~~~~~~~~~~~

The :class:`ezdxf.math.ConstructionArc` provides various class methods for
creating arcs and the construction tool can be created from an ARC entity.

Add an angular dimension to an ARC entity:

.. code-block:: Python

    import ezdxf

    doc = ezdxf.new(setup=True)
    msp = doc.modelspace()

    arc = msp.add_arc(
        center=(0, 0),
        radius=5,
        start_angle = 60,
        end_angle = 120,
    )
    msp.add_angular_dim_arc(
        arc.construction_tool(),
        distance=2,
    ).render()

.. image:: gfx/dim_angular_from_arc.png

Placing Measurement Text
------------------------

The default location of the measurement text depends on various
:class:`~ezdxf.entities.DimStyle` parameters and is applied if no user defined
text location is defined.

.. note::

    Not all possibles features of DIMSTYLE are supported by the `ezdxf` rendering
    procedure and especially for the angular dimension there are less features
    implemented than for the linear dimension because of the lack of good
    documentation.

.. seealso::

    - Graphical reference of many DIMVARS and some advanced information:
      :ref:`dimstyle_table_internals`
    - Source code file `standards.py`_ shows how to create your own DIMSTYLES.
    - The Script `dimension_angular.py`_ shows examples for angular dimensions.

.. _tut_angular_dim_default_text_location:

Default Text Locations
~~~~~~~~~~~~~~~~~~~~~~

The DIMSTYLE "EZ_CURVED" places the measurement text in the center of the angle
above the dimension line. The first examples above show the measurement text at
the default text location.

The text direction angle is always perpendicular to the line from the text center
to the center point of the angle unless this angle is manually overridden.

The **"vertical"** location of the measurement text relative to the dimension
line is defined by :attr:`~ezdxf.entities.DimStyle.dxf.dimtad`:

=== =====
0   Center, it is possible to adjust the vertical location by
    :attr:`~ezdxf.entities.DimStyle.dxf.dimtvp`
1   Above
2   Outside, handled like `Above` by `ezdxf`
3   JIS, handled like `Above` by `ezdxf`
4   Below
=== =====

.. code-block:: Python

    msp.add_angular_dim_cra(
        center=(3, 3),
        radius=3,
        distance=1,
        start_angle=60,
        end_angle=120,
        override={
            "dimtad": 1,  # 0=center; 1=above; 4=below;
        },
    ).render()

.. image:: gfx/dim_angular_dimtad.png

Arrows and measurement text are placed "outside" automatically if the available
space between the extension lines isn't sufficient.
This overrides the :attr:`dimtad` value by 1 ("above").
`Ezdxf` follows its own rules, ignores the :attr:`~ezdxf.entities.DimStyle.dxf.dimatfit`
attribute and works similar to :attr:`dimatfit` = 1, move arrows first, then text:

.. image:: gfx/dim_angular_outside.png

.. _tut_angular_dim_shift_default_text_location:

Shift Text From Default Location
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The method :meth:`shift_text` shifts the measurement text away from the default
location. The shifting direction is aligned to the text rotation of the default
measurement text.

.. code-block:: Python

    dim = msp.add_angular_dim_cra(
        center=(3, 3),
        radius=3,
        distance=1,
        start_angle=60,
        end_angle=120,
    )
    # shift text from default text location:
    dim.shift_text(0.5, 1.0)
    dim.render()

.. image:: gfx/dim_angular_shift_text.png

This is just a rendering effect, editing the dimension line in a CAD application
resets the text to the default location.

.. _tut_angular_dim_user_text_location:

User Defined Text Locations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Beside the default location it is always possible to override the text location
by a user defined location.

The coordinates of user locations are located in the rendering UCS and the
default rendering UCS is the :ref:`WCS`.

Absolute User Location
++++++++++++++++++++++

Absolute placing of the measurement text means relative to the origin of the
render UCS.
The user location is stored in the DIMENSION entity, which means editing the
dimension line in a CAD application does not alter the text location.
This location also determines the rotation of the measurement text.

.. code-block:: python

    dim = msp.add_angular_dim_cra(
        center=(3, 3),
        radius=3,
        distance=1,
        start_angle=60,
        end_angle=120,
        location=(5, 8),  # user defined measurement text location
    )
    dim.render()

.. image:: gfx/dim_angular_user_location_1.png

Relative User Location
++++++++++++++++++++++

Relative placing of the measurement text means relative to the middle of the
dimension line. This is only possible by calling the :meth:`set_location`
method, and the argument `relative` has to be ``True``.
The user location is stored in the DIMENSION entity, which means editing the
dimension line in a CAD application does not alter the text location.
This location also determines the rotation of the measurement text.

.. code-block:: python

    dim = msp.add_angular_dim_cra(
        center=(3, 3),
        radius=3,
        distance=1,
        start_angle=60,
        end_angle=120,
    )
    dim.set_location((1, 2), relative=True)
    dim.render()

.. image:: gfx/dim_angular_user_location_2.png

Adding a Leader
+++++++++++++++

The method :meth:`set_location` has the option to add a leader line to the
measurement text. This also aligns the text rotation to the render
UCS x-axis, this means in the default case the measurement text is horizontal.
The leader line can be "below" the text or start at the "left" or "right"
center of the text, this location is defined by the
:attr:`~ezdxf.entities.DimStyle.dxf.dimtad` attribute, 0 means "center" and
any value != 0 means "below".

.. code-block:: python

    for dimtad, x in [(0, 0), (4, 6)]:
        dim = msp.add_angular_dim_cra(
            center=(3 + x, 3),
            radius=3,
            distance=1,
            start_angle=60,
            end_angle=120,
            override={"dimtad": dimtad}  # "center" == 0; "below" != 0;
        )
        dim.set_location((1, 2), relative=True, leader=True)
        dim.render()

.. image:: gfx/dim_angular_user_location_3.png

Advanced version which calculates the relative text location:
The user location vector has a length 2 and the orientation is defined by
`center_angle` pointing away from the center of the angle.

.. code-block:: python

    import ezdxf
    from ezdxf.math import Vec3

    doc = ezdxf.new(setup=True)
    msp = doc.modelspace()
    for dimtad, y, leader in [
        [0, 0, False],
        [0, 7, True],
        [4, 14, True],
    ]:
        for x, center_angle in [
            (0, 0), (7, 45), (14, 90), (21, 135), (26, 225), (29, 270)
        ]:
            dim = msp.add_angular_dim_cra(
                center=(x, y),
                radius=3.0,
                distance=1.0,
                start_angle=center_angle - 15.0,
                end_angle=center_angle + 15.0,
                override={"dimtad": dimtad},
            )
            # The user location is relative to the center of the dimension line:
            usr_location = Vec3.from_deg_angle(angle=center_angle, length=2.0)
            dim.set_location(usr_location, leader=leader, relative=True)
            dim.render()


.. image:: gfx/dim_angular_user_location_4.png

.. _tut_angular_dim_overriding_text_rotation:

Overriding Text Rotation
------------------------

All factory methods supporting the argument `text_rotation` can override the
measurement text rotation.
The user defined rotation is relative to the render UCS x-axis (default is WCS).

This example uses a relative text location without a leader and forces the text
rotation to 90 degrees:

.. code-block:: python

    for x, center_angle in [(7, 45), (14, 90), (21, 135)]:
        dim = msp.add_angular_dim_cra(
            center=(x, 0),
            radius=3.0,
            distance=1.0,
            start_angle=center_angle - 15.0,
            end_angle=center_angle + 15.0,
            text_rotation=90,  # vertical text
        )
        usr_location = Vec3.from_deg_angle(angle=center_angle, length=1.0)
        dim.set_location(usr_location, leader=False, relative=True)
        dim.render()

.. image:: gfx/dim_angular_user_location_5.png

Angular Units
-------------

Angular units are set by :attr:`~ezdxf.entities.DimStyle.dxf.dimaunit`:

=== =====
0   Decimal degrees
1   Degrees/Minutes/Seconds, ``dimadec`` controls the shown precision

    - dimadec=0: 30
    - dimadec=2: 3035'
    - dimadec=4: 3035'25"
    - dimadec=7: 3035'25.15"

2   Grad
3   Radians
=== =====

.. code-block:: Python

    d1 = 15
    d2 = 15.59031944
    for x, (dimaunit, dimadec) in enumerate(
        [
            (0, 4),
            (1, 7),
            (2, 4),
            (3, 4),
        ]
    ):
        dim = msp.add_angular_dim_cra(
            center=(x * 4.0, 0.0),
            radius=3.0,
            distance=1.0,
            start_angle=90.0 - d1,
            end_angle=90.0 + d2,
            override={
                "dimaunit": dimaunit,
                "dimadec": dimadec,
            },
        )
        dim.render()

.. image:: gfx/dim_angular_dimaunit.png

.. image:: gfx/dim_angular_dms.png

Overriding Measurement Text
---------------------------

See Linear Dimension Tutorial: :ref:`tut_overriding_measurement_text`

Measurement Text Formatting and Styling
---------------------------------------

See Linear Dimension Tutorial: :ref:`tut_measurement_text_formatting_and_styling`

Tolerances and Limits
---------------------

See Linear Dimension Tutorial: :ref:`tut_tolerances_and_limits`


.. _dimension_angular.py:  https://github.com/mozman/ezdxf/blob/master/examples/render/dimension_angular.py
.. _standards.py: https://github.com/mozman/ezdxf/blob/master/src/ezdxf/tools/standards.py

--- End of file: tutorials/angular_dimension.rst ---



--- Start of file: tutorials/arc_dimension.rst ---

.. _tut_arc_dimension:


Tutorial for Arc Dimensions
===========================

Please read the :ref:`tut_linear_dimension` before, if you haven't. This is a
repetition of the :ref:`tut_angular_dimension`, because `ezdxf` reuses the
angular dimension to render arc dimensions. This approach is very different
to CAD applications, but also much less work.

.. note::

    `Ezdxf` does not render the arc dimension like CAD applications and does
    not consider all DIMSTYLE variables, so the rendering results are **very**
    different from CAD applications.

Dimension Style "EZ_CURVED"
---------------------------

All factory methods to create arc dimensions uses the dimension style
"EZ_CURVED" for curved dimension lines which is defined as:

- angle unit is decimal degrees, :attr:`dimaunit` = 0
- measurement text height = 0.25 (drawing scale = 1:100)
- measurement text location is above the dimension line
- closed filled arrow and arrow size :attr:`dimasz` = 0.25
- :attr:`dimzin` = 2, suppresses trailing zeros (e.g. 12.5000 becomes 12.5)
- :attr:`dimarcsym` = 2, disables the arc symbol, 0 renders only an open round
  bracket "(" in front of the text and 1 for arc symbol above the text is not
  supported, renders like disabled

For more information go to: :ref:`tut_angular_dim_style`

Factory Methods to Create Arc Dimensions
----------------------------------------

Defined by Center, Radius and Angles
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first example shows an arc dimension defined by the center point, radius,
start- and end angles:

.. code-block:: Python

    import ezdxf

    # Use argument setup=True to setup the default dimension styles.
    doc = ezdxf.new(setup=True)

    # Add new entities to the modelspace:
    msp = doc.modelspace()

    # Add an arc DIMENSION defined by the center point, start- and end angles,
    # the measurement text is placed at the default location above the dimension
    # line:
    dim = msp.add_arc_dim_cra(
        center=(5, 5),  # center point of the angle
        radius=5,  # distance from center point to the start of the extension lines
        start_angle=60,  # start angle in degrees
        end_angle=120,  # end angle in degrees
        distance=2,  # distance from start of the extension lines to the dimension line
        dimstyle="EZ_CURVED",  # default angular dimension style
    )

    # Necessary second step to create the BLOCK entity with the dimension geometry.
    # Additional processing of the DIMENSION entity could happen between adding
    # the entity and the rendering call.
    dim.render()
    doc.saveas("arc_dimension_cra.dxf")

The return value `dim` is **not** a dimension entity, instead a
:class:`~ezdxf.entities.DimStyleOverride` object is
returned, the dimension entity is stored as :attr:`dim.dimension`.

.. image:: gfx/dim_arc_cra.png

Arc by 3 Points
~~~~~~~~~~~~~~~

The next example shows an angular dimension defined by three points,
a center point and the two end points of the angle legs, the first point
defines the radius, the second point defines only the end angle, the distance
from the center point is not relevant:

.. code-block:: Python

    import ezdxf

    doc = ezdxf.new(setup=True)
    msp = doc.modelspace()

    msp.add_arc_dim_3p(
        base=(0, 7),  # location of the dimension line
        center=(0, 0),  # center point
        p1=(2.5, 4.330127018922193),  # 1st point of arc defines start angle and radius
        p2=(-2.5, 4.330127018922194),  # 2nd point defines the end angle
    ).render()

.. image:: gfx/dim_arc_3p.png

Angle from ConstructionArc
~~~~~~~~~~~~~~~~~~~~~~~~~~

The :class:`ezdxf.math.ConstructionArc` provides various class methods for
creating arcs and the construction tool can be created from an ARC entity.

Add an angular dimension to an ARC entity:

.. code-block:: Python

    import ezdxf

    doc = ezdxf.new(setup=True)
    msp = doc.modelspace()

    arc = msp.add_arc(
        center=(0, 0),
        radius=5,
        start_angle = 60,
        end_angle = 120,
    )
    msp.add_arc_dim_arc(
        arc.construction_tool(),
        distance=2,
    ).render()


Placing Measurement Text
------------------------

The default location of the measurement text depends on various
:class:`~ezdxf.entities.DimStyle` parameters and is applied if no user defined
text location is defined.

.. note::

    Not all possibles features of DIMSTYLE are supported by the `ezdxf` rendering
    procedure and especially for the arc dimension there are less features
    implemented than for the linear dimension because of the lack of good
    documentation. If the arc symbol is enabled (:attr:`dimarcsym` = 0) only an
    open round bracket "(" is rendered in front  of the measurement text!

.. seealso::

    - Graphical reference of many DIMVARS and some advanced information:
      :ref:`dimstyle_table_internals`
    - Source code file `standards.py`_ shows how to create your own DIMSTYLES.
    - The Script `dimension_arc.py`_ shows examples for angular dimensions.

Default Text Locations
~~~~~~~~~~~~~~~~~~~~~~

The DIMSTYLE "EZ_CURVED" places the measurement text in the center of the angle
above the dimension line. The first examples above show the measurement text at
the default text location.

The text direction angle is always perpendicular to the line from the text center
to the center point of the angle unless this angle is manually overridden.

Arrows and measurement text are placed "outside" automatically if the available
space between the extension lines isn't sufficient.

For more information go to: :ref:`tut_angular_dim_default_text_location`

Shift Text From Default Location
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The method :meth:`shift_text` shifts the measurement text away from the default
location. The shifting direction is aligned to the text rotation of the default
measurement text.

For more information go to: :ref:`tut_angular_dim_shift_default_text_location`

User Defined Text Locations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Beside the default location it is always possible to override the text location
by a user defined location.

The coordinates of user locations are located in the rendering UCS and the
default rendering UCS is the :ref:`WCS`.

For more information go to: :ref:`tut_angular_dim_user_text_location`

Absolute User Location
++++++++++++++++++++++

Absolute placing of the measurement text means relative to the origin of the
render UCS.

For more information go to: :ref:`tut_angular_dim_user_text_location`

Relative User Location
++++++++++++++++++++++

Relative placing of the measurement text means relative to the middle of the
dimension line.

For more information go to: :ref:`tut_angular_dim_user_text_location`

Adding a Leader
+++++++++++++++

Add a leader line to the measurement text and set the text rotation to
"horizontal".

For more information go to: :ref:`tut_angular_dim_user_text_location`

Overriding Text Rotation
------------------------

All factory methods supporting the argument `text_rotation` can override the
measurement text rotation.
The user defined rotation is relative to the render UCS x-axis (default is WCS).

For more information go to: :ref:`tut_angular_dim_user_text_location`

Overriding Measurement Text
---------------------------

See Linear Dimension Tutorial: :ref:`tut_angular_dim_overriding_text_rotation`

Measurement Text Formatting and Styling
---------------------------------------

See Linear Dimension Tutorial: :ref:`tut_measurement_text_formatting_and_styling`

Tolerances and Limits
---------------------

See Linear Dimension Tutorial: :ref:`tut_tolerances_and_limits`


.. _dimension_arc.py:  https://github.com/mozman/ezdxf/blob/master/examples/render/dimension_arc.py
.. _standards.py: https://github.com/mozman/ezdxf/blob/master/src/ezdxf/tools/standards.py

--- End of file: tutorials/arc_dimension.rst ---



--- Start of file: tutorials/blocks.rst ---

.. _tut_blocks:

Tutorial for Blocks
===================

If you are not familiar with the concept of blocks, please read this first:
Concept of :ref:`block_concept`

Create a Block
--------------

Blocks are managed as :class:`~ezdxf.layouts.BlockLayout` objects by the
:class:`~ezdxf.sections.blocks.BlocksSection` object, every drawing has only
one blocks section referenced by attribute :attr:`Drawing.blocks`.

.. literalinclude:: src/blocks.py
    :lines: 1-21

Block References (Insert)
-------------------------

A block reference can be created by adding an :class:`~ezdxf.entities.Insert`
entity to any of these layout types:

  - :class:`~ezdxf.layouts.Modelspace`
  - :class:`~ezdxf.layouts.Paperspace`
  - :class:`~ezdxf.layouts.BlockLayout`

A block reference can be scaled and rotated individually.
Lets add some random flags to the modelspace:

.. literalinclude:: src/blocks.py
    :lines: 23-40

Query all block references of block ``FLAG``:

.. code-block:: python

    for flag_ref in msp.query('INSERT[name=="FLAG"]'):
        print(str(flag_ref))

When adding a block reference to a layout with different units, the scaling
factor between these units should be applied as scaling attributes
(:attr:`xscale`, ...) e.g. modelspace in meters and block in centimeters,
:attr:`xscale` has to be 0.01.

Block Attributes
----------------

A block attribute (:class:`~ezdxf.entities.Attrib`) is a text annotation
attached to a block reference with an associated tag.
Attributes are often used to add information to blocks which can be evaluated
and exported by CAD applications.
An attribute can be added to a block reference by the :meth:`Insert.add_attrib`
method, the ATTRIB entity is geometrically not related to the block reference,
so insertion point, rotation and scaling of the attribute have to be calculated
by the user, but helper tools for that do exist.

Using Attribute Definitions
---------------------------

Another way to add attributes to block references is using attribute templates
(:class:`~ezdxf.entities.AttDef`). First create the attribute definition in the
block definition, then add the block reference by :meth:`add_blockref`
and attach and fill attributes automatically by the :meth:`~ezdxf.entities.Insert.add_auto_attribs`
method to the block reference. This method has the advantage that all attributes
are placed relative to the block base point with the same rotation and scaling
as the block reference, but non-uniform scaling is not handled very well.

The :meth:`~ezdxf.layouts.BaseLayout.add_auto_blockref` method handles
non-uniform scaling better by wrapping the block reference and its attributes
into an anonymous block and let the CAD application do the transformation work.
This method has the disadvantage of a more complex evaluation of attached
attributes

Using attribute definitions (:class:`~ezdxf.entities.AttDef` templates):

.. literalinclude:: src/blocks.py
    :lines: 42-68

Get/Set Attributes of Existing Block References
-----------------------------------------------

See the howto: :ref:`howto_get_attribs`

Evaluate Wrapped Block References
---------------------------------

As mentioned above the evaluation of block references wrapped into anonymous
blocks is complex:

.. code-block:: python

    # Collect all anonymous block references starting with '*U'
    anonymous_block_refs = modelspace.query('INSERT[name ? "^\*U.+"]')

    # Collect the references of the 'FLAG' block
    flag_refs = []
    for block_ref in anonymous_block_refs:
        # Get the block layout of the anonymous block
        block = doc.blocks.get(block_ref.dxf.name)
        # Find all block references to 'FLAG' in the anonymous block
        flag_refs.extend(block.query('INSERT[name=="FLAG"]'))

    # Evaluation example: collect all flag names.
    flag_numbers = [
        flag.get_attrib_text("NAME")
        for flag in flag_refs
        if flag.has_attrib("NAME")
    ]

    print(flag_numbers)


Exploding Block References
--------------------------

This is an advanced feature and the results may not be perfect.
A **non-uniform scaling** lead to incorrect results for text entities (TEXT,
MTEXT, ATTRIB) and some other entities like HATCH with circular- or elliptic
path segments.  The "exploded" entities are added to the same layout as the
block reference by default.


.. code-block:: Python

    for flag_ref in msp.query('INSERT[name=="FLAG"]'):
        flag_ref.explode()

Examine Entities of Block References
------------------------------------

To just examine the content entities of a block reference use the
:meth:`~ezdxf.entities.Insert.virtual_entities` method.
This methods yields "virtual" entities with properties identical to "exploded"
entities but they are not stored in the entity database, have no handle and are
not assigned to any layout.

.. code-block:: Python

    for flag_ref in msp.query('INSERT[name=="FLAG"]'):
        for entity in flag_ref.virtual_entities():
            if entity.dxftype() == "LWPOLYLINE":
                print(f"Found {str(entity)}.")



--- End of file: tutorials/blocks.rst ---



--- Start of file: tutorials/common_graphical_attributes.rst ---

.. _tut_common_graphical_attributes:

Tutorial for Common Graphical Attributes
========================================

The graphical attributes :attr:`color`, :attr:`linetype`, :attr:`lineweight`,
:attr:`true_color`, :attr:`transparency`, :attr:`ltscale` and :attr:`invisible`
are available for all graphical DXF entities and are located in the DXF
namespace attribute :attr:`dxf` of the DXF entities.
All these attributes are optional and all except for :attr:`true_color` and
:attr:`transparency` have a default value.

Not all of these attributes are supported by all DXF versions. This table
shows the minimum required DXF version for each attribute:

======= =======================================================
R12     :attr:`color`, :attr:`linetype`
R2000   :attr:`lineweight`, :attr:`ltscale`, :attr:`invisible`
R2004   :attr:`true_color`, :attr:`transparency`
======= =======================================================

Color
-----

Please read the section about the :ref:`aci` to understand the basics.

The usage of the :attr:`~ezdxf.entities.DXFGraphic.dxf.color` attribute is very
straight forward. Setting the value is::

    entity.dxf.color = 1

and getting the value looks like this::

    value = entity.dxf.color

The :attr:`color` attribute has a default value of 256, which means take the
color defined by the layer associated to the entity. The :mod:`ezdxf.colors`
module defines some constants for often used color values::

    entity.dxf.color = ezdxf.colors.RED

The :func:`ezdxf.colors.aci2rgb` function converts the ACI value to the RGB value
of the default modelspace palette.

.. seealso::

    - Basics about :ref:`aci`
    - :mod:`ezdxf.colors` module

True Color
----------

Please read the section about :ref:`true color` to understand the basics.

The easiest way is to use the :attr:`rgb` property to set and get the true color
values as RGB tuples::

    entity.rgb = (255, 128, 16)

The :attr:`rgb` property return ``None`` if the :attr:`true_color` attribute is
not present::

    rgb = entity.rgb
    if rgb is not None:
        r, g, b = rgb

Setting and getting the :attr:`true_color` DXF attribute directly is possible
and the :mod:`ezdxf.colors` module has helper function to convert RGB tuples to
24-bit value and back::

    entity.dxf.true_color = ezdxf.colors.rgb2int(255, 128, 16)

The :attr:`true_color` attribute is optional does not have a default value and
therefore it is not safe to use the attribute directly, check if the attribute
exists beforehand::

    if entity.dxf.hasattr("true_color"):
        r, g, b = ezdxf.colors.int2rgb(entity.dxf.true_color)

or use the :meth:`get` method of the :attr:`dxf` namespace attribute to get a
default value if the attribute does not exist::

    r, g, b = ezdxf.colors.int2rgb(entity.dxf.get("true_color", 0)

.. seealso::

    - Basics about :ref:`true color`
    - :mod:`ezdxf.colors` module

Transparency
------------

Please read the section about :ref:`transparency` to understand the basics.

It's recommended to use the :attr:`~ezdxf.entities.DXFGraphic.transparency`
property of the :class:`~ezdxf.entities.DXFGraphic` base class.
The :attr:`transparency` property is a float value in the range from 0.0 to
1.0 where 0.0 is opaque and 1.0 if fully transparent::

    entity.transparency = 0.5

or set the values of the DXF attribute by constants defined in the
:mod:`ezdxf.colors` module::

    entity.dxf.transparency = ezdxf.colors.TRANSPARENCY_50

The default setting for :attr:`transparency` in CAD applications is always
transparency by layer, but the :attr:`transparency` property in `ezdxf`
has a default value of 0.0 (opaque), so there are additional entity properties to
check if the transparency value should be taken from the associated entity layer
or from the parent block::

    if entity.is_transparency_by_layer:
        ...
    elif entity.is_transparency_by_block:
        ...
    else:
        ...

The top level entity attribute :attr:`transparency` does not support setting
transparency by layer or block::

    from ezdxf import colors

    ...

    # set transparency by layer by removing the DXF attribute "transparency":
    entity.dxf.discard("transparency")

    # set transparency by block:
    entity.dxf.transparency = colors.TRANSPARENCY_BYBLOCK

    # there are also some handy constants in the colors module:
    # TRANSPARENCY_10 upto TRANSPARENCY_90 in steps of 10
    entity.dxf.transparency = colors.TRANSPARENCY_30  # set 30% transparency
    entity.dxf.transparency = colors.OPAQUE

.. seealso::

    - Basics about :ref:`transparency`
    - :mod:`ezdxf.colors` module

Linetype
--------

Please read the section about :ref:`linetypes` to understand the basics.

The :attr:`linetype` attribute contains the name of the linetype as string and
can be set by the :attr:`dxf` namespace attribute directly::

    entity.dxf.linetype = "DASHED"  # linetype DASHED must exist!

The :attr:`linetype` attribute is optional and has a default value of "BYLAYER",
so the attribute can always be used without any concerns::

    name = entity.dxf.linetype

.. warning::

    Make sure the linetype you assign to an entity is really defined in the
    linetype table otherwise AutoCAD will not open the DXF file. There are no
    implicit checks for that by `ezdxf` but you can call the
    :meth:`~ezdxf.document.Drawing.audit` method of the DXF document explicitly
    to validate the document before exporting.

`Ezdxf` creates new DXF documents with as little content as possible, this means
only the resources that are absolutely necessary are created.
The :func:`ezdxf.new` function can create some standard linetypes by setting the
argument `setup` to ``True``::

    doc = ezdxf.new("R2010", setup=True)

.. seealso::

    - Basics about :ref:`linetypes`
    - :ref:`tut_linetypes`

Lineweight
----------

Please read the section about :ref:`lineweights` to understand the basics.

The :attr:`lineweight` attribute contains the lineweight as an integer value
and can be set by the :attr:`dxf` namespace attribute directly::

    entity.dxf.lineweight = 25

The :attr:`lineweight` value is the line width in millimeters times 100 e.g.
0.25mm = 25, but only certain values are valid for more information
go to section: :ref:`lineweights`.

Values < 0 have a special meaning and can be imported as constants from
:mod:`ezdxf.lldxf.const`

=== ==================
-1  LINEWEIGHT_BYLAYER
-2  LINEWEIGHT_BYBLOCK
-3  LINEWEIGHT_DEFAULT
=== ==================

The :attr:`lineweight` attribute is optional and has a default value of -1, so
the attribute can always be used without any concerns::

    lineweight = entity.dxf.lineweight

.. important::

    You have to enable the option to show lineweights in your CAD application or
    viewer to see the effect on screen, which is disabled by default, the same
    has to be done in the page setup options for plotting lineweights.

.. code-block:: Python

    # activate on screen lineweight display
    doc.header["$LWDISPLAY"] = 1

.. seealso::

    - Basics about :ref:`lineweights`

Linetype Scale
--------------

The :attr:`ltscale` attribute scales the linetype pattern by a float value and
can be set by the :attr:`dxf` namespace attribute directly::

    entity.dxf.ltscale = 2.0

The :attr:`ltscale` attribute is optional and has a default value of 1.0, so
the attribute can always be used without any concerns::

    scale = entity.dxf.ltscale

.. seealso::

    - Basics about :ref:`linetypes`

Invisible
---------

The :attr:`invisible` attribute an boolean value (0/1) which defines if an
entity is invisible or visible and can be set by the :attr:`dxf` namespace
attribute directly::

    entity.dxf.invisible = 1

The :attr:`invisible` attribute is optional and has a default value of 0, so
the attribute can always be used without any concerns::

    is_invisible = bool(entity.dxf.invisible)


GfxAttribs
----------

When adding new entities to an entity space like the modelspace or a block definition,
the factory methods expect the graphical DXF attributes by the argument
`dxfattribs`. This object can be a Python :class:`dict` where the key is the DXF
attribute name and the value is the attribute value, or better use the
:class:`~ezdxf.gfxattribs.GfxAttribs` object which has some additional
validation checks and support for code completions by IDEs:


.. code-block:: Python

    import ezdxf
    from ezdxf.gfxattribs import GfxAttribs

    doc = ezdxf.new()
    msp = doc.modelspace()

    line = msp.add_line(
        (0, 0), (10, 10), dxfattribs=GfxAttribs(layer="0", rgb=(25, 128, 16))
    )

.. seealso::

    - :mod:`ezdxf.gfxattribs` module


--- End of file: tutorials/common_graphical_attributes.rst ---



--- Start of file: tutorials/custom_data.rst ---

.. _tut_custom_data:

Storing Custom Data in DXF Files
================================

This tutorial describes how to store custom data in DXF files using
standard DXF features.

Saving data in comments is not covered in this section, because comments are not
a reliable way to store information in DXF files and `ezdxf` does not support
adding comments to DXF files. Comments are also ignored by `ezdxf` and many
other DXF libraries when loading DXF files, but there is a :mod:`ezdxf.comments`
module to load comments from DXF files.

The DXF data format is a very versatile and flexible data format and supports
various ways to store custom data. This starts by setting special header variables,
storing XData, AppData and extension dictionaries in DXF entities and objects,
storing XRecords in the OBJECTS section and ends by using proxy entities or
even extending the DXF format by user defined entities and objects.

This is the common prolog for all Python code examples shown in this tutorial:

.. code-block:: Python

    import ezdxf

    doc = ezdxf.new()
    msp = doc.modelspace()

Retrieving User Data
--------------------

Retrieving the custom data is a simple task by `ezdxf`, but often not possible in CAD
applications without using the scripting features (AutoLISP) or even the SDK.

AutoLISP Resources
++++++++++++++++++

- `Autodesk Developer Documentation <http://help.autodesk.com/view/OARX/2018/ENU/>`_
- `AfraLISP`_
- `Lee Mac Programming <http://www.lee-mac.com>`_

.. warning::

    I have no experience with AutoLISP so far and I created this scripts for
    AutoLISP while writing this tutorial. There may be better ways to accomplish
    these tasks, and feedback on this is very welcome.
    Everything is tested with BricsCAD and should also work with the
    full version of AutoCAD.

Header Section
--------------

The HEADER section has tow ways to store custom data.

Predefined User Variables
+++++++++++++++++++++++++

There are ten predefined user variables, five 16-bit integer variables called
``$USERI1`` up to ``$USERI5`` and five floating point variables (reals) called
``$USERR1`` up to ``$USERR5``.
This is very limited and the data maybe will be overwritten by the next
application which opens and saves the DXF file. Advantage of this methods is,
it works for all supported DXF versions starting at R12.

Settings the data:

.. literalinclude:: src/customdata/header.py
    :lines: 10-11

Getting the data by `ezdxf`:

.. literalinclude:: src/customdata/header.py
    :lines: 14-15

Getting the data in `BricsCAD` at the command line::

    : USERI1
    New current value for USERI1 (-32768 to 32767) <4711>:

Getting the data by AutoLISP::

    : (getvar 'USERI1)
    4711

Setting the value by AutoLISP::

    : (setvar 'USERI1 1234)
    1234

Custom Document Properties
++++++++++++++++++++++++++

This method defines custom document properties, but requires at least DXF R2004.
The custom document properties are stored in a :class:`~ezdxf.sections.header.CustomVars`
instance in the :attr:`~ezdxf.sections.header.HeaderSection.custom_vars` attribute of
the :class:`~ezdxf.sections.header.HeaderSection` object and supports only
string values.

Settings the data:

.. literalinclude:: src/customdata/header.py
    :lines: 18

Getting the data by `ezdxf`:

.. literalinclude:: src/customdata/header.py
    :lines: 21

The document property ``MyFirstVar`` is available in `BricsCAD` as FIELD
variable:

.. image:: gfx/custom_header_property.png

AutoLISP script for getting the custom document properties:

.. code-block:: Lisp

    (defun C:CUSTOMDOCPROPS (/ Info Num Index Custom)
      (vl-load-com)
      (setq acadObject (vlax-get-acad-object))
      (setq acadDocument (vla-get-ActiveDocument acadObject))

      ;;Get the SummaryInfo
      (setq Info (vlax-get-Property acadDocument 'SummaryInfo))
      (setq Num (vla-NumCustomInfo Info))
      (setq Index 0)
      (repeat Num
        (vla-getCustomByIndex Info Index 'ID 'Value)
        (setq Custom (cons (cons ID Value) Custom))
        (setq Index (1+ Index))
      )  ;repeat

      (if Custom (reverse Custom))
    )

Running the script in BricsCAD:

.. code-block:: Text

    : (load "customdocprops.lsp")
    C:CUSTOMDOCPROPS
    : CUSTOMDOCPROPS
    (("MyFirstVar" . "First Value"))

Meta Data
---------

Starting with version v0.16.4 `ezdxf` stores some meta data in the DXF file and
the AppID ``EZDXF`` will be created.
Two entries will be added to the :class:`~ezdxf.document.MetaData`
instance, the ``CREATED_BY_EZDXF`` for DXF documents created by `ezdxf` and the
entry ``WRITTEN_BY_EZDXF`` if the DXF document will be saved by `ezdxf`.
The marker string looks like this ``"0.17b0 @ 2021-09-18T05:14:37.921826+00:00"``
and contains the `ezdxf` version and an UTC timestamp in ISO format.

You can add your own data to the :class:`~ezdxf.document.MetaData`
instance as a string with a maximum of 254 characters and choose a good name
which may never be used by `ezdxf` in the future.

.. code-block:: Python

    metadata = doc.ezdxf_metadata()
    metadata["MY_UNIQUE_KEY"] = "my additional meta data"

    print(metadata.get("CREATED_BY_EZDXF"))
    print(metadata.get("MY_UNIQUE_KEY"))


The data is stored as XDATA in then BLOCK entity of the model space for DXF R12
and for DXF R2000 and later as a DXF :class:`~ezdxf.entities.Dictionary`
in the root dictionary by the key ``EZDXF_META``.
See following chapters for accessing such data by AutoLISP.

XDATA
-----

:ref:`extended_data` is a way to attach arbitrary data to DXF entities.
Each application needs a unique AppID registered in the AppID table to add
XDATA to an entity. The AppID ``ACAD`` is reserved and by using `ezdxf`
the AppID ``EZDXF`` is also registered automatically.
The total size of XDATA for a single DXF entity is limited to 16kB for AutoCAD.
XDATA is supported by all DXF versions and is accessible by AutoLISP.

The valid group codes for extended data are limited to the following values,
see also the internals of :ref:`xdata_internals`:

================= ==============================================================
Group Code        Description
================= ==============================================================
1000              Strings up to 255 bytes long
1001              (fixed) Registered application name up to 31 bytes long
1002              (fixed) An extended data control string ``'{'``  or ``'}'``
1004              Binary data
1005              Database Handle of entities in the drawing database
1010              3D point, in the order X, Y, Z that will not be modified at
                  any transformation of the entity
1011              A WCS point that is moved, scaled, rotated and mirrored
                  along with the entity
1012              A WCS displacement that is scaled, rotated and
                  mirrored along with the entity, but not moved
1013              A WCS direction that is rotated and mirrored along
                  with the entity but not moved and scaled.
1040              A real value
1041              Distance, a real value that is scaled along with the entity
1042              Scale Factor, a real value that is scaled along with the entity
1070              A 16-bit integer (signed or unsigned)
1071              A 32-bit signed (long) integer
================= ==============================================================

Group codes are not unique in the XDATA section and can be repeated, therefore
tag order matters.

.. literalinclude:: src/customdata/xdata.py
    :lines: 10-39

AutoLISP script for getting XDATA for AppID ``YOUR_UNIQUE_ID``:

.. code-block:: Lisp

    (defun C:SHOWXDATA (/ entity_list xdata_list)
        (setq entity_list (entget (car (entsel)) '("YOUR_UNIQUE_ID")))
        (setq xdata_list (assoc -3 entity_list))
        (car (cdr xdata_list))
    )

Script output:

.. code-block:: Text

    : SHOWXDATA
    Select entity: ("YOUR_UNIQUE_ID" (1000 . "custom text") (1040 . 3.141592) ...

.. seealso::

    - `AfraLISP XDATA tutorial <https://www.afralisp.net/autolisp/tutorials/extended-entity-data-part-1.php>`_
    - :ref:`extended_data` Reference

XDATA Helper Classes
--------------------

The :class:`~ezdxf.entities.xdata.XDataUserList` and
:class:`~ezdxf.entities.xdata.XDataUserDict` are helper classes to manage XDATA
content in a simple way.

Both classes store the Python types ``int``, ``float`` and ``str`` and the
`ezdxf` type :class:`~ezdxf.math.Vec3`. As the names suggests has the
:class:`XDataUserList` a list-like interface and the :class:`XDataUserDict` a
dict-like interface. This classes can not contain additional container types,
but multiple lists and/or dicts can be stored in the same XDATA section for the
same AppID.

These helper classes uses a fixed group code for each data type:

==== ========================
1001 strings (max. 255 chars)
1040 floats
1071 32-bit ints
1010 Vec3
==== ========================

Additional required imports for these examples:

.. code-block:: Python

    from ezdxf.math import Vec3
    from ezdxf.entities.xdata import XDataUserDict, XDataUserList

Example for :class:`~ezdxf.entities.xdata.XDataUserDict`:

Each :class:`XDataUserDict` has a unique name, the default name is "DefaultDict"
and the default AppID is ``EZDXF``.
If you use your own AppID, don't forget to create the requited AppID table entry
like :code:`doc.appids.new("MyAppID")`, otherwise AutoCAD will not open the
DXF file.

.. literalinclude:: src/customdata/xdata_helper.py
    :lines: 11-19

If you modify the content of without using the context manager
:meth:`~ezdxf.entities.xdata.XDataUserDict.entity`, you have to call
:meth:`~ezdxf.entities.xdata.XDataUserDict.commit` by yourself, to transfer the
modified data back into the XDATA section.

Getting the data back from an entity:

.. literalinclude:: src/customdata/xdata_helper.py
    :lines: 22-25

Example for :class:`~ezdxf.entities.xdata.XDataUserList`:

This example stores the data in a :class:`XDataUserList` named "AppendedPoints",
the default name is "DefaultList" and the default AppID is ``EZDXF``.

.. literalinclude:: src/customdata/xdata_helper.py
    :lines: 29-32

Now the content of both classes are stored in the same XDATA section for AppID
``EZDXF``. The :class:`XDataUserDict` is stored by the name "DefaultDict" and
the :class:`XDataUserList` is stored by the name "AppendedPoints".

Getting the data back from an entity:

.. literalinclude:: src/customdata/xdata_helper.py
    :lines: 35-39

.. seealso::

    - :class:`~ezdxf.entities.xdata.XDataUserList` class
    - :class:`~ezdxf.entities.xdata.XDataUserDict` class

Extension Dictionaries
----------------------

Extension dictionaries are another way to attach custom data to any DXF
entity. This method requires DXF R13/14 or later. I will use the short term
XDICT for extension dictionaries in this tutorial.

The :ref:`extension_dictionary` is a regular DXF :class:`~ezdxf.entities.Dictionary`
which can store (key, value) pairs where the key is a string and the value is a
DXF object from the OBJECTS section.
The usual objects to store custom data are :class:`~ezdxf.entities.DictionaryVar`
to store simple strings and :class:`~ezdxf.entities.XRecord` to store complex
data.

Unlike XDATA, custom data attached by extension dictionary will not be
transformed along with the DXF entity!

This example shows how to manage the XDICT and to store simple strings as
:class:`~ezdxf.entities.DictionaryVar` objects in the XDICT, to store more
complex data go to the next section `XRecord`_.

1. Get or create the XDICT for an entity:

.. literalinclude:: src/customdata/xdict.py
    :lines: 10-18

2. Add strings as :class:`~ezdxf.entities.DictionaryVar` objects to the XDICT.
No AppIDs required, but existing keys will be overridden, so be careful by
choosing your keys:

.. literalinclude:: src/customdata/xdict.py
    :lines: 20-21

3. Retrieve the strings from the XDICT as :class:`~ezdxf.entities.DictionaryVar`
objects:

.. literalinclude:: src/customdata/xdict.py
    :lines: 23-24


The AutoLISP access to DICTIONARIES is possible, but it gets complex and I'm
only referring to the `AfraLISP Dictionaries and XRecords`_ tutorial.

.. seealso::

    - `AfraLISP Dictionaries and XRecords`_ Tutorial
    - :ref:`extension_dictionary` Reference
    - DXF :class:`~ezdxf.entities.Dictionary` Reference
    - :class:`~ezdxf.entities.DictionaryVar` Reference

XRecord
-------

The :class:`~ezdxf.entities.XRecord` object can store arbitrary data like the
XDATA section, but is not limited by size and can use all group codes in the
range from 1 to 369 for :ref:`dxf_tags_internals`.
The :class:`~ezdxf.entities.XRecord` can be referenced by any DXF
:class:`~ezdxf.entities.Dictionary`, other :class:`XRecord` objects (tricky
ownership!), the XDATA section (store handle by group code 1005) or any other
DXF object by adding the :class:`XRecord` object to the
:ref:`extension_dictionary` of the DXF entity.

It is recommend to follow the DXF reference to assign appropriate group codes
to :ref:`dxf_tags_internals`. My recommendation is shown in the table
below, but all group codes from 1 to 369 are valid. I advice against using the
group codes 100 and 102 (structure tags) to avoid confusing generic tag loaders.
Unfortunately, Autodesk doesn't like general rules and uses DXF format
exceptions everywhere.

=== ======================
1   strings (max. 2049 chars)
2   structure tags as strings like ``"{"`` and  ``"}"``
10  points and vectors
40  floats
90  integers
330 handles
=== ======================

Group codes are not unique in :class:`XRecord` and can be repeated, therefore
tag order matters.

This example shows how to attach a :class:`~ezdxf.entities.XRecord` object to a
LINE entity by :ref:`extension_dictionary`:

.. literalinclude:: src/customdata/xrecord.py
    :lines: 11-28

Script output:

.. code-block:: Text

    [DXFTag(1, 'text1'),
     DXFTag(40, 3.141592),
     DXFTag(90, 256),
     DXFVertex(10, (1.0, 2.0, 0.0)),
     DXFTag(330, '30')]

Unlike XDATA, custom data attached by extension dictionary will not be
transformed along with the DXF entity! To react to entity modifications by a
CAD applications it is possible to write event handlers by AutoLISP, see the
`AfraLISP Reactors Tutorial`_ for more information. This is very advanced stuff!

.. seealso::

    - `AfraLISP Dictionaries and XRecords`_ Tutorial
    - `AfraLISP Reactors Tutorial`_
    - :class:`~ezdxf.entities.XRecord` Reference
    - helper functions: :func:`ezdxf.lldxf.types.dxftag` and :func:`ezdxf.lldxf.types.tuples_to_tags`

XRecord Helper Classes
----------------------

The :class:`~ezdxf.urecord.UserRecord` and :class:`~ezdxf.urecord.BinaryRecord`
are helper classes to manage XRECORD content in a simple way.
The :class:`~ezdxf.urecord.UserRecord` manages the data as plain
Python types: ``dict``, ``list``, ``int``, ``float``, ``str`` and the `ezdxf`
types :class:`~ezdxf.math.Vec2` and :class:`~ezdxf.math.Vec3`. The top level
type for the :attr:`UserRecord.data` attribute has to be a ``list``.
The :class:`~ezdxf.urecord.BinaryRecord` stores arbitrary binary data as `BLOB`_.
These helper classes uses fixed group codes to manage the data in XRECORD,
you have no choice to change them.

Additional required imports for these examples:

.. literalinclude:: src/customdata/urecord.py
    :lines: 6-11

Example 1: Store entity specific data in the :ref:`extension_dictionary`:


.. literalinclude:: src/customdata/urecord.py
    :lines: 23-37

Example 1: Get entity specific data back from the :ref:`extension_dictionary`:

.. literalinclude:: src/customdata/urecord.py
    :lines: 42-47

If you modify the content of :attr:`UserRecord.data` without using the context
manager, you have to call :meth:`~ezdxf.urecord.UserRecord.commit` by yourself,
to store the modified data back into the XRECORD.

Example 2: Store arbitrary data in DICTIONARY objects.
The XRECORD is stored in the named DICTIONARY, called :attr:`rootdict` in `ezdxf`.
This DICTIONARY is the root entity for the tree-like data structure
stored in the OBJECTS section, see also the documentation of the
:mod:`ezdxf.sections.objects` module.

.. literalinclude:: src/customdata/urecord.py
    :lines: 52-69

Example 2:  Get user data back from the DICTIONARY object

.. literalinclude:: src/customdata/urecord.py
    :lines: 74-78

Example 3: Store arbitrary binary data

.. literalinclude:: src/customdata/urecord.py
    :lines: 83-91

Example 3: Get binary data back from the DICTIONARY object

.. literalinclude:: src/customdata/urecord.py
    :lines: 99-106

.. hint::

    Don't be fooled, the ability to save any binary data such as images, office
    documents, etc. in the DXF file doesn't impress AutoCAD, it simply ignores
    this data, this data only has a meaning for your application!

.. seealso::

    - :mod:`~ezdxf.urecord` module
    - :class:`~ezdxf.urecord.UserRecord` class
    - :class:`~ezdxf.urecord.BinaryRecord` class


AppData
-------

:ref:`application_defined_data` was introduced in DXF R13/14 and is used by
AutoCAD internally to store the handle to the :ref:`extension_dictionary` and
the :ref:`reactors` in DXF entities.
`Ezdxf` supports these kind of data storage for any AppID and the data is
preserved by AutoCAD and BricsCAD, but I haven't found a way to access this
data by AutoLISP or even the SDK.
So I don't recommend this feature to store application defined data,
because :ref:`extended_data` and the :ref:`extension_dictionary` are well
documented and safe ways to attach custom data to entities.

.. literalinclude:: src/customdata/appdata.py
    :lines: 10-25

Printed output:

.. code-block:: Text

    LINE(#30) has 3 tags of AppData for AppID 'YOUR_UNIQUE_ID'
    (300, 'custom text')
    (370, 4711)
    (460, 3.141592)

.. _AfraLISP: https://www.afralisp.net/index.php
.. _AfraLISP Dictionaries and XRecords: https://www.afralisp.net/autolisp/tutorials/dictionaries-and-xrecords.php
.. _Visual AutoLISP: https://www.afralisp.net/visual-lisp/
.. _AfraLISP Reactors Tutorial: https://www.afralisp.net/visual-lisp/tutorials/reactors-part-1.php
.. _BLOB: https://en.wikipedia.org/wiki/Binary_large_object

--- End of file: tutorials/custom_data.rst ---



--- Start of file: tutorials/diameter_dimension.rst ---

.. _tut_diameter_dimension:

Tutorial for Diameter Dimensions
================================

Please read the :ref:`tut_radius_dimension` before, if you haven't.

.. note::

    `Ezdxf` does not consider all DIMSTYLE variables, so the
    rendering results are different from CAD applications.

This is a repetition of the radius tutorial, just with diameter dimensions.

.. code-block:: Python

    import ezdxf

    # setup=True setups the default dimension styles
    doc = ezdxf.new("R2010", setup=True)

    msp = doc.modelspace()  # add new dimension entities to the modelspace
    msp.add_circle((0, 0), radius=3)  # add a CIRCLE entity, not required
    # add default diameter dimension, measurement text is located outside
    dim = msp.add_diameter_dim(
        center=(0, 0),
        radius=3,
        angle=45,
        dimstyle="EZ_RADIUS"
    )
    dim.render()
    doc.saveas("diameter_dimension.dxf")

The example above creates a 45 degrees slanted diameter :class:`~ezdxf.entities.Dimension`
entity, the default dimension style "EZ_RADIUS" (same as for radius dimensions)
is defined as 1 drawing unit = 1m, drawing scale = 1:100 and the length
factor = 100, which creates a measurement text in cm, the default
location for the measurement text is outside of the circle.

The `center` point defines the center of the circle but there doesn't have
to exist a circle entity, `radius` defines the circle radius and `angle` defines
the slope of the dimension line, it is also possible to define the circle by a
measurement point `mpoint` on the circle.

The return value `dim` is **not** a dimension entity, instead a
:class:`~ezdxf.entities.DimStyleOverride` object is returned, the dimension
entity is stored as `dim.dimension`.

Placing Measurement Text
------------------------

There are different predefined DIMSTYLES to achieve various text placing locations.

The basic DIMSTYLE "EZ_RADIUS" settings are:

- 1 drawing unit = 1m
- scale 1:100
- the length factor :attr:`dimlfac` = 100, which creates a measurement text in cm.
- uses a closed filled arrow, arrow size :attr:`dimasz` = 0.25

.. note::

    Not all possibles features of DIMSTYLE are supported by the `ezdxf` rendering
    procedure and especially for the diameter dimension there are less features
    implemented than for the linear dimension because of the lack of good
    documentation.

.. seealso::

    - Graphical reference of many DIMVARS and some advanced information:
      :ref:`dimstyle_table_internals`
    - Source code file `standards.py`_ shows how to create your own DIMSTYLES.
    - The Script `dimension_diameter.py`_ shows examples for radius dimensions.

Default Text Locations Outside
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

"EZ_RADIUS" default settings for to place text outside:

=========== ====================================================================
tmove       1 = add a leader when dimension text is moved, this is the best
            setting for text outside to preserve the appearance of the DIMENSION
            entity, if editing afterwards in a CAD application.
dimtad      1 = place the text vertical above the dimension line
=========== ====================================================================

.. code-block:: python

    dim = msp.add_diameter_dim(
        center=(0, 0),
        radius=2.5,
        angle=45,
        dimstyle="EZ_RADIUS"
    )
    dim.render()  # always required, but not shown in the following examples

.. image:: gfx/dim_diameter_outside.png

To force text outside horizontal set :attr:`~ezdxf.entities.DimStyle.dxf.dimtoh`
to 1:

.. code-block:: python

    dim = msp.add_diameter_dim(
        center=(0, 0),
        radius=2.5,
        angle=45,
        dimstyle="EZ_RADIUS",
        override={"dimtoh": 1}
    )

.. image:: gfx/dim_diameter_outside_horiz.png

Default Text Locations Inside
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

DIMSTYLE "EZ_RADIUS_INSIDE" can be used to place the dimension text inside
the circle at a default location.

The basic DIMSTYLE settings are:

- 1 drawing unit = 1m
- scale 1:100, length_factor is 100 which creates
- the length factor :attr:`dimlfac` = 100, which creates a measurement text in cm.
- uses a closed filled arrow, arrow size :attr:`dimasz` = 0.25

Advanced "EZ_RADIUS_INSIDE" settings to place (force) the text inside of the
circle:

=========== ====================================================================
tmove       0 = moves the dimension line with dimension text, this is the best
            setting for text inside to preserve the appearance of the DIMENSION
            entity, if editing afterwards in a CAD application.
dimtix      1 = force text inside
dimatfit    0 = force text inside, required by BricsCAD and AutoCAD
dimtad      0 = center text vertical, BricsCAD and AutoCAD always create a
            vertical centered text, `ezdxf` let you choose the vertical
            placement (above, below, center), but editing the DIMENSION in
            BricsCAD or AutoCAD will reset text to center placement.
=========== ====================================================================

.. code-block:: python

    dim = msp.add_diameter_dim(
        center=(0, 0),
        radius=2.5,
        angle=45,
        dimstyle="EZ_RADIUS_INSIDE"
    )

.. image:: gfx/dim_diameter_inside.png

To force text inside horizontal set :attr:`~ezdxf.entities.DimStyle.dxf.dimtih`
to 1:

.. code-block:: python

    dim = msp.add_diameter_dim(
        center=(0, 0),
        radius=2.5,
        angle=45,
        dimstyle="EZ_RADIUS_INSIDE",
        override={"dimtih": 1}
    )

.. image:: gfx/dim_diameter_inside_horiz.png
    :align: center


User Defined Text Locations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Beside the default location it is always possible to override the text location
by a user defined location. This location also determines the angle of the
dimension line and overrides the argument `angle`. For user defined locations
it is not necessary to force text inside (``dimtix=1``), because the location of
the text is explicit given, therefore the DIMSTYLE "EZ_RADIUS" can be used
for all this examples.

User defined location outside of the circle:

.. code-block:: python

    dim = msp.add_diameter_dim(
        center=(0, 0),
        radius=2.5,
        location=(4, 4),
        dimstyle="EZ_RADIUS"
    )

.. image:: gfx/dim_diameter_user_outside.png

User defined location outside of the circle and forced horizontal text:

.. code-block:: python

    dim = msp.add_diameter_dim(
        center=(0, 0),
        radius=2.5,
        location=(4, 4),
        dimstyle="EZ_RADIUS",
        override={"dimtoh": 1}
    )

.. image:: gfx/dim_diameter_user_outside_horiz.png

User defined location inside of the circle:

.. code-block:: python

    dim = msp.add_diameter_dim(
        center=(0, 0),
        radius=2.5,
        location=(1, 1),
        dimstyle="EZ_RADIUS"
    )

.. image:: gfx/dim_diameter_user_inside.png

User defined location inside of the circle and forced horizontal text:

.. code-block:: python

    dim = msp.add_diameter_dim(
        center=(0, 0),
        radius=2.5,
        location=(1, 1),
        dimstyle="EZ_RADIUS",
        override={"dimtih": 1},
    )

.. image:: gfx/dim_diameter_user_inside_horiz.png

Center Mark/Lines
-----------------

See Radius Dimension Tutorial: :ref:`tut_center_mark`

Overriding Measurement Text
---------------------------

See Linear Dimension Tutorial: :ref:`tut_overriding_measurement_text`

Measurement Text Formatting and Styling
---------------------------------------

See Linear Dimension Tutorial: :ref:`tut_measurement_text_formatting_and_styling`


.. _dimension_diameter.py:  https://github.com/mozman/ezdxf/blob/master/examples/render/dimension_diameter.py
.. _standards.py: https://github.com/mozman/ezdxf/blob/master/src/ezdxf/tools/standards.py

--- End of file: tutorials/diameter_dimension.rst ---



--- Start of file: tutorials/dxf_primitives.rst ---

.. _tut_dxf_primitives:

Tutorial for Simple DXF Entities
================================

These are basic graphical entities located in an entity space like
the modelspace or a block definition and only support the common graphical
attributes.

The entities in the following examples are always placed in the xy-plane of the
:ref:`WCS` aka the 2D drawing space.
Some of these entities can only be placed outside the xy-plane in 3D space by
utilizing the :ref:`OCS`, but this feature is beyond the scope of this tutorial,
for more information about that go to: :ref:`tut_ocs`.

Prelude to all following examples::

    import ezdxf
    from ezdxf.gfxattribs import GfxAttribs

    doc = ezdxf.new()
    doc.layers.new("ENTITY", color=1)
    msp = doc.modelspace()
    attribs = GfxAttribs(layer="ENTITY")

.. seealso::

    - :ref:`tut_simple_drawings`
    - :ref:`tut_layers`
    - :mod:`ezdxf.gfxattribs` module

.. _tut_dxf_primitives_point:

Point
-----

The :class:`~ezdxf.entities.Point` entity marks a 3D point in the :ref:`WCS`::

    point = msp.add_point((10, 10), dxfattribs=attribs)

All :class:`~ezdxf.entities.Point` entities have the same styling stored in the
header variable $PDMODE, for more information read the reference of class
:class:`~ezdxf.entities.Point`.

.. seealso::

    - Reference of class :class:`~ezdxf.entities.Point`
    - :ref:`tut_common_graphical_attributes`

.. _tut_dxf_primitives_line:

Line
----

The :class:`~ezdxf.entities.Line` entity is a 3D line with a start- and
an end point in the :ref:`WCS`::

    line = msp.add_line((0, 0), (10, 10), dxfattribs=attribs)

.. seealso::

    - Reference of class :class:`~ezdxf.entities.Line`
    - :ref:`tut_common_graphical_attributes`
    - :class:`ezdxf.math.ConstructionLine`

.. _tut_dxf_primitives_circle:

Circle
------

The :class:`~ezdxf.entities.Circle` entity is an :ref:`OCS` entity defined by a
center point and a radius::

    circle = msp.add_circle((10, 10), radius=3, dxfattribs=attribs)


.. seealso::

    - Reference of class :class:`~ezdxf.entities.Circle`
    - :ref:`tut_common_graphical_attributes`
    - :class:`ezdxf.math.ConstructionCircle`

.. _tut_dxf_primitives_arc:

Arc
---

The :class:`~ezdxf.entities.Arc` entity is an :ref:`OCS` entity defined by a
center point, a radius a start-  and an end angle in degrees::

    arc = msp.add_arc((10, 10), radius=3, start_angle=30, end_angle=120, dxfattribs=attribs)

The arc goes always in counter-clockwise orientation around the z-axis more
precisely the extrusion vector of :ref:`OCS`, but this is beyond the scope of
this tutorial.

The helper class :class:`ezdxf.math.ConstructionArc` provides constructors to
create arcs from different scenarios:

- :class:`~ezdxf.math.ConstructionArc.from_2p_angle`: arc from 2 points and an angle
- :class:`~ezdxf.math.ConstructionArc.from_2p_radius`: arc from 2 points and a radius
- :class:`~ezdxf.math.ConstructionArc.from_3p`: arc from 3 points

This example creates an arc from point (10, 0) to point (0, 0) passing the
point (5, 3):

.. code-block:: Python

    from ezdxf.math import ConstructionArc

    # -x-x-x- snip -x-x-x-

    arc = ConstructionArc.from_3p(
        start_point=(10, 0), end_point=(0, 0), def_point=(5, 3)
    )
    arc.add_to_layout(msp, dxfattribs=attribs)

.. seealso::

    - Reference of class :class:`~ezdxf.entities.Arc`
    - :ref:`tut_common_graphical_attributes`
    - :class:`ezdxf.math.ConstructionArc`

.. _tut_dxf_primitives_ellipse:

Ellipse
-------

The :class:`~ezdxf.entities.Ellipse` entity requires DXF R2000 or newer and is a
true :ref:`WCS` entity. The ellipse is defined by a center point, a vector for
the major axis, the ratio between major- and minor axis and the start- and end
parameter in radians::

    ellipse = msp.add_ellipse(
        (10, 10), major_axis=(5, 0), ratio=0.5, start_param=0, end_param=math.pi, dxfattribs=attribs
    )


When placed in 3D space the extrusion vector defines the normal vector of the
ellipse plane and the minor axis is the extrusion vector ``cross`` the major axis.


.. seealso::

    - Reference of class :class:`~ezdxf.entities.Ellipse`
    - :ref:`tut_common_graphical_attributes`
    - :class:`ezdxf.math.ConstructionEllipse`


Further Tutorials
-----------------

- :ref:`tut_lwpolyline`
- :ref:`tut_spline`
- :ref:`tut_text`
- :ref:`tut_mtext`
- :ref:`tut_hatch`
- :ref:`tut_mleader`
- :ref:`tut_mesh`


--- End of file: tutorials/dxf_primitives.rst ---



--- Start of file: tutorials/edges.rst ---

.. _tut_edges:

Tutorial for Finding Chains and Loops
=====================================

.. versionadded:: 1.4

This tutorial shows how to find connected structures like open or closed polylines
by the :mod:`ezdxf.edgeminer` and the :mod:`ezdxf.edgesmith` modules.

Introduction
------------

The main goal of the :mod:`ezdxf.edgeminer` module is to find connected edges in a heap
of unordered edges.

The module is designed to work with anything that has a start- and end point and knows
nothing about the edge itself except for the optional length. Therefore intersection
points between edges are not known.

1. Step: Create Edges
~~~~~~~~~~~~~~~~~~~~~

The companion module :mod:`ezdxf.edgesmith` creates the required edges from DXF
primitives like LINE, ARC, ELLIPSE, SPLINE and POLYLINE.

- :func:`ezdxf.edgesmith.make_edge_2d`
- :func:`ezdxf.edgesmith.edges_from_entities_2d`

The current implementation of the :mod:`~ezdxf.edgesmith` module is restricted to work
with 2D structures. Every edge is projected onto the xy-plane of the :ref:`WCS`.

2. Step: Find Chains and Loops
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :mod:`~ezdxf.edgeminer` module provides functions to search for open chains and
closed loops:

- :func:`ezdxf.edgeminer.find_sequential_chain`
- :func:`ezdxf.edgeminer.find_all_sequential_chains`
- :func:`ezdxf.edgeminer.find_simple_chain`
- :func:`ezdxf.edgeminer.find_all_simple_chains`
- :func:`ezdxf.edgeminer.find_all_open_chains`
- :func:`ezdxf.edgeminer.find_loop`
- :func:`ezdxf.edgeminer.find_loop_by_edge`
- :func:`ezdxf.edgeminer.find_all_loops`

3. Step: Build Polylines and Paths
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

From the chains and loops found, you can build new polylines and boundary paths for
hatches:

- :func:`ezdxf.edgesmith.lwpolyline_from_chain`
- :func:`ezdxf.edgesmith.polyline2d_from_chain`
- :func:`ezdxf.edgesmith.polyline_path_from_chain`
- :func:`ezdxf.edgesmith.edge_path_from_chain`
- :func:`ezdxf.edgesmith.path2d_from_chain`

Terminology
-----------

This is a short summary, for more information see: :mod:`ezdxf.edgeminer`

Edge
    A linear connection between two points.

Leaf
    A leaf is a loose end of an edge, which is not connected to other edges.

Junction
    A junction has more than two adjacent edges.

Chain
    A chain has sequential connected edges.
    The end point of an edge is connected to the start point of the following edge.

Simple Chain
    A simple chain starts and ends with a leaf or a junction.

Open Chain
    An open chain starts and ends with a leaf.

Loop
    A loop is a simple chain with connected start- and end vertices.

.. _tut_join_to_polylines:

Join Ordered Entities to Polylines
----------------------------------

The first example uses an exploded polyline to show how to search for connected edges,
when the edges are ordered.

.. code-block:: Python

    import random
    import ezdxf
    from ezdxf import edgeminer, edgesmith

    doc = ezdxf.new()
    doc.header["$LWDISPLAY"] = 1
    msp = doc.modelspace()

    lwp = msp.add_lwpolyline(
        [(0, 0), (5, 0, -0.5), (5, 5), (0, 5)],
        format="xyb",
        close=True,
        dxfattribs={"layer": "SOURCE", "color": 2, "lineweight": 30},
    )
    # create lines and arcs from LWPOLYLINE
    entities = lwp.explode()

The orientation of the entities looks like this:

.. image:: gfx/edges_01_src.png

ARC entities are always counter-clockwise oriented, so the start- and end points
of the adjacent lines are not connected in start/end order.

The :func:`ezdxf.edgeminer.find_sequential_chain` function is the right tool for this
task. It searches sequential ordered edges and reverses those, where the start- and end
point doesn't match. The search stops at the first edge that doesn't have a matching
start- or end point or a closed loop was found.

    1. create edges from DXF entities
    2. find connected edges
    3. create LWPOLYLINE from connected edges

.. code-block:: Python

    # 1. create edges from DXF entities
    edges = list(edgesmith.edges_from_entities_2d(entities))
    # 2. search for connected edges
    chain = edgeminer.find_sequential_chain(edges)
    # 3. create a LWPOLYLINE from connected edges
    lwp2 = edgesmith.lwpolyline_from_chain(
        chain, dxfattribs={"layer": "LWPOLYLINE", "color": 1, "lineweight": 30}
    )
    msp.add_entity(lwp2)
    doc.saveas("result1.dxf")

The new created LWPOLYLINE in BricsCAD:

.. image:: gfx/edges_02_lwp2.png

Join Unordered Entities to Polylines
------------------------------------

For the search in a heap of unordered edges is an additional object required.
A :class:`ezdxf.edgeminer.Deposit` has a spatial search tree to optimize the
search for unordered edges.

The :func:`ezdxf.edgeminer.find_simple_chain` function starts at an edge and searches in
both directions via the spatial search tree for connected edges. The search stops at a
leaf, a junction or when a closed loop was found.

.. code-block:: Python

    # create a new doc
    doc = ezdxf.new()
    doc.header["$LWDISPLAY"] = 1
    msp = doc.modelspace()

    # reuse same entities from previous example
    edges = list(edgesmith.edges_from_entities_2d(entities))

    # shuffle the ordered edges
    random.shuffle(edges)

    # a deposit optimizes the search for unordered edges
    deposit = edgeminer.Deposit(edges)

    # start the search at an arbitrary edge
    start = edges[0]
    chain = edgeminer.find_simple_chain(deposit, start)
    lwp3 = edgesmith.lwpolyline_from_chain(
        chain, dxfattribs={"color": 1, "lineweight": 30}
    )
    msp.add_entity(lwp3)
    doc.saveas("result2.dxf")

The result is the same as in "result1.dxf".

The following functions are for situations when you don't know where to start.

    - :func:`ezdxf.edgeminer.find_all_simple_chains`: returns all chains that start
      and end with a leaf or a junction
    - :func:`ezdxf.edgeminer.find_all_open_chains`: returns all chains from the deposit
      that start and end with a leaf. Warning: recursive backtracking!
    - :func:`ezdxf.edgeminer.find_loop`: returns the first loop found in the deposit.
      Warning: recursive backtracking!
    - :func:`ezdxf.edgeminer.find_all_loops`: returns all possible loops found in the
      deposit. Warning: recursive backtracking!


.. _tut_join_to_hatches:

Join Entities to Hatches
------------------------

Creating hatches from edges is similar to creating polylines.

    1. create a :class:`~ezdxf.entities.Hatch`
    2. find connected edges
    3. create boundary paths from connected edges
    4. add boundary paths to :class:`~ezdxf.entities.Hatch`

.. code-block:: Python

    # create a new doc
    doc = ezdxf.new()
    doc.header["$LWDISPLAY"] = 1
    msp = doc.modelspace()

    # 1. create a HATCH
    hatch = msp.add_hatch(color=2)

    # reuse same entities from previous example
    edges = list(edgesmith.edges_from_entities_2d(entities))

    # shuffle the ordered edges
    random.shuffle(edges)

    # a deposit optimizes the search for unordered edges
    deposit = edgeminer.Deposit(edges)

    # start the search at an arbitrary edge
    start = edges[0]

    # 2. find edges
    chain = edgeminer.find_simple_chain(deposit, start)

    # 3. create a polyline boundary path from edges
    boundary_path = edgesmith.polyline_path_from_chain(chain)

    # 4.add boundary path to HATCH
    hatch.paths.append(boundary_path)
    doc.saveas("hatch1.dxf")

The new created HATCH in BricsCAD:

.. image:: gfx/edges_03_hatch.png

How Are 3D Entities Handled?
----------------------------

The :mod:`ezdxf.edgeminer` module is designed to be as versatile as possible and uses
3D coordinates for all vertices. So edges are only connected when the x-, y- and
z-coordinates of their vertices are close together.

The :mod:`ezdxf.edgesmith` module is designed to avoid the complexity of 3D entities and
handles only 2D entities by setting all z-coordinates to 0.
Therefore all vertices are projected onto the xy-plane of the
WCS and if an entity can not represent such a projection the entity will be flattened
into line segments.

This example includes an ARC and a SPLINE in 3D space:

.. image:: gfx/edges_04_3d_xy.png

.. image:: gfx/edges_04_3d_iso.png

.. code-block:: Python

    doc = ezdxf.readfile("edges_3d.dxf")
    msp = doc.modelspace()

    # create edges and search index
    edges = list(edgesmith.edges_from_entities_2d(msp))
    deposit = edgeminer.Deposit(edges)
    # find a chain
    chain = edgeminer.find_simple_chain(deposit, edges[0])
    # add a hatch and add the boundary path
    hatch = msp.add_hatch(color=5)
    boundary_path = edgesmith.polyline_path_from_chain(chain, max_sagitta=0.01)
    hatch.paths.append(boundary_path)
    doc.saveas("flattened_hatch.dxf")

The hatch is projected onto the xy-plane of the WCS:

.. image:: gfx/edges_04_hatch.png

To process only 2D entities us the :func:`~ezdxf.edgesmith.filter_2d_entities`
function that returns only pure 2D entities and ignores all entities placed outside or
extending beyond the xy-plane.

Junctions
---------

A junction is a vertex with a degree of 3 or more and adds complexity to the task of
finding geometry. There is not a single solution that fits all needs and some goals are
not achievable by the :mod:`ezdxf.edgeminer` module.

This is the starting point for the following examples, each red circle marks a junction:

.. image:: gfx/edges_05_lines.png

You can check the complexity of your problem by printing the degree-counter:

.. code-block:: Python

    print(deposit.degree_counter())

Output::

    Counter({2: 15, 3: 4})

There a 15 vertices of degree 2 (good) and 4 vertices of degree 3 (bad).

Find All Simple Chains
~~~~~~~~~~~~~~~~~~~~~~

A simple chain starts and ends with a leaf or a junction, hence there are no decisions
to make and and finding them is also fast by using a spatial search index.

.. code-block:: Python

    # load data
    doc = ezdxf.readfile("junctions.dxf")
    msp = doc.modelspace()
    lines = msp.query("LINE")

    # create edges and search index
    edges = list(edgesmith.edges_from_entities_2d(lines))
    deposit = edgeminer.Deposit(edges)

    # find chains
    chains = edgeminer.find_all_simple_chains(deposit)

    # create a new output document
    out = ezdxf.new()
    msp = out.modelspace()
    color = 1
    for chain in chains:
        polyline = edgesmith.lwpolyline_from_chain(
            chain, dxfattribs={"color": color}
        )
        msp.add_entity(polyline)
        color += 1
    out.saveas("simple_chains.dxf")


Each color represents a separated LWPOLYLINE:

.. image:: gfx/edges_05_simple_chains.png

Find All Loops
~~~~~~~~~~~~~~

This task is harder and an edge can be part of multiple solutions:

.. code-block:: Python

    # same code as in the previous example til here
    # find chains
    loops = edgeminer.find_all_loops(deposit)

    # create a new output document
    out = ezdxf.new()
    msp = out.modelspace()
    color = 1
    for loop in loops:
        layer = f"LOOP_{color}"
        polyline = edgesmith.lwpolyline_from_chain(
            loop, dxfattribs={"color": color, "layer": layer}
        )
        msp.add_entity(polyline)
        color += 1
    out.saveas("loops.dxf")


These are 6 of the 7 solutions, the 7th solution is the dashed line:

.. image:: gfx/edges_05_loops.png

The :func:`~ezdxf.edgeminer.find_all_loops` function is a recursive backtracking
algorithm and has a complexity of O(n!), therefore all recursive search functions
have a timeout argument to finish the task before the universe ends.

These helper functions may help you to choose a solution, but the default length
calculation for edges is not precise!

- :func:`ezdxf.edgeminer.longest_chain`
- :func:`ezdxf.edgeminer.shortest_chain`

Find One Loop For a Given Edge
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :func:`~ezdxf.edgeminer.find_loop_by_edge` function starts at a given edge and has a
preferred `clockwise` or `counter-clockwise` search order. The algorithm chooses the
next edge at a junction in `clockwise` order if the argument :attr:`clockwise` is ``True``
otherwise the first `counter-clockwise` edge. This is a fast non-recursive algorithm.

.. code-block:: Python

    edges = list(edgesmith.edges_from_entities_2d(lines))
    deposit = edgeminer.Deposit(edges)

    # choose an edge to start with
    start = edges[0]
    loop1 = edgeminer.find_loop_by_edge(deposit, start, clockwise=True)
    loop2 = edgeminer.find_loop_by_edge(deposit, start, clockwise=False)

.. image:: gfx/edges_05_choose_order.png

Red is the `clockwise` solution and yellow is the `counter-clockwise` solution:

.. image:: gfx/edges_05_find_loop_by_edge.png

Find Loop by Pick-Point
-----------------------

The CAD functionality to select a HATCH boundary path by picking a point inside the
boundary is a bit tricky, but can be achieved by combining some tools.

    1. find a starting edge near the pick-point
    2. find candidates by the :func:`find_loop_by_edge` function for both search orders
    3. sort candidates by area
    4. take the smallest loop which contains the pick-point

.. image:: gfx/edges_06_loop_by_pick_point.png

The function :func:`~ezdxf.edgesmith.intersecting_edges_2d` tests all edges for an
intersection with a line starting at the pick-point and ending outside the bounding box
of all vertices. Any loop containing the pick-point has at least one edge that
intersects this line.

.. code-block:: Python

    doc = ezdxf.readfile("junctions.dxf")
    msp = doc.modelspace()
    lines = msp.query("LINE")
    edges = list(edgesmith.edges_from_entities_2d(lines))
    pick_point = (110, 50)

    # 1. find a starting edge near the pick-point
    intersecting_edges = edgesmith.intersecting_edges_2d(edges, pick_point)
    if not len(intersecting_edges):
        print("no intersection found")
        return
    hatch = msp.add_hatch(color=2)

    # The intersecting edges are sorted by ascending distance to the pick-point
    # take the closest edge as starting edge:
    start = intersecting_edges[0].edge

    # 2. find the best loop candidates
    deposit = edgeminer.Deposit(edges)
    candidates = [
        edgeminer.find_loop_by_edge(deposit, start, clockwise=True),
        edgeminer.find_loop_by_edge(deposit, start, clockwise=False),
    ]

    # 3. sort candidates by area
    candidates.sort(key=edgesmith.loop_area)
    for loop in candidates:
        # 4. take the smallest loop which contains the pick-point
        if edgesmith.is_inside_polygon_2d(loop, pick_point):
            hatch.paths.append(edgesmith.polyline_path_from_chain(loop))
            break
    else:  # for loop ended without break
        print("no loop found")
        return
    doc.saveas("find_loop_by_pick_point.dxf")

I am not convinced that this is the best solution or that this solution works for all
use cases, therefore this is not (yet) a helper function in the :mod:`edgesmith` module.

Gaps and Design Inaccuracies
----------------------------

Most real-world DXF drawings have design inaccuracies, that means, there are gaps between
the endpoints of entities.

All search and test functions have an optional argument :attr:`gap_tol` or the gap
tolerance is stored in the :class:`Deposit` class.
The gap tolerance is the maximum distance between two edge vertices to consider them
as connected. It is important to use the same tolerance throughout a task, from creating
the edges til building new DXF entities from chains and loops.

Specialty Edge Paths
~~~~~~~~~~~~~~~~~~~~

AutoCAD is very picky about edge paths in HATCH entities when it comes to considering
them as closed. Therefore the :func:`edge_path_from_chain` function adds additional line
segments between edges when the gap is larger than ``LEN_TOL``, ``LEN_TOL`` is a constant
value of 1e-9.

Coincident Edges
----------------

Coincident edges in the context of :mod:`edgeminer` are edges where the start- and the end vertex
are coincident, remember: the shape of the edge is not known. This is the reason why such
edges are not removed automatically, e.g. two arcs can create a closed loop as coincident
edges:

.. image:: gfx/edges_07_loop_from_arcs.png

Coincident edges are a major nuisance and should be avoided at all costs. They create
ambiguity and can be the reason why the expected results are not found.

The :func:`~ezdxf.edgeminer.filter_coincident_edges` function removes coincident edges.
It takes a function to test if two edges are coincident and the default function tests
only if the end points are coincident, but you can pass a more sophisticated function.


Set Operations
--------------

The :class:`ezdxf.edgeminer.Edge` class implements the :meth:`__hash__` method and can be
used in sets, this allows set operations like subtracting a found loop from the source
edges:

.. code-block:: Python

    edges = list(edgesmith.edges_from_entities_2d(lines))
    deposit = edgeminer.Deposit(edges)

    # returns the first loop found
    first_loop = edgeminer.find_loop(deposit)
    edges = list(set(edges) - set(first_loop))

    # or use this helper function:
    edges = edgeminer.subtract_edges(edges, first_loop)

The :class:`Deposit` has to be recreated for the new list of edges!

--- End of file: tutorials/edges.rst ---



--- Start of file: tutorials/entity_selection.rst ---

.. _tut_entity_selection:

Tutorial for Entity Selection
=============================

This tutorial shows how to use the :mod:`ezdxf.select` module, which provides functions 
to select entities based on various shapes.  These selection functions offer a way to 
filter entities based on their spatial location.

This is the base document for this tutorial:

.. figure:: gfx/select-base.png

Why Bounding Boxes?
-------------------

The :mod:`~ezdxf.select` module primarily relies on bounding boxes to perform selections. 
Bounding boxes offer a fast way to identify potential overlaps between entities and the 
selection shape. This approach prioritizes performance over absolute accuracy.

.. note::

    The bounding boxes for text-based entities and entities containing curves are not 
    accurate! For more information read the docs for the :mod:`ezdxf.bbox` module.

Source of Entities
------------------

The source of the selection can be any iterable of DXF entities, like the modelspace, 
any paperspace layout or a block layout, also the result of an entity query as an 
:class:`~ezdxf.query.EntityQuery` container, or any collection of DXF entities that 
implements the :meth:`__iter__` method.

Selection Shapes
----------------

- :class:`~ezdxf.select.Window`: Defines a rectangular selection area.
- :class:`~ezdxf.select.Circle`: Selects entities within a circular area.
- :class:`~ezdxf.select.Polygon`: Selects entities based on the shape of a closed polygon.

Using Selection Functions
-------------------------

These selection functions utilize the selection shapes:

- :func:`~ezdxf.select.bbox_inside`: Selects entities whose bounding box lies withing the selection shape.
- :func:`~ezdxf.select.bbox_outside`: Selects entities whose bounding box is completely outside the selection shape.
- :func:`~ezdxf.select.bbox_overlap`: Selects entities whose bounding box overlaps the selection shape.

Additional selection functions:

- :func:`~ezdxf.select.bbox_chained`: Selects entities that are linked together by overlapping bounding boxes.
- :func:`~ezdxf.select.bbox_crosses_fence`: Selects entities whose bounding box overlaps an open polyline.
- :func:`~ezdxf.select.point_in_bbox`: Selects entities where the selection point lies within the bounding box.

The functions return an :class:`~ezdxf.query.EntityQuery` object, which provides access 
to the selected entities. You can iterate over the :class:`EntityQuery` to access each 
selected entity.

Bounding Box Inside Selection
-----------------------------

Selects entities which bounding boxes are completely within the selection shape.

Example to select entities inside a window:

.. figure:: gfx/select-inside-window.png


.. code-block:: Python

    import ezdxf
    from ezdxf import select

    doc = ezdxf.readfile("base.dxf")
    msp 0 doc.modelspace()

    window = select.Window((150, 105), (280, 240))
    for entity in select.bbox_inside(window, msp):
        print(str(entity))

output::

    CIRCLE(#9D)
    LWPOLYLINE(#9E)

Bounding Box Outside Selection
------------------------------

Selects entities whose bounding box is completely outside the selection shape.

.. figure:: gfx/select-outside-window.png

.. code-block:: Python

    window = select.Window((185, 105), (245, 240))
    for entity in select.bbox_outside(window, msp):
        print(str(entity))

output::

    TEXT(#9F)
    SPLINE(#A0)
    LINE(#A1)

Bounding Box Overlap Selection
------------------------------

Selects entities whose bounding box overlaps the selection shape.

This function works similar to the crossing selection in CAD applications, but not 
exactly the same.  The function selects entities whose bounding boxes overlap the 
selection shape.  This will also select elements where all of the entity geometry is 
outside the selection shape, but the bounding box overlaps the selection shape, 
e.g. border polylines.

.. figure:: gfx/select-inside-window.png

.. code-block:: Python

    window = select.Window((150, 105), (280, 240))
    for entity in select.bbox_overlap(window, msp):
        print(str(entity))

output::

    CIRCLE(#9D)
    LWPOLYLINE(#9E)
    TEXT(#9F)
    SPLINE(#A0)
    LINE(#A1)
    LWPOLYLINE(#A2)

Bounding Box Chained Selection
------------------------------

Selects elements that are directly or indirectly connected to each other by overlapping 
bounding boxes. The selection begins at the specified starting element.

.. figure:: gfx/select-chained.png

.. code-block:: Python

    # choose entity for the beginning of the chain:
    line = msp.query("LINE").first
    for entity in select.bbox_chained(line, msp):
        print(str(entity))

output::

    LINE(#A1)
    CIRCLE(#9D)
    LWPOLYLINE(#9E)
    SPLINE(#A0)

Bounding Box Crosses Fence
--------------------------

Selects entities whose bounding box intersects an open polyline.

.. figure:: gfx/select-fence.png

.. code-block:: Python

    for entity in select.bbox_crosses_fence([(83, 101), (186, 193), (300, 107)], msp):
        print(str(entity))

output::

    CIRCLE(#9D)
    LWPOLYLINE(#9E)
    SPLINE(#A0)
    LINE(#A1)

.. note::

    The polyline does not cross the entity geometry itself!

Point In Bounding Box Selection
-------------------------------

Selects entities where the selection point lies within the bounding box.

.. figure:: gfx/select-point.png

.. code-block:: Python

    for entity in select.bbox_point((264, 140), msp):
        print(str(entity))

output::

    LWPOLYLINE(#9E)
    SPLINE(#A0)

Circle Selection
----------------

For the circle shape, the selection tests are carried out on the real circlar area.

This example selects all entities around the CIRCLE entity within a 60 unit radius
whose bounding box overlaps the circle selection:

.. figure:: gfx/select-by-circle.png

.. code-block:: Python

    entity = msp.query("CIRCLE").first
    circle = select.Circle(entity.dxf.center, radius=60)
    for entity in select.bbox_overlap(circle, msp):
        print(str(entity))

output::

    CIRCLE(#9D)
    LWPOLYLINE(#9E)
    TEXT(#9F)
    SPLINE(#A0)

Polygon Selection
-----------------

As for the circle shape, the polygon selection tests are carried out on the real polygon 
area. 

.. note::
    
    This may not work 100% correctly if the selection polygon has a complex concave shape!

This example selects all entities whose bounding box lies entirely within the selection 
polygon:

.. figure:: gfx/select-by-polygon.png

.. code-block:: Python

    
    polygon = select.Polygon([(110, 168), (110, 107), (316, 107), (316, 243), (236, 243)])
    for entity in select.bbox_inside(polygon, msp):
        print(str(entity))

output::

    LWPOLYLINE(#9E)
    SPLINE(#A0)
    LINE(#A1)



--- End of file: tutorials/entity_selection.rst ---



--- Start of file: tutorials/geo.rst ---

.. _tut_geo_addon:

Tutorial for the Geo Add-on
===========================

This tutorial shows how to load a GPS track into a geo located DXF file and
also the inverse operation, exporting geo located DXF entities as GeoJSON
files.

Please read the section :ref:`geo_intended_usage` in the documentation of the
:mod:`ezdxf.addons.geo` module first.

.. warning::

    TO ALL BEGINNERS!

    If you are just learning to work with geospatial data, using DXF files is
    not the way to go! DXF is not the first choice for storing data for
    spatial data analysts. If you run into problems I cannot help you as
    I am just learning myself.


The complete source code and test data for this tutorial are available in the
github repository:

https://github.com/mozman/ezdxf/tree/master/docs/source/tutorials/src/geo

Setup Geo Location Reference
----------------------------

The first step is setting up the geo location reference, which is **not** doable
with ezdxf yet - this feature may come in the future - but for now you have
to use a CAD application to do this. If the DXF file has no geo location
reference the projected 2D coordinates are most likely far away from the WCS
origin (0, 0), use the CAD command "ZOOM EXTENDS" to find the data.


Load GPX Data
-------------

The GPX format stores GPS data in a XML format, use the :class:`ElementTree`
class to load the data:

.. literalinclude:: src/geo/gpx.py
    :lines: 15-22

The loaded GPS data has a WSG84 EPSG:4326 projection as longitude and
latitude in decimal degrees. The next step is to create a :class:`GeoProxy`
object from this data, the :meth:`GeoProxy.parse` method accepts a
``__geo_interface__`` mapping or a Python object with a
:attr:`__geo_interface__` attribute/property. In this case as simple
"LineString" object for all GPS points is sufficient:

.. literalinclude:: src/geo/gpx.py
    :lines: 25-30

Transform the data from the polar representation EPSG:4326 into a 2D cartesian
map representation EPSG:3395 called "World Mercator", this is the only
projection supported by the add-on, without the need to write a custom
transformation function:

.. literalinclude:: src/geo/gpx.py
    :lines: 34

The data is now transformed into 2D cartesian coordinates in meters and most
likely far away from origin (0, 0), the data stored in the GEODATA entity helps
to transform the data into the DXF WCS in modelspace units, if the DXF file has
no geo location reference you have to stick with the large coordinates:

.. literalinclude:: src/geo/gpx.py
    :lines: 36-54

We are ready to save the final DXF file::

    doc.saveas(str(out_path))


In BricsCAD the result looks like this, the underlying images were added by
the BricsCAD command MAPCONNECT and such a feature is **not** planned for
the add-on:

.. image:: gfx/gpx_tracks.png

Export DXF Entities as GeoJSON
------------------------------

This will only work with a proper geo location reference, the code shown accepts
also WCS data from DXF files without a GEODATA object, but the result is just
unusable - but in valid GeoJSON notation.

First get epsg code and the CRS transformation matrix:

.. literalinclude:: src/geo/gpx.py
    :lines: 82-89

Query the DXF entities to export:

.. literalinclude:: src/geo/gpx.py
    :lines: 90-91

Create a :class:`GeoProxy` object from the DXF entity:

.. literalinclude:: src/geo/gpx.py
    :lines: 57-59

Transform DXF WCS coordinates in modelspace units into the CRS coordinate system
by the transformation matrix `m`:

.. literalinclude:: src/geo/gpx.py
    :lines: 60-61

The next step assumes a EPSG:3395 projection, everything else needs a custom
transformation function:

.. literalinclude:: src/geo/gpx.py
    :lines: 62-64

Use the :mod:`json` module from the Python standard library to write the
GeoJSON data, provided by the :attr:`GeoProxy.__geo_interface__` property:

.. literalinclude:: src/geo/gpx.py
    :lines: 65-68

The content of the GeoJSON file looks like this:

.. code::

    {
      "type": "LineString",
      "coordinates": [
        [
          15.430999,
          47.06503
        ],
        [
          15.431039,
          47.064797
        ],
        [
          15.431206,
          47.064582
        ],
        [
          15.431283,
          47.064342
        ],
        ...
    }

Custom Transformation Function
------------------------------

This sections shows how to use the GDAL package to write a custom transformation
function. The example reimplements the builtin transformation from unprojected
WGS84 coordinates to 2D map coordinates EPSG:3395 "World Mercator":

.. code-block:: python

    from osgeo import osr
    from ezdxf.math import Vec3

    # GPS track in WGS84, load_gpx_track() code see above
    gpx_points = list(load_gpx_track('track1.gpx'))

    # Create source coordinate system:
    src_datum = osr.SpatialReference()
    src_datum.SetWellKnownGeoCS('WGS84')

    # Create target coordinate system:
    target_datum = osr.SpatialReference()
    target_datum.SetWellKnownGeoCS('EPSG:3395')

    # Create transformation object:
    ct = osr.CoordinateTransform(src_datum, target_datum)

    # Create GeoProxy() object:
    geo_proxy = GeoProxy.parse({
        'type': 'LineString',
        'coordinates': gpx_points
    })

    # Apply a custom transformation function to all coordinates:
    geo_proxy.apply(lambda v: Vec3(ct.TransformPoint(v.x, v.y)))

The same example with the pyproj package:

.. code-block:: python

    from pyproj import Transformer
    from ezdxf.math import Vec3

    # GPS track in WGS84, load_gpx_track() code see above
    gpx_points = list(load_gpx_track('track1.gpx'))

    # Create transformation object:
    ct = Transformer.from_crs('EPSG:4326', 'EPSG:3395')

    # Create GeoProxy() object:
    geo_proxy = GeoProxy.parse({
        'type': 'LineString',
        'coordinates': gpx_points
    })

    # Apply a custom transformation function to all coordinates:
    geo_proxy.apply(lambda v: Vec3(ct.transform(v.x, v.y)))

Polygon Validation by Shapely
-----------------------------

Ezdxf tries to avoid to create invalid polygons from HATCH entities like a hole
in another hole, but not all problems are detected by ezdxf, especially
overlapping polygons. For a reliable and robust result use the Shapely package
to check for valid polygons:

.. code-block:: python

    import ezdxf
    from ezdxf.addons import geo
    from shapely.geometry import shape

    # Load DXF document including HATCH entities.
    doc = ezdxf.readfile('hatch.dxf')
    msp = doc.modelspace()

    # Test a single entity
    # Get the first DXF hatch entity:
    hatch_entity = msp.query('HATCH').first

    # Create GeoProxy() object:
    hatch_proxy = geo.proxy(hatch_entity)

    # Shapely supports the __geo_interface__
    shapely_polygon = shape(hatch_proxy)

    if shapely_polygon.is_valid:
        ...
    else:
        print(f'Invalid Polygon from {str(hatch_entity)}.')

    # Remove invalid entities by a filter function
    def validate(geo_proxy: geo.GeoProxy) -> bool:
        # Multi-entities are divided into single entities:
        # e.g. MultiPolygon is verified as multiple single Polygon entities.
        if geo_proxy.geotype == 'Polygon':
            return shape(geo_proxy).is_valid
        return True

    # The gfilter() function let only pass compatible DXF entities
    msp_proxy = geo.GeoProxy.from_dxf_entities(geo.gfilter(msp))

    # remove all mappings for which validate() returns False
    msp_proxy.filter(validate)

Interface to GDAL/OGR
---------------------

The GDAL/OGR package has no direct support for the ``__geo_interface__``, but
has builtin support for the GeoJSON format:

.. code-block:: python

    from osgeo import ogr
    from ezdxf.addons import geo
    from ezdxf.render import random_2d_path
    import json

    p = geo.GeoProxy({'type': 'LineString', 'coordinates': list(random_2d_path(20))})
    # Create a GeoJSON string from the __geo_interface__ object by the json
    # module and feed the result into ogr:
    line_string = ogr.CreateGeometryFromJson(json.dumps(p.__geo_interface__))

    # Parse the GeoJSON string from ogr by the json module and feed the result
    # into a GeoProxy() object:
    p2 = geo.GeoProxy.parse(json.loads(line_string.ExportToJson()))

--- End of file: tutorials/geo.rst ---



--- Start of file: tutorials/getting_data.rst ---

.. _tut_getting_data:

Tutorial for Getting Data from DXF Files
========================================

This tutorial shows how to get data from an existing DXF document.
If you are a new user of `ezdxf`, read also the tutorial :ref:`arch-usr`.

Loading the DXF file:

.. code-block:: Python

    import sys
    import ezdxf

    try:
        doc = ezdxf.readfile("your_dxf_file.dxf")
    except IOError:
        print(f"Not a DXF file or a generic I/O error.")
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f"Invalid or corrupted DXF file.")
        sys.exit(2)

This works well for DXF files from trusted sources like AutoCAD or BricsCAD,
for loading DXF files with minor or major flaws look at the
:mod:`ezdxf.recover` module.

.. seealso::

    - :ref:`dwgmanagement`
    - :ref:`arch-usr`

Layouts
-------

The term layout is used as a synonym for an arbitrary entity space which can contain
DXF entities like LINE, CIRCLE, TEXT and so on. Each DXF entity can only reside
in exact one layout.

There are three different layout types:

- :class:`~ezdxf.layouts.Modelspace`: the common construction space
- :class:`~ezdxf.layouts.Paperspace`: used to to create print layouts
- :class:`~ezdxf.layouts.BlockLayout`: reusable elements, every block has its
  own entity space

A DXF document consist of exact one modelspace and at least one paperspace.
DXF R12 has only one unnamed paperspace the later DXF versions support more than
one paperspace and each paperspace has a name.

Getting the modelspace layout
-----------------------------

The modelspace contains the "real" world representation of the drawing subjects
in real world units. The modelspace has the fixed name "Model" and the DXF document
has a special getter method :meth:`~ezdxf.document.Drawing.modelspace`.

.. code:: Python

    msp = doc.modelspace()

Iterate over DXF entities of a layout
-------------------------------------

This code shows how to iterate over all DXF entities in modelspace:

.. code-block:: Python

    # helper function
    def print_entity(e):
        print("LINE on layer: %s\n" % e.dxf.layer)
        print("start point: %s\n" % e.dxf.start)
        print("end point: %s\n" % e.dxf.end)

    # iterate over all entities in modelspace
    msp = doc.modelspace()
    for e in msp:
        if e.dxftype() == "LINE":
            print_entity(e)

    # entity query for all LINE entities in modelspace
    for e in msp.query("LINE"):
        print_entity(e)


All layout objects supports the standard Python iterator protocol and the
``in`` operator.

Access DXF attributes of an entity
----------------------------------

The :meth:`e.dxftype` method returns the DXF type, the DXF type is always an
uppercase string like ``"LINE"``. All DXF attributes of an entity are grouped in
the namespace attribute :attr:`~ezdxf.entities.dxfentity.DXFEntity.dxf`:

.. code-block:: Python

    e.dxf.layer  # layer of the entity as string
    e.dxf.color  # color of the entity as integer

See :ref:`Common graphical DXF attributes`


If a DXF attribute is not set (the DXF attribute does not exist), a
:class:`DXFValueError` will be raised. The :meth:`get` method returns a default
value in this case or ``None`` if no default value is specified:

.. code-block:: Python

    # If DXF attribute 'paperspace' does not exist, the entity defaults
    # to modelspace:
    p = e.dxf.get("paperspace", 0)

or check beforehand if the attribute exist:

.. code-block:: Python

    if e.dxf.hasattr("paperspace"):
        ...

An unsupported DXF attribute raises a :class:`DXFAttributeError`, to check if
an attribute is supported by an entity use:

.. code-block:: Python

    if e.dxf.is_supported("paperspace"):
        ...

Getting a paperspace layout
---------------------------

.. code:: Python

    paperspace = doc.paperspace("layout0")

The code above retrieves the paperspace named ``layout0``, the usage of the
:class:`~ezdxf.layouts.Paperspace` object is the same as of the modelspace object.
DXF R12 provides only one paperspace, therefore the paperspace name in the
method call :code:`doc.paperspace("layout0")` is ignored or can be left off.
For newer DXF versions you can get a list of the available layout names
by the methods :meth:`~ezdxf.document.Drawing.layout_names` and
:meth:`~ezdxf.document.Drawing.layout_names_in_taborder`.

.. _entity queries:

Retrieve entities by query language
-----------------------------------

`Ezdxf` provides a flexible query language for DXF entities.
All layout types have a :meth:`~ezdxf.layouts.BaseLayout.query` method to start
an entity query or use the :meth:`ezdxf.query.new` function.

The query string is the combination of two queries, first the required entity
query and second the optional attribute query, enclosed in square brackets:
``"EntityQuery[AttributeQuery]"``

The entity query is a whitespace separated list of DXF entity names or the
special name ``*``. Where ``*`` means all DXF entities, all DXF names
have to be uppercase. The ``*`` search can exclude entity types by adding the
entity name with a preceding ``!`` (e.g. ``* !LINE``, search all entities except
lines).

The attribute query is used to select DXF entities by its DXF attributes. The
attribute query is an addition to the entity query and matches only if the
entity already match the entity query. The attribute query is a
boolean expression, supported operators: ``and``, ``or``, ``!``.

.. seealso::

    :ref:`entity query string`

Get all LINE entities from the modelspace:

.. code-block:: Python

    msp = doc.modelspace()
    lines = msp.query("LINE")

The result container :class:`~ezdxf.query.EntityQuery` also provides the
:meth:`query()` method to further refine the query, such as retrieving all
LINE entities at layer ``construction``:

.. code-block:: Python

    construction_lines = lines.query('*[layer=="construction"]')

The ``*`` is a wildcard for all DXF types, in this case you could also use
``LINE`` instead of ``*``, ``*`` works here because the source just contains
LINE entities.

This could be executed as a single query:

.. code-block:: Python

    lines = msp.query('LINE[layer=="construction"]')

An advanced query for getting all modelspace entities at layer ``construction``,
but excluding entities with linetype ``DASHED``:

.. code-block:: Python

    not_dashed_entities = msp.query('*[layer=="construction" and linetype!="DASHED"]')

Extended EntityQuery Features
-----------------------------

The :class:`~ezdxf.query.EntityQuery` class has properties and overloaded
operators to build extended queries by Python features instead of a query
string.

Same task as in the previous section but using features of the
:class:`~ezdxf.query.EntityQuery` container:

.. code-block:: Python

    # The overloaded rational operators return an EntityQuery object and not a bool value!
    lines = msp.query("LINES").layer == "construction"
    not_dashed_lines = lines.linetype != "DASHED"

.. seealso::

    :ref:`extended query features`

.. _using_groupby:

Retrieve entities by groupby() function
---------------------------------------

The :func:`~ezdxf.groupby.groupby` function searches and group entities by a
user defined criteria.  As an example let's group all entities from modelspace
by layer, the result will be a `dict` with layer names as dict-key and a list of
all entities from the modelspace matching this layer as dict-value:

.. code-block:: Python

    from ezdxf.groupby import groupby
    group = groupby(entities=msp, dxfattrib="layer")

The `entities` argument can be any container or generator which yields
DXF entities:

.. code-block:: Python

    group = msp.groupby(dxfattrib="layer")

    for layer, entities in group.items():
        print(f'Layer "{layer}" contains following entities:')
        for entity in entities:
            print(f"    {entity}")
        print("-"*40)

The previous example shows how to group entities by a single DXF attribute.
For a more advanced query create a custom key function, which accepts a DXF
entity as argument and returns a hashable value as dict-key or ``None`` to
exclude the entity.

The following example shows how to group entities by layer and color,
the dict-key is a ``(layer, color)`` tuple and the dict-value is a list of
entities with matching DXF attributes:

.. code-block:: Python

    def layer_and_color_key(entity):
        # return None to exclude entities from the result container
        if entity.dxf.layer == "0":  # exclude entities from default layer "0"
            return None
        else:
            return entity.dxf.layer, entity.dxf.color

    group = msp.groupby(key=layer_and_color_key)
    for key, entities in group.items():
        print(f'Grouping criteria "{key}" matches following entities:')
        for entity in entities:
            print(f"    {entity}")
        print("-"*40)

The :func:`~ezdxf.groupby.groupby` function catches :class:`DXFAttributeError`
exceptions while processing entities and excludes this entities from the result.
There is no need to worry about DXF entities which do not support certain
attributes, they will be excluded automatically.

.. seealso::

    :func:`~ezdxf.groupby.groupby` documentation



--- End of file: tutorials/getting_data.rst ---



--- Start of file: tutorials/hatch.rst ---

.. _tut_hatch:

Tutorial for Hatch
==================

Create hatches with one boundary path
-------------------------------------

The simplest form of the :class:`~ezdxf.entities.Hatch` entity has one polyline
path with only straight lines as boundary path:

.. literalinclude:: src/hatch/solid_hatch_polyline_path.py

But like all polyline entities the polyline path can also have bulge values:

.. literalinclude:: src/hatch/solid_hatch_polyline_path_with_bulge.py

The most flexible way to define a boundary path is the edge path. An edge path
can have multiple edges and each edge can be one of the following elements:

    - line :meth:`EdgePath.add_line`
    - arc :meth:`EdgePath.add_arc`
    - ellipse :meth:`EdgePath.add_ellipse`
    - spline :meth:`EdgePath.add_spline`

Create a solid hatch with an edge path (ellipse) as boundary path:

.. literalinclude:: src/hatch/solid_hatch_ellipse.py

Create hatches with multiple boundary paths (islands)
-----------------------------------------------------

The DXF attribute :attr:`hatch_style` defines the island detection style:

=== ========================================================
0   nested - altering filled and unfilled areas
1   outer - area between `external` and `outermost` path is filled
2   ignore - `external` path is filled
=== ========================================================

.. literalinclude:: src/hatch/solid_hatch_islands.py
    :lines: 11-27

This is also the result for all 4 paths and :attr:`hatch_style` set to ``2``
(ignore).

.. image:: gfx/hatch-island-01.png
    :align: center

.. literalinclude:: src/hatch/solid_hatch_islands.py
    :lines: 31-36

This is also the result for all 4 paths and :attr:`hatch_style` set to ``1``
(outer).

.. image:: gfx/hatch-island-02.png
    :align: center

.. literalinclude:: src/hatch/solid_hatch_islands.py
    :lines: 40-45

.. image:: gfx/hatch-island-03.png
    :align: center

.. literalinclude:: src/hatch/solid_hatch_islands.py
    :lines: 49-56

.. image:: gfx/hatch-island-04.png
    :align: center

The expected result of combinations of various :attr:`hatch_style` values and
paths `flags`, or the handling of overlapping paths is not documented by the
DXF reference, so don't ask me, ask Autodesk or just try it by yourself
and post your experience in the forum.

Example for Edge Path Boundary
------------------------------

.. literalinclude:: src/hatch/edge_path.py
    :lines: 8-56

.. image:: gfx/hatch-edge-path.png
    :align: center

Associative Boundary Paths
--------------------------

A HATCH entity can be associative to a base geometry, which means if the base
geometry is edited in a CAD application the HATCH get the same modification.
Because `ezdxf` is **not** a CAD application, this association is **not**
maintained nor verified by `ezdxf`, so if you modify the base geometry
afterwards the geometry of the boundary path is not updated and no verification
is done to check if the associated geometry matches the boundary path, this
opens many possibilities to create invalid DXF files: USE WITH CARE.

This example associates a LWPOLYLINE entity to the hatch created from the
LWPOLYLINE vertices:

.. literalinclude:: src/hatch/assoc_hatch.py
    :lines: 8-24

An :class:`EdgePath` needs associations to all geometry entities forming the
boundary path.

Predefined Hatch Pattern
------------------------

Use predefined hatch pattern by name:

.. code-block:: Python

    hatch.set_pattern_fill("ANSI31", scale=0.5)


.. image:: gfx/hatch-predefined-pattern.png
    :align: center

Load Hatch Patterns From File
-----------------------------

CAD applications store the hatch patterns in pattern files with the file extension 
``.pat``. The following script shows how to load and use these pattern files:

.. code-block:: Python

    from ezdxf.tools import pattern

    EXAMPLE = """; a pattern file

    *SOLID, Solid fill
    45, 0,0, 0,.125
    *ANSI31, ANSI Iron, Brick, Stone masonry
    45, 0,0, 0,.125
    *ANSI32, ANSI Steel
    45, 0,0, 0,.375
    45, .176776695,0, 0,.375
    *ANSI33, ANSI Bronze, Brass, Copper
    45, 0,0, 0,.25
    45, .176776695,0, 0,.25, .125,-.0625
    *ANSI34, ANSI Plastic, Rubber
    45, 0,0, 0,.75
    45, .176776695,0, 0,.75
    45, .353553391,0, 0,.75
    45, .530330086,0, 0,.75
    """

    hatch = msp.add_hatch()
    # load your pattern file from the file system as string:
    # with open("pattern_file.pat", "rt") as fp:
    #      EXAMPLE = fp.read()
    patterns = pattern.parse(EXAMPLE)

    hatch.set_pattern_fill(
        "MyPattern",
        color=7,
        angle=0,  # the overall rotation of the pattern in degrees
        scale=1.0,  # overall scaling of the pattern
        style=0,  # normal hatching style
        pattern_type=0,  # user-defined
        # pattern name without the preceding asterisk
        definition=patterns["ANSI34"],  
    )
    points = [(0, 0), (10, 0), (10, 10), (0, 10)]
    hatch.paths.add_polyline_path(points)
    msp.add_lwpolyline(points, close=True, dxfattribs={"color": 1})


.. seealso::

    :ref:`tut_hatch_pattern`


--- End of file: tutorials/hatch.rst ---



--- Start of file: tutorials/hatch_pattern.rst ---

.. _tut_hatch_pattern:

Tutorial for Hatch Pattern Definition
=====================================

A hatch pattern consist of one or more hatch lines. A hatch line defines a set
of lines which have the same orientation an the same line pattern. All the
lines defined by a hatch line are parallel and have a constant distance to each
other. The `origin` defines the start point of the hatch line and also the
starting point of the line pattern. The `direction` defines the angle between
the :ref:`WCS` x-axis and the hatch line. The `offset` is a 2D vector which will
be added consecutively the the origin for each new hatch line. The line pattern
has the same format as as the simple linetype pattern (:ref:`tut_linetypes`).

.. important::

    The hatch pattern must be defined for a hatch scaling factor of 1.0 and a
    hatch rotation angle of 0 degrees!

The first example creates a simple pattern of horizontal solid lines with a
vertical distance of 0.5 drawing units.

.. code-block:: Python

    import ezdxf

    doc = ezdxf.new("R2010")
    msp = doc.modelspace()
    hatch = msp.add_hatch()
    hatch.set_pattern_fill(
        "MyPattern",
        color=7,
        angle=0,
        scale=1.0,
        style=0,  # normal hatching style
        pattern_type=0,  # user-defined
        # pattern definition as list of:
        # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
        # line pattern is a solid line
        definition=[[0, (0, 0), (0, 0.5), []]],

    )
    points = [(0, 0), (10, 0), (10, 10), (0, 10)]
    hatch.paths.add_polyline_path(points)
    msp.add_lwpolyline(points, close=True, dxfattribs={"color": 1})
    doc.saveas("user_defined_hatch_pattern.dxf")

.. image:: gfx/hatch_pattern_1.png
    :align: center

The next example shows how the `offset` value works:

.. code-block:: Python

    # -x-x-x- snip -x-x-x-
    hatch = msp.add_hatch()
    hatch.set_pattern_fill(
        "MyPattern",
        color=7,
        angle=0,
        scale=1.0,
        style=0,  # normal hatching style
        pattern_type=0,  # user-defined
        # the line pattern is a dashed line:  - - - -
        # the offset is 1 unit vertical and 0.3 units horizontal
        # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
        definition=[[0, (0, 0), (0.3, 1), [1, -1]]],

    )
    # -x-x-x- snip -x-x-x-

.. image:: gfx/hatch_pattern_2.png
    :align: center

The next example combines two parallel hatch lines, the origin defines how
the hatch lines are offset from each other:

.. code-block:: Python

    # -x-x-x- snip -x-x-x-
    hatch = msp.add_hatch()
    hatch.set_pattern_fill(
        "MyPattern",
        color=7,
        angle=0,
        scale=1.0,
        style=0,  # normal hatching style
        pattern_type=0,  # user-defined
        # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
        definition=[
            [0, (0, 0), (0.3, 1), [1, -1]],  # dashed line
            [0, (0, 0.5), (0, 1), []],  # solid line
        ],
    )
    # -x-x-x- snip -x-x-x-

.. image:: gfx/hatch_pattern_3.png
    :align: center

The next example combines two hatch lines with different angles.
The origins can be the same for this example. The :class:`Vec2` class is used to
calculate the offset value for a normal distance of 0.7 drawing units between
the slanted lines:

.. code-block:: Python

    from ezdxf.math import Vec2

    # -x-x-x- snip -x-x-x-
    hatch = msp.add_hatch()
    # offset vector for a normal distance of 0.7 for a 45 deg slanted hatch line
    offset = Vec2.from_deg_angle(45 + 90, length=0.7)
    hatch.set_pattern_fill(
        "MyPattern",
        color=7,
        angle=0,
        scale=1.0,
        style=0,  # normal hatching style
        pattern_type=0,  # user-defined
        # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
        definition=[
            [0, (0, 0), (0, 1), [1, -1]],  # horizontal dashed line
            [45, (0, 0), offset, []],  # slanted solid line
        ],
    )
    # -x-x-x- snip -x-x-x-

.. image:: gfx/hatch_pattern_4.png
    :align: center


--- End of file: tutorials/hatch_pattern.rst ---



--- Start of file: tutorials/image.rst ---

.. _tut_image:

Tutorial for Image and ImageDef
===============================

This example shows how to use a raster image in a DXF document.
Each IMAGE entity requires an associated IMAGEDEF entity in the objects
section, which stores the filename of the linked image and the size in pixels.
Multiple IMAGE entities can share the same IMAGEDEF entity.

.. important::

    The raster image is NOT embedded in the DXF file!

.. code-block:: Python

    import ezdxf

    # The IMAGE entity requires the DXF R2000 format or later.
    doc = ezdxf.new("R2000")

    # The IMAGEDEF entity is like a block definition, it just defines the image.
    my_image_def = doc.add_image_def(
        filename="mycat.jpg", size_in_pixel=(640, 360)
    )


    msp = doc.modelspace()
    # The IMAGE entity is like the INSERT entity, it's just an image reference,
    # and there can be multiple references to the same picture in a DXF document.

    # 1st image reference
    msp.add_image(
        insert=(2, 1),
        size_in_units=(6.4, 3.6),
        image_def=my_image_def,
        rotation=0
    )
    # 2nd image reference
    msp.add_image(
        insert=(4, 5),
        size_in_units=(3.2, 1.8),
        image_def=my_image_def,
        rotation=30
    )

    # Get existing image definitions from the OBJECTS section:
    image_defs = doc.objects.query("IMAGEDEF")

    doc.saveas("dxf_with_cat.dxf")



--- End of file: tutorials/image.rst ---



--- Start of file: tutorials/image_export.rst ---

.. _tut_image_export:

Tutorial for Image Export
=========================

.. contents::
    :local:

Introduction
------------

This tutorial shows how to export DXF content of the modelspace or a paperspace as
images by the :mod:`~ezdxf.addons.drawing` add-on.

The tutorial covers the new added backends in `ezdxf` version 1.1:

- :class:`ezdxf.addons.drawing.svg.SVGBackend` class for SVG export
- :class:`ezdxf.addons.drawing.pymupdf.PyMuPdfBackend` class for PDF and PNG export
- :class:`ezdxf.addons.drawing.hpgl2.PlotterBackend` class for PLT/HPGL2 export
- :class:`ezdxf.addons.drawing.dxf.DXFBackend` class for flattened DXF export

The tutorial **does not cover** the :class:`~ezdxf.addons.drawing.matplotlib.MatplotlibBackend`
and :class:`~ezdxf.addons.drawing.pyqt.PyQtBackend`, for information about these
backends see:

- Howtos for the :ref:`how_to_drawing_addon`
- FAQs at github: https://github.com/mozman/ezdxf/discussions/550

Common Basics
-------------

The rendering process is divided into multiple steps. The frontend resolves the DXF
properties and breaks down complex DXF entities into simple drawing primitives which
are send to the backend that renders the output format.

.. literalinclude:: src/export/basic_svg.py
    :lines: 4-

The exported SVG shows a spiral centered on an A4 page with a margin of 20mm, notice
the background has a dark color like the usual background of the modelspace:

.. image:: gfx/image_export_01.png
    :align: center


Frontend Configuration
~~~~~~~~~~~~~~~~~~~~~~

The :class:`~ezdxf.addons.drawing.config.Configuration` object configures the rendering
process. This example changes the background color from dark grey to white and renders
all lines black.

Add the :mod:`config` module to imports:

.. literalinclude:: src/export/change_bg_color.py
    :lines: 5

Create a new configuration and override the background and color policy between the
2nd and the 3rd step:

.. literalinclude:: src/export/change_bg_color.py
    :lines: 31-39

The new exported SVG has a white background and all lines are black:

.. image:: gfx/image_export_02.png
    :align: center

There are many configuration options:

    - :class:`~ezdxf.addons.drawing.config.LineweightPolicy` - relative, absolute or relative fixed lineweight
    - :class:`~ezdxf.addons.drawing.config.LinePolicy` - solid or accurate linetypes
    - :class:`~ezdxf.addons.drawing.config.HatchPolicy` - normal, ignore, only outlines or always solid fill
    - :class:`~ezdxf.addons.drawing.config.ColorPolicy` - color, black, white, monochrome, ...
    - :class:`~ezdxf.addons.drawing.config.BackgroundPolicy` - default, black, white, off (transparent) and custom
    - :class:`~ezdxf.addons.drawing.config.TextPolicy` - filling, outline, ignore, ...
    - :class:`~ezdxf.addons.drawing.config.ProxyGraphicPolicy` - ignore, show, prefer
    - lineweight scaling factor
    - minimal lineweight
    - `max_flattening_distance` for curve approximation
    - and more ...

All configuration options are documented here: :class:`~ezdxf.addons.drawing.config.Configuration`.

Page Layout
~~~~~~~~~~~

The :class:`~ezdxf.addons.drawing.layout.Page` object defines the output page for some
backends (SVG, PDF, PNG, PLT).

A page is defined by width and height in a given length unit. The supported length
units are millimeters (mm), inch (in), point (1 pt is 1/72 in) and pixels (1 px is 1/96
in).

It's possible to autodetect the page size from the content or fit the content onto the
page. In both cases the margin values are used to create space between the content and
the page borders. The content is centered in the remaining space without margins.

.. important::

    None of the backends crop the content automatically, the margin values are just
    calculation values!

Autodetect Page Size
~~~~~~~~~~~~~~~~~~~~

The required page size is auto-detected by setting the width and/or height to 0.
By default the scaling factor is 1, so 1 drawing unit is 1 page unit.
The content is fit to page by default and the outcome is shown in the previous examples.

This example shows the output when the scale should be 1:1, 1 drawing unit is 1 page
unit (mm):

.. literalinclude:: src/export/page_auto_detect.py
    :lines: 44-49

The page has a size of 14x14mm, a content size of 10x10mm and 2mm margins on all sides.

.. image:: gfx/image_export_03.png
    :align: center

Scaling Content
~~~~~~~~~~~~~~~

Scaling the content by factor 10 means, 10 page units represent 1 drawing unit, which is
a scale of 10:1 and only uniform scaling is supported.

.. literalinclude:: src/export/page_auto_detect.py
    :lines: 54-59

The page has a size of 104x104mm, a content size of 100x100mm and 2mm margins on all
sides.

.. image:: gfx/image_export_04.png
    :align: center

Limit Page Size
~~~~~~~~~~~~~~~

The page arguments `max_width` and `max_height` can limit the page size in
auto-detection mode, e.g. most plotter devices can only print upto a width of 900mm.

.. seealso::

    - :class:`~ezdxf.addons.drawing.layout.Page` class
    - :class:`~ezdxf.addons.drawing.layout.Margins` class
    - :class:`~ezdxf.addons.drawing.layout.Settings` class


SVG Export
----------

The steps to export a SVG by the :class:`~ezdxf.addons.drawing.svg.SVGBackend` are show
in the first example, the configuration of the frontend and the page setup are shown in
the previous sections.

    1. Create the render context
    2. Create the backend
    3. Create and configure the frontend
    4. Draw the content
    5. Setup the page layout
    6. Create the SVG output string

This is the same code as for the first example:

.. literalinclude:: src/export/basic_svg.py
    :lines: 27-42

The SVG backend flips the coordinates along the y-axis and transforms the content into a
compact integer coordinate space and produces therefore a small file size but therefore
the output coordinates are different to the DXF coordinates.

PDF Export
----------

The PDF export requires the the `PyMuPdf`_ package to be installed.

The steps to export a PDF are very similar to SVG, except for the
:class:`~ezdxf.addons.drawing.pymupdf.PyMuPdfBackend` class and the backend returns bytes
and not a string:

    1. Create the render context
    2. Create the backend
    3. Create and configure the frontend
    4. Draw the content
    5. Setup the page layout
    6. Create the SVG output string

Import the :mod:`pymupdf` backend module:

.. literalinclude:: src/export/basic_pdf.py
    :lines: 5

The export function:

.. literalinclude:: src/export/basic_pdf.py
    :lines: 28-43

.. image:: gfx/image_export_pdf_01.png
    :align: center

The PDF has is dark background for the modelspace by default and color index 7 is white.
Create a frontend configuration and override the :class:`BackgroundPolicy` to get a
white background:

.. literalinclude:: src/export/basic_pdf.py
    :lines: 52-54

Now the exported PDF has a white background and color index 7 is black:

.. image:: gfx/image_export_pdf_02.png
    :align: center


PNG Export
----------

The PNG export is done by the :class:`~ezdxf.addons.drawing.pymupdf.PyMuPdfBackend`
class and differs only in the method to get the PNG data bytes:

.. literalinclude:: src/export/basic_png.py
    :lines: 59-62

The :mod:`pymupdf` backend supports multiple image formats:

=== =========================
png Portable Network Graphics
ppm Portable Pixmap (no alpha channel)
pbm Portable Bitmap (no alpha channel)
=== =========================

PLT/HPGL2 Export
----------------

The :class:`~ezdxf.addons.drawing.hpgl2.PlotterBackend` creates HPGL/2 plot files for
output on raster plotters. The :class:`PlotterBackend` is designed to print on white
paper, so the background color is always white and color index 7 is black by default.

.. warning::

    The plot files are only tested by the plot file viewer `ViewCompanion Standard`_
    but not on real hardware - please use with care and give feedback.

The PLT/HPGL2 export is very similar to the SVG export:

.. literalinclude:: src/export/basic_plt.py
    :lines: 5-7, 29-44

.. image:: gfx/image_export_plt_01.png
    :align: center

The HPGL/2 viewer does not show the margins around the content, but most construction
drawings draw the page borders around the content.

The :class:`PlotterBackend` has some quality preset methods to get the HPGL/2 data:

- :meth:`~ezdxf.addons.drawing.hpgl2.PlotterBackend.compatible`
- :meth:`~ezdxf.addons.drawing.hpgl2.PlotterBackend.low_quality`
- :meth:`~ezdxf.addons.drawing.hpgl2.PlotterBackend.normal_quality` (default)
- :meth:`~ezdxf.addons.drawing.hpgl2.PlotterBackend.high_quality`

The difference are mostly the floating point precision and the usage of Bzier curves,
but the Bzier curves are approximated by plotter drivers (even by HP drivers), so there
is no real quality improvement, but curves need less space than approximated polylines
so the file size is smaller.

Very old plotter may not support Bzier curves and floating point coordinates, for these
plotters the :meth:`compatible` method exports only polylines and integer coordinates.

Usage::

    # 6. get the HPGL2 rendering as bytes
    plt_bytes = backend.high_quality(page)

DXF Export
----------

The :class:`~ezdxf.addons.drawing.dxf.DXFBackend` exports the content as DXF primitives:
POINT, LINE, LWPOLYLINE, SPLINE and HATCH. All blocks are exploded, text is
rendered as filled polygons represented by the HATCH entity and arcs are represented by
SPLINE entities (internal Bzier curve representation).

This backend was added to convert HPGL/2 files to DXF files, because the
:mod:`hpgl2` add-on reuses the backends of the :mod:`drawing` add-on for export.
Maybe it is useful for other tasks too.

This backend works different than the previous. There is no page setup and everything
is rendered into a given layout of a DXF document:

.. literalinclude:: src/export/basic_dxf.py
    :lines: 5-7, 28-40


Recorder Backend
----------------

The :class:`~ezdxf.addons.drawing.recorder.Recorder` backend is an intermediate layer to
record the drawing commands of the :class:`~ezdxf.addons.drawing.frontend.Frontend` class.
The :class:`~ezdxf.addons.drawing.recorder.Player` object can replay this records on any
other backend class but also provides some additional features like bounding box
detection, content transformation and cropping.

The SVG/PDF/PLT backends use this intermediate layer internally to transform and place
the content.

.. _PyMuPdf: https://pypi.org/project/PyMuPDF/
.. _ViewCompanion Standard: http://www.softwarecompanions.com/


--- End of file: tutorials/image_export.rst ---



--- Start of file: tutorials/index.rst ---

.. _tutorials:


Tutorials
=========

.. toctree::
    :maxdepth: 1

    getting_data
    simple_drawings
    common_graphical_attributes
    layers
    linetypes
    dxf_primitives
    entity_selection
    blocks
    lwpolyline
    text
    mtext
    spline
    polyface
    mesh
    hatch
    hatch_pattern
    image
    underlay
    mleader
    psp_viewports
    ocs_usage
    ucs_transform
    linear_dimension
    radius_dimension
    diameter_dimension
    angular_dimension
    arc_dimension
    ordinate_dimension
    geo
    custom_data
    xref_module
    image_export
    edges


--- End of file: tutorials/index.rst ---



--- Start of file: tutorials/layers.rst ---

.. _tut_layers:

Tutorial for Layers
===================

If you are not familiar with the concept of layers, please read this first:
Concept of :ref:`layer_concept`

Reminder: a layer definition is not required for using a layer!

Create a Layer Definition
-------------------------

.. code-block:: python

    import ezdxf

    doc = ezdxf.new(setup=True)  # setup required line types
    msp = doc.modelspace()
    doc.layers.add(name="MyLines", color=7, linetype="DASHED")

The advantage of assigning a linetype and a color to a layer is that entities
on this layer can inherit this properties by using ``"BYLAYER"`` as linetype
string and ``256`` as color, both values are default values for new entities
so you can leave off these assignments:

.. code-block:: python

    msp.add_line((0, 0), (10, 0), dxfattribs={"layer": "MyLines"})

The new created line will be drawn with color ``7`` and linetype ``"DASHED"``.

Moving an Entity to a Different Layer
-------------------------------------

Moving an entity to a different layer is a simple assignment of the new
layer name to the :attr:`layer` attribute of the entity.

.. code-block:: python

    line = msp.add_line((0, 0), (10, 0), dxfattribs={"layer": "MyLines"})
    # move the entity to layer "OtherLayer"
    line.dxf.layer = "OtherLayer"

Changing Layer State
--------------------

Get the layer definition object from the layer table:

.. code-block:: python

    my_lines = doc.layers.get('MyLines')

Check the state of the layer:

.. code-block:: python

    my_lines.is_off()  # True if layer is off
    my_lines.is_on()   # True if layer is on
    my_lines.is_locked()  # True if layer is locked
    layer_name = my_lines.dxf.name  # get the layer name

Change the state of the layer:

.. code-block:: python

    # switch layer off, entities at this layer will not shown in CAD applications/viewers
    my_lines.off()

    # lock layer, entities at this layer are not editable in CAD applications
    my_lines.lock()

Get/set the color of a layer by property :attr:`Layer.color`, because the
DXF attribute :attr:`Layer.dxf.color` is misused for switching the layer on and
off, the layer is off if the color value is negative.

Changing the layer properties:

.. code-block:: python

    my_lines.dxf.linetype = "DOTTED"
    my_lines.color = 13  # preserves on/off state of layer

.. seealso::

    For all methods and attributes see class :class:`~ezdxf.entities.Layer`.

Check Available Layers
----------------------

The :class:`~ezdxf.sections.table.LayerTable` object supports some standard
Python protocols:

.. code-block:: python

    # iteration
    for layer in doc.layers:
        if layer.dxf.name != "0":
            layer.off()  # switch all layers off except layer "0"

    # check for existing layer definition
    if "MyLines" in doc.layers:
        layer = doc.layers.get("MyLines")

    layer_count = len(doc.layers) # total count of layer definitions

Renaming a Layer
----------------

The :class:`~ezdxf.entities.Layer` class has a method for renaming the layer,
but has same limitations, not all places where layer references can occur are
documented, third-party entities are black-boxes with unknown content and layer
references could be stored in the extended data section of any DXF entity or in
a XRECORD entity, so some references may reference a non-existing layer
definition after the renaming, at least these references are still valid,
because a layer definition is not required for using a layer.

.. code-block:: python

    my_lines = doc.layers.get("MyLines")
    my_lines.rename("YourLines")


Deleting a Layer Definition
---------------------------

Delete a layer definition:

.. code-block:: python

    doc.layers.remove("MyLines")

This just deletes the layer definition, all DXF entities referencing this layer
still exist, if they inherit any properties from the deleted layer they will now
get the default layer properties.

.. warning::

    The behavior of entities referencing the layer by handle is unknown and may
    break the DXF document.

Deleting All Entities From a Layer
----------------------------------

Because of all these uncertainties about layer references mentioned above,
deleting all entities referencing a certain layer from a DXF document is not
implemented as an API call!

Nonetheless deleting all graphical entities from the DXF document which do
reference a certain layer by the :attr:`layer` attribute is a safe procedure:

.. code-block:: python

    key_func = doc.layers.key
    layer_key = key_func("MyLines")
    # The trashcan context-manager is a safe way to delete entities from the
    # entities database while iterating.
    with doc.entitydb.trashcan() as trash:
        for entity in doc.entitydb.values():
            if not entity.dxf.hasattr("layer"):
                continue
            if layer_key == key_func(entity.dxf.layer):
                # safe destruction while iterating
                trash.add(entity.dxf.handle)


--- End of file: tutorials/layers.rst ---



--- Start of file: tutorials/linear_dimension.rst ---

.. _tut_linear_dimension:

Tutorial for Linear Dimensions
==============================

The :class:`~ezdxf.entities.Dimension` entity is the generic entity for all
dimension types, but unfortunately AutoCAD is **not willing** to show a
dimension line defined only by this dimension entity, it also needs an anonymous
block which contains the dimension line shape constructed by DXF primitives
like LINE and TEXT entities, this representation is called the dimension line
`rendering` in this documentation, beside the fact that this is not a real
graphical rendering.  BricsCAD is a much more friendly CAD application, which
do show the dimension entity without the graphical rendering as block, which was
very useful for testing, because there is no documentation how to apply all the
dimension style variables (more than 80).
This seems to be the reason why dimension lines are rendered so differently by
many CAD application.

Don't expect to get the same rendering results by `ezdxf` as you get from
AutoCAD. `Ezdxf` tries to be as close to the results rendered by BricsCAD, but
it is not possible to implement all the various combinations of dimension style
parameters, which often affect one another.

.. note::

    `Ezdxf` does not consider all DIMSTYLE variables, so the
    rendering results are different from CAD applications.

Text rendering is another problem, because `ezdxf` has no real rendering engine.
Some font properties, like the real text width, which is only available to
`ezdxf` if the `Matplotlib` package is installed and this value may also vary
slightly for different CAD applications.  Without access to the `Matplotlib`
package the text properties in `ezdxf` are based on an abstract monospaced font
and are bigger than required by true type fonts.

Not all DIMENSION and DIMSTYLE features are supported by all DXF versions,
especially DXF R12 does not support many features, but in this case the required
rendering of dimension lines is an advantage, because if the application just
shows the rendered block, all features which can be used in DXF R12 will be
displayed, but these features will disappear if the dimension line will be
edited in the CAD application. `Ezdxf` writes only the supported DIMVARS of the
used DXF version to avoid invalid DXF files. So it is not that critical to know
all the supported features of a DXF version, except for limits and tolerances,
`ezdxf` uses the advanced features of the MTEXT entity to create limits and
tolerances and therefore they are not supported (displayed) in DXF R12 files.

.. seealso::

    - Graphical reference of many DIMVARS and some advanced information:
      :ref:`dimstyle_table_internals`
    - Source code file `standards.py`_ shows how to create your own DIMSTYLES.
    - The Script `dimension_linear.py`_ shows examples for linear dimensions.

Horizontal Dimension
--------------------

.. code-block:: Python

    import ezdxf

    # Create a DXF R2010 document:
    # Use argument setup=True to setup the default dimension styles.
    doc = ezdxf.new("R2010", setup=True)

    # Add new dimension entities to the modelspace:
    msp = doc.modelspace()

    # Add a LINE entity for visualization, not required to create the DIMENSION
    # entity:
    msp.add_line((0, 0), (3, 0))

    # Add a horizontal linear DIMENSION entity:
    dim = msp.add_linear_dim(
        base=(3, 2),  # location of the dimension line
        p1=(0, 0),  # 1st measurement point
        p2=(3, 0),  # 2nd measurement point
        dimstyle="EZDXF",  # default dimension style
    )

    # Necessary second step to create the BLOCK entity with the dimension geometry.
    # Additional processing of the DIMENSION entity could happen between adding
    # the entity and the rendering call.
    dim.render()
    doc.saveas("dim_linear_horiz.dxf")

.. image:: gfx/dim_linear_horiz.png


The example above creates a horizontal :class:`~ezdxf.entities.Dimension` entity.
The default dimension style "EZDXF" is defined as:

- 1 drawing unit = 1m
- measurement text height = 0.25 (drawing scale = 1:100)
- the length factor :attr:`dimlfac` = 100, which creates a measurement text in cm.
- arrow is "ARCHTICK", arrow size :attr:`dimasz` = 0.175

Every dimension style which does not exist will be replaced by the dimension
style "Standard" at DXF export by :meth:`save` or :meth:`saveas`
(e.g. dimension style setup was not initiated).

The `base` point defines the location of the dimension line, `ezdxf` accepts any
point on the dimension line, the point `p1` defines the start point of the
first extension line, which also defines the first measurement point and the
point `p2` defines the start point of the second extension line, which also
defines the second measurement point.

The return value `dim` is **not** a dimension entity, instead a
:class:`~ezdxf.entities.DimStyleOverride` object is returned, the dimension
entity is stored as attribute :attr:`dim.dimension`.

Vertical and Rotated Dimension
------------------------------

Argument `angle` defines the angle of the dimension line in relation to the
x-axis of the WCS or UCS, measurement is the distance between first and second
measurement point in direction of `angle`.

.. code-block:: Python

    # assignment to dim is not necessary, if no additional processing happens
    msp.add_linear_dim(base=(3, 2), p1=(0, 0), p2=(3, 0), angle=-30).render()
    doc.saveas("dim_linear_rotated.dxf")

.. image:: gfx/dim_linear_rotated.png

For a vertical dimension set argument `angle` to 90 degree, but in this example
the vertical distance would be 0.

Aligned Dimension
-----------------

An aligned dimension line is parallel to the line defined by the definition
points `p1` and `p2`. The placement of the dimension line is defined by the
argument `distance`, which is the distance between the definition line and the
dimension line. The `distance` of the dimension line is orthogonal to the base
line in counter clockwise orientation.

.. code-block:: Python

    msp.add_line((0, 2), (3, 0))
    dim = msp.add_aligned_dim(p1=(0, 2), p2=(3, 0), distance=1)
    doc.saveas("dim_linear_aligned.dxf")

.. image:: gfx/dim_linear_aligned.png

Dimension Style Override
------------------------

Many dimension styling options are defined by the associated
:class:`~ezdxf.entities.DimStyle` entity.
But often you wanna change just a few settings without creating a new dimension
style, therefore the DXF format has a protocol to store this changed settings
in the dimension entity itself.
This protocol is supported by `ezdxf` and every factory function which creates
dimension entities supports the `override` argument.
This `override` argument is a simple Python dictionary (e.g.
:code:`override = {"dimtad": 4}`, place measurement text below dimension line).

The overriding protocol is managed by the :class:`~ezdxf.entities.DimStyleOverride`
object, which is returned by the most dimension factory functions.

Placing Measurement Text
------------------------

The default location of the measurement text depends on various
:class:`~ezdxf.entities.DimStyle` parameters and is applied if no user defined
text location is defined.

Default Text Locations
~~~~~~~~~~~~~~~~~~~~~~

"Horizontal direction" means in direction of the dimension line and "vertical
direction" means perpendicular to the dimension line direction.

The **"horizontal"** location of the measurement text is defined by
:attr:`~ezdxf.entities.DimStyle.dxf.dimjust`:

=== =====
0   Center of dimension line
1   Left side of the dimension line, near first extension line
2   Right side of the dimension line, near second extension line
3   Over first extension line
4   Over second extension line
=== =====

.. code-block:: Python

    msp.add_linear_dim(
        base=(3, 2), p1=(0, 0), p2=(3, 0), override={"dimjust": 1}
    ).render()

.. image:: gfx/dim_linear_dimjust.png

The **"vertical"** location of the measurement text relative to the dimension
line is defined by :attr:`~ezdxf.entities.DimStyle.dxf.dimtad`:

=== =====
0   Center, it is possible to adjust the vertical location by
    :attr:`~ezdxf.entities.DimStyle.dxf.dimtvp`
1   Above
2   Outside, handled like `Above` by `ezdxf`
3   JIS, handled like `Above` by `ezdxf`
4   Below
=== =====

.. code-block:: Python

    msp.add_linear_dim(
        base=(3, 2), p1=(0, 0), p2=(3, 0), override={"dimtad": 4}
    ).render()

.. image:: gfx/dim_linear_dimtad.png

The distance between text and dimension line is defined by
:attr:`~ezdxf.entities.DimStyle.dxf.dimgap`.

The :class:`~ezdxf.entities.DimStyleOverride` object has a method
:meth:`~ezdxf.entities.DimStyleOverride.set_text_align` to set the default text
location in an easy way, this is also the reason for the 2 step creation process
of dimension entities:

.. code-block:: Python

    dim = msp.add_linear_dim(base=(3, 2), p1=(0, 0), p2=(3, 0))
    dim.set_text_align(halign="left", valign="center")
    dim.render()

====== =====
halign "left", "right", "center", "above1", "above2"
valign "above", "center", "below"
====== =====

Run function :func:`example_for_all_text_placings_R2007` in the example script
`dimension_linear.py`_ to create a DXF file with all text placings supported by
`ezdxf`.

User Defined Text Locations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Beside the default location, it is possible to locate the measurement text freely.

Location Relative to Origin
+++++++++++++++++++++++++++

The user defined text location can be set by the argument `location` in most
dimension factory functions and always references the midpoint of the
measurement text:

.. code-block:: Python

    msp.add_linear_dim(
        base=(3, 2), p1=(3, 0), p2=(6, 0), location=(4, 4)
    ).render()

.. image:: gfx/dim_linear_user_location_absolute.png

The `location` is relative to the origin of the active coordinate system or
WCS if no UCS is defined in the :meth:`~ezdxf.entities.DimStyleOverride.render`
method, the user defined `location` can also be set by
:meth:`~ezdxf.entities.DimStyleOverride.user_location_override`.

Location Relative to Center of Dimension Line
+++++++++++++++++++++++++++++++++++++++++++++

The method :meth:`~ezdxf.entities.DimStyleOverride.set_location` has additional
features for linear dimensions.
Argument `leader` = ``True`` adds a simple leader from the measurement text to
the center of the dimension line and argument `relative` = ``True`` places the
measurement text relative to the center of the dimension line.

.. code-block:: Python

    dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
    dim.set_location(location=(-1, 1), leader=True, relative=True)
    dim.render()

.. image:: gfx/dim_linear_user_location_relative.png

Location Relative to Default Location
+++++++++++++++++++++++++++++++++++++

The method :meth:`~ezdxf.entities.DimStyleOverride.shift_text` shifts the
measurement text away from the default text location. The shifting directions
are aligned to the text direction, which is the direction of the dimension line
in most cases, `dh` (for delta horizontal) shifts the text parallel to the text
direction, `dv` (for delta vertical) shifts the text perpendicular to the text
direction. This method does not support leaders.

.. code-block:: Python

    dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
    dim.shift_text(dh=1, dv=1)
    dim.render()

.. image:: gfx/dim_linear_user_location_shift.png

Overriding Text Rotation
++++++++++++++++++++++++

All factory methods supporting the argument `text_rotation` can override the
measurement text rotation.
The user defined rotation is relative to the render UCS x-axis (default is WCS).

.. _tut_measurement_text_formatting_and_styling:

Measurement Text Formatting and Styling
---------------------------------------

Text Properties
~~~~~~~~~~~~~~~

=================== ===========================================
DIMVAR              Description
=================== ===========================================
:attr:`dimtxsty`    Specifies the text style of the dimension as
                    :class:`~ezdxf.entities.Textstyle` name.
:attr:`dimtxt`      Text height in drawing units.
:attr:`dimclrt`     Measurement text color as :ref:`ACI`.
=================== ===========================================

.. code-block:: Python

    msp.add_linear_dim(
        base=(3, 2),
        p1=(3, 0),
        p2=(6, 0),
        override={
            "dimtxsty": "Standard",
            "dimtxt": 0.35,
            "dimclrt": 1,
        }
    ).render()

.. image:: gfx/dim_linear_text.png


Background Filling
~~~~~~~~~~~~~~~~~~

Background fillings are supported since DXF R2007, and `ezdxf` uses the MTEXT
entity to implement this feature, so setting background filling in DXF R12 has
no effect. The DIMVAR :attr:`~ezdxf.entities.DimStyle.dxf.dimtfill` defines the
kind of background filling and the DIMVAR :attr:`~ezdxf.entities.DimStyle.dxf.dimtfillclr`
defines the fill color.

=================== ====================================================
DIMVAR              Description
=================== ====================================================
:attr:`dimtfill`    Enables background filling if bigger than 0
:attr:`dimtfillclr` Fill color as :ref:`ACI`, if :attr:`dimtfill` is 2
=================== ====================================================

=================== ====================================================
:attr:`dimtfill`    Description
=================== ====================================================
0                   disabled
1                   canvas color
2                   color defined by :attr:`dimtfillclr`
=================== ====================================================

.. code-block:: Python

    msp.add_linear_dim(
        base=(3, 2),
        p1=(3, 0),
        p2=(6, 0),
        override={
            "dimtfill": 2,
            "dimtfillclr": 1,
        }
    ).render()

.. image:: gfx/dim_linear_bg_filling.png

Text Formatting
~~~~~~~~~~~~~~~

- **decimal places**: :attr:`~ezdxf.entities.DimStyle.dxf.dimdec` defines the
  number of decimal places displayed for the primary units of a dimension. (DXF R2000)
- **decimal point character**: :attr:`~ezdxf.entities.DimStyle.dxf.dimdsep`
  defines the decimal point as ASCII code, get the ASCII code by :code:`ord('.')`
- **rounding**: :attr:`~ezdxf.entities.DimStyle.dxf.dimrnd`, rounds all
  dimensioning distances to the specified value, for instance, if :attr:`dimrnd`
  is set to 0.25, all distances round to the nearest 0.25 unit. If :attr:`dimrnd`
  is set to 1.0, all distances round to the nearest integer. For more information
  look at the documentation of the :func:`ezdxf.math.xround` function.
- **zero trimming**: :attr:`~ezdxf.entities.DimStyle.dxf.dimzin`, `ezdxf`
  supports only a subset of values:

    - 4 to suppress leading zeros
    - 8 to suppress trailing zeros
    - 12 as the combination of both

- **measurement factor**: scale measurement by factor
  :attr:`~ezdxf.entities.DimStyle.dxf.dimlfac`, e.g. to get the dimensioning
  text in cm for a DXF file where 1 drawing unit represents 1m, set
  :attr:`dimlfac` to 100.
- **text template**: :attr:`~ezdxf.entities.DimStyle.dxf.dimpost`,
  "<>" represents the measurement text, e.g. "~<>cm" produces "~300cm" for
  measurement in previous example.

To set this values the :meth:`ezdxf.entities.DimStyle.set_text_format` and
:meth:`ezdxf.entities.DimStyleOverride.set_text_format` methods are very
recommended.

.. _tut_overriding_measurement_text:

Overriding Measurement Text
---------------------------

This feature allows overriding the real measurement text by a custom
measurement text, the text is stored as string in the
:class:`~ezdxf.entities.Dimension` entity as attribute
:attr:`~ezdxf.entities.Dimension.dxf.text`.
Special values of the :attr:`text` attribute are: one space " " to suppress the
measurement text at all, an empty string ""  or "<>" to display the real
measurement.

All factory functions have an explicit `text` argument, which always replaces
the `text` value in the `dxfattribs` dict.

.. code-block:: Python

    msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0), text=">1m").render()

.. image:: gfx/dim_linear_text_override.png

.. _tut_dimension_line_properties:

Dimension Line Properties
-------------------------

The *dimension line color* is defined by the DIMVAR :attr:`dimclrd` as :ref:`ACI`,
:attr:`dimclrd` and also defines the color of the arrows. The *linetype* is
defined by :attr:`dimltype` and requires DXF R2007. The *lineweight* is defined
by :attr:`dimlwd` and requires DXF R2000, see also the
:attr:`~ezdxf.entities.DXFGraphic.dxf.lineweight` reference for valid values.
The :attr:`dimdle` is the extension of the dimension line beyond the extension
lines, this dimension line extension is not supported for all arrows.

=================== ==============================================================================
DIMVAR              Description
=================== ==============================================================================
:attr:`dimclrd`     dimension line and arrows color as :ref:`ACI`
:attr:`dimltype`    linetype of dimension line
:attr:`dimlwd`      line weight of dimension line
:attr:`dimdle`      extension of dimension line in drawing units
=================== ==============================================================================

.. code-block:: Python

    msp.add_linear_dim(
        base=(3, 2),
        p1=(3, 0),
        p2=(6, 0),
        override={
            "dimclrd": 1,  # red
            "dimdle": 0.25,
            "dimltype": "DASHED2",
            "dimlwd": 35,  # 0.35mm line weight
        }
    ).render()

.. image:: gfx/dim_linear_dimline_properties.png

:meth:`~ezdxf.entities.DimStyleOverride` method:

.. code-block:: Python

    dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
    dim.set_dimline_format(
        color=1, linetype="DASHED2", lineweight=35, extension=0.25
    )
    dim.render()

.. _tut_extension_line_properties:

Extension Line Properties
-------------------------

The *extension line color* is defined by the DIMVAR :attr:`dimclre` as :ref:`ACI`.
The *linetype* for the first and the second extension line is defined by
:attr:`dimltex1` and :attr:`dimltex2` and requires DXF R2007.
The *lineweight* is defined by :attr:`dimlwe` and required DXF R2000, see also
the :attr:`~ezdxf.entities.DXFGraphic.dxf.lineweight` reference for valid
values.

The :attr:`dimexe` is the extension of the extension line beyond the dimension
line, and :attr:`dimexo` defines the offset of the extension line from the
measurement point.

=================== ============================================================
DIMVAR              Description
=================== ============================================================
:attr:`dimclre`     extension line color as :ref:`ACI`
:attr:`dimltex1`    linetype of first extension line
:attr:`dimltex2`    linetype of second extension line
:attr:`dimlwe`      line weight of extension line
:attr:`dimexe`      extension beyond dimension line in drawing units
:attr:`dimexo`      offset of extension line from measurement point
:attr:`dimfxlon`    set to 1 to enable fixed length extension line
:attr:`dimfxl`      length of fixed length extension line in drawing units
:attr:`dimse1`      suppress first extension line if 1
:attr:`dimse2`      suppress second extension line if 1
=================== ============================================================

.. code-block:: Python

    msp.add_linear_dim(
        base=(3, 2),
        p1=(3, 0),
        p2=(6, 0),
        override={
            "dimclre": 1,   # red
            "dimltex1": "DASHED2",
            "dimltex2": "CENTER2",
            "dimlwe": 35,   # 0.35mm line weight
            "dimexe": 0.3,  # length above dimension line
            "dimexo": 0.1,  # offset from measurement point
        }
    ).render()

.. image:: gfx/dim_linear_extline_properties.png

:meth:`~ezdxf.entities.DimStyleOverride` methods:

.. code-block:: Python

    dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
    dim.set_extline_format(color=1, lineweight=35, extension=0.3, offset=0.1)
    dim.set_extline1(linetype="DASHED2")
    dim.set_extline2(linetype="CENTER2")
    dim.render()

Fixed length extension lines are supported in DXF R2007, set :attr:`dimfxlon`
to 1 and :attr:`dimfxl` defines the length of the extension line starting at the
dimension line.

.. code-block:: Python

    msp.add_linear_dim(
        base=(3, 2),
        p1=(3, 0),
        p2=(6, 0),
        override={
            "dimfxlon": 1,  # fixed length extension lines
            "dimexe": 0.2,  # length above dimension line
            "dimfxl": 0.4,  # length below dimension line
        }
    ).render()

.. image:: gfx/dim_linear_extline_dimfxl.png

:meth:`~ezdxf.entities.DimStyleOverride` method:

.. code-block:: Python

    dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
    dim.set_extline_format(extension=0.2, fixed_length=0.4)
    dim.render()

To suppress extension lines set :attr:`dimse1` to 1 to suppress the first
extension line and :attr:`dimse2` to 1 to suppress the second extension line.

.. code-block:: Python

    msp.add_linear_dim(
        base=(3, 2),
        p1=(3, 0),
        p2=(6, 0),
        override={
            "dimse1": 1,  # suppress first extension line
            "dimse2": 1,  # suppress second extension line
            "dimblk": ezdxf.ARROWS.closed_filled,  # arrows just looks better
        }
    ).render()

.. image:: gfx/dim_linear_extline_suppress.png

:meth:`~ezdxf.entities.DimStyleOverride` methods:

.. code-block:: Python

    dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
    dim.set_arrows(blk=ezdxf.ARROWS.closed_filled)
    dim.set_extline1(disable=True)
    dim.set_extline2(disable=True)
    dim.render()

.. _tut_arrows:

Arrows
------

"Arrows" mark then beginning and the end of a dimension line, and most of them
do not look like arrows.

DXF distinguish between the simple tick (a slanted line) and arrows as blocks.

To use a simple tick as "arrow" set :attr:`~ezdxf.entities.DimStyle.dxf.dimtsz`
to a value greater than 0, this also disables arrow blocks as side effect:

.. code-block:: Python

    dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
    dim.set_tick(size=0.25)
    dim.render()

`Ezdxf` uses the "ARCHTICK" block at double size to render the tick (AutoCAD and
BricsCad just draw a simple line), so there is no advantage of using the tick
instead of an arrow.

Using arrows:

.. code-block:: Python

    dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
    dim.set_arrow(blk="OPEN_30", size=0.25)
    dim.render()


=================== ============================================================
DIMVAR              Description
=================== ============================================================
:attr:`dimtsz`      tick size in drawing units, set to 0 to use arrows
:attr:`dimblk`      set both arrow block names at once
:attr:`dimblk1`     first arrow block name
:attr:`dimblk2`     second arrow block name
:attr:`dimasz`      arrow size in drawing units
=================== ============================================================

.. code-block:: Python

    msp.add_linear_dim(
        base=(3, 2),
        p1=(3, 0),
        p2=(6, 0),
        override={
            "dimtsz": 0,  # set tick size to 0 to enable arrow usage
            "dimasz": 0.25,  # arrow size in drawing units
            "dimblk": "OPEN_30",  # arrow block name
        }
    ).render()

The dimension line extension (:attr:`dimdle`) works only for a few arrow
blocks and the simple tick:

- "ARCHTICK"
- "OBLIQUE"
- "NONE"
- "SMALL"
- "DOTSMALL"
- "INTEGRAL"

Arrow Shapes
~~~~~~~~~~~~

.. image:: gfx/all_arrows.png

Arrow Names
~~~~~~~~~~~

The arrow names are stored as attributes in the :code:`ezdxf.ARROWS` object.

=========================== ========================
closed_filled               "" (empty string)
dot                         "DOT"
dot_small                   "DOTSMALL"
dot_blank                   "DOTBLANK"
origin_indicator            "ORIGIN"
origin_indicator_2          "ORIGIN2"
open                        "OPEN"
right_angle                 "OPEN90"
open_30                     "OPEN30"
closed                      "CLOSED"
dot_smallblank              "SMALL"
none                        "NONE"
oblique                     "OBLIQUE"
box_filled                  "BOXFILLED"
box                         "BOXBLANK"
closed_blank                "CLOSEDBLANK"
datum_triangle_filled       "DATUMFILLED"
datum_triangle              "DATUMBLANK"
integral                    "INTEGRAL"
architectural_tick          "ARCHTICK"
ez_arrow                    "EZ_ARROW"
ez_arrow_blank              "EZ_ARROW_BLANK"
ez_arrow_filled             "EZ_ARROW_FILLED"
=========================== ========================

.. _tut_tolerances_and_limits:

Tolerances and Limits
---------------------

The tolerances and limits features are implemented by using inline codes for
the :class:`~ezdxf.entities.MText` entity, therefore DXF R2000 is required.
It is not possible to use both tolerances and limits at the same time.

Tolerances
~~~~~~~~~~

Geometrical tolerances are shown as additional text appended to the measurement
text. It is recommend to use :meth:`~ezdxf.entities.DimStyleOverride.set_tolerance`
method in :class:`~ezdxf.entities.DimStyleOverride` or :class:`~ezdxf.entities.DimStyle`.

The attribute :attr:`dimtp` defines the upper tolerance value, :attr:`dimtm`
defines the lower tolerance value if present, else the lower tolerance value is
the same as the upper tolerance value. Tolerance values are shown as given!

Same upper and lower tolerance value:

.. code-block:: python

    dim = msp.add_linear_dim(base=(0, 3), p1=(3, 0), p2=(6.5, 0))
    dim.set_tolerance(.1, hfactor=.4, align="top", dec=2)
    dim.render()

.. image:: gfx/dim_linear_tol.png

Different upper and lower tolerance values:

.. code-block:: python

    dim = msp.add_linear_dim(base=(0, 3), p1=(3, 0), p2=(6.5, 0))
    dim.set_tolerance(upper=.1, lower=.15, hfactor=.4, align="middle", dec=2)
    dim.render()

.. image:: gfx/dim_linear_tol_upr_lwr.png

The attribute :attr:`dimtfac` specifies a scale factor for the text height of
limits and tolerance values relative to the dimension text height, as set by
:attr:`dimtxt`. For example, if :attr:`dimtfac` is set to 1.0, the text height
of fractions and tolerances is the same height as the dimension text.
If :attr:`dimtxt` is set to 0.75, the text height of limits and tolerances is
three-quarters the size of dimension text.

Vertical justification for tolerances is specified by :attr:`dimtolj`:

=================== ====================================================
:attr:`dimtolj`     Description
=================== ====================================================
0                   Align with bottom line of dimension text
1                   Align vertical centered to dimension text
2                   Align with top line of dimension text
=================== ====================================================

=================== ====================================================
DIMVAR              Description
=================== ====================================================
:attr:`dimtol`      set to 1 to enable tolerances
:attr:`dimtp`       set the maximum (or upper) tolerance limit for dimension text
:attr:`dimtm`       set the minimum (or lower) tolerance limit for dimension text
:attr:`dimtfac`     specifies a scale factor for the text height of limits and tolerance values
                    relative to the dimension text height, as set by :attr:`dimtxt`.
:attr:`dimtzin`     4 to suppress leading zeros, 8 to suppress trailing zeros or 12 to
                    suppress both, like :attr:`dimzin` for dimension text, see also `Text Formatting`_
:attr:`dimtolj`     set the vertical justification for tolerance values relative to the nominal
                    dimension text.
:attr:`dimtdec`     set the number of decimal places to display in tolerance values
=================== ====================================================

Limits
~~~~~~

The geometrical limits are shown as upper and lower measurement limit and
replaces the usual measurement text. It is recommend to use
:meth:`~ezdxf.entities.DimStyleOverride.set_limits` method in
:class:`~ezdxf.entities.DimStyleOverride` or :class:`~ezdxf.entities.DimStyle`.

For limits the tolerance values are drawing units scaled by measurement factor
:attr:`dimlfac`, the upper limit is scaled measurement value + :attr:`dimtp` and
the lower limit is scaled measurement value - :attr:`dimtm`.

The attributes :attr:`dimtfac`, :attr:`dimtzin` and :attr:`dimtdec` have the
same meaning for limits as for tolerances.

.. code-block:: python

    dim = msp.add_linear_dim(base=(0, 3), p1=(3, 0), p2=(6.5, 0))
    dim.set_limits(upper=.1, lower=.15, hfactor=.4, dec=2)
    dim.render()

.. image:: gfx/dim_linear_limits.png

=================== ==============================
DIMVAR              Description
=================== ==============================
:attr:`dimlim`      set to 1 to enable limits
=================== ==============================

Alternative Units
-----------------

Alternative units are not supported.


.. _dimension_linear.py:  https://github.com/mozman/ezdxf/blob/master/examples/render/dimension_linear.py
.. _standards.py: https://github.com/mozman/ezdxf/blob/master/src/ezdxf/tools/standards.py

--- End of file: tutorials/linear_dimension.rst ---



--- Start of file: tutorials/linetypes.rst ---

.. _tut_linetypes:

Tutorial for Creating Linetype Pattern
======================================

Simple line type example:

.. image:: gfx/ltype_simple.jpg

You can define your own linetypes. A linetype definition has a name,
a description and line pattern elements:

.. code-block:: python

    elements = [total_pattern_length, elem1, elem2, ...]

total_pattern_length
    Sum of all linetype elements (absolute values)

elem
    if elem > 0 it is a line, if elem < 0 it is gap, if elem == 0.0 it is a dot

Create a new linetype definition:

.. code-block:: python

    import ezdxf
    from ezdxf.tools.standards import linetypes  # some predefined linetypes

    doc = ezdxf.new()
    msp = doc.modelspace()

    my_line_types = [
        (
            "DOTTED",
            "Dotted .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .",
            [0.2, 0.0, -0.2],
        ),
        (
            "DOTTEDX2",
            "Dotted (2x) .    .    .    .    .    .    .    . ",
            [0.4, 0.0, -0.4],
        ),
        (
            "DOTTED2",
            "Dotted (.5) . . . . . . . . . . . . . . . . . . . ",
            [0.1, 0.0, -0.1],
        ),
    ]
    for name, desc, pattern in my_line_types:
        if name not in doc.linetypes:
            doc.linetypes.add(
                name=name,
                pattern=pattern,
                description=desc,
            )

Setup some predefined linetypes:

.. code-block:: python

    for name, desc, pattern in linetypes():
        if name not in doc.linetypes:
            doc.linetypes.add(
                name=name,
                pattern= pattern,
                description=desc,
            )

Check Available Linetypes
-------------------------

The linetypes object supports some standard Python protocols:

.. code-block:: python


    # iteration
    print("available linetypes:")
    for lt in doc.linetypes:
        print(f"{lt.dxf.name}: {lt.dxf.description}")

    # check for existing linetype
    if "DOTTED" in doc.linetypes:
        pass

    count = len(doc.linetypes) # total count of linetypes

Removing Linetypes
------------------

.. warning::

    Ezdxf does not check if a linetype is still in use and deleting a linetype
    which is still in use generates an **invalid** DXF file. The audit process
    :meth:`~ezdxf.document.Drawing.audit()` of the DXF document removes
    :attr:`linetype` attributes referencing non existing linetypes.

You can delete a linetype:

.. code-block:: python

    doc.layers.remove("DASHED")

This just removes the linetype definition, the :attr:`linetype` attribute of DXF
entities may still refer the removed linetype definition "DASHED" and AutoCAD
will not open DXF files including undefined linetypes.

Tutorial for Creating Complex Linetype Pattern
==============================================

In DXF R13 Autodesk introduced complex linetypes, containing TEXT or SHAPES in
line types.

Complex linetype example with text:

.. image:: gfx/ltype_text.jpg

Complex line type example with shapes:

.. image:: gfx/ltype_shape.jpg


For easy usage the pattern string for complex line types is mostly the same
string as the pattern definition strings in AutoCAD ".lin" files.

Example for complex line type TEXT:

.. code-block:: python

    doc = ezdxf.new("R2018")  # DXF R13 or later is required

    doc.linetypes.add(
        name="GASLEITUNG2",
        # linetype definition string from acad.lin:
        pattern='A,.5,-.2,["GAS",STANDARD,S=.1,U=0.0,X=-0.1,Y=-.05],-.25',
        description= "Gasleitung2 ----GAS----GAS----GAS----GAS----GAS----",
        length=1,  # required for complex line types
    })


The pattern always starts with an "A", the following float values have the same
meaning as for simple linetypes, a value > 0 is a line, a value < 0 is a gap,
and a 0 is a point, the opening square bracket "[" starts the complex part of
the linetype pattern.

The text after the "[" defines the complex linetype:

- A text in quotes (e.g. "GAS") defines a *complex TEXT linetype* and represents
  the pattern text itself.
- A text without quotes is a SHAPE name (in ".lin" files) and defines a
  *complex SHAPE linetype. Ezdxf can not translate this SHAPE name from the
  ".lin" file into the required shape file index, so *YOU* have to translate
  this SHAPE name into the shape file index, e.g. saving the file with AutoCAD
  as DXF and searching for the DXF linetype definition, see example below and
  the DXF Internals: :ref:`ltype_table_internals`.

For *complex TEXT linetypes* the second parameter is the text style,
for *complex SHAPE linetypes* the second parameter is the shape file name,
the shape file has to be in the same directory as the DXF file or in one of the
CAD application support paths.

The meaning of the following comple linetype parameters are shown in the table
below:

======= ===================================================================
 S      scaling factor, always > 0, if S=0 the TEXT or SHAPE is not visible
 R or U rotation relative to the line direction
 X      x-direction offset (along the line)
 Y      y-direction offset (perpendicular to the line)
======= ===================================================================

These parameters are case insensitive and the closing square bracket "]" ends
the complex part of the linetype pattern.

The fine tuning of this parameters is a try an error process, for
*complex TEXT linetypes* the scaling factor (e.g. the STANDARD text style) sets
the text height (e.g. "S=0.1" sets the text height to 0.1 units), by shifting in
y-direction by half of the scaling factor, the text is vertically centered to
the line. For the x-direction it seems to be a good practice to place a gap in
front of the text and after the text, find x shifting value and gap sizes by
try and error. The overall length is at least the sum of all line and gap
definitions (absolute values).

Example for complex line type SHAPE:

.. code-block:: python

    doc.linetypes.add("GRENZE2",
        # linetype definition in acad.lin:
        # A,.25,-.1,[BOX,ltypeshp.shx,x=-.1,s=.1],-.1,1
        # replacing BOX by shape index 132 (got index from an AutoCAD file),
        # ezdxf can't get shape index from ltypeshp.shx
        pattern="A,.25,-.1,[132,ltypeshp.shx,x=-.1,s=.1],-.1,1",
        description="Grenze eckig ----[]-----[]----[]-----[]----[]--",
        length= 1.45,  # required for complex line types
    })

Complex line types with shapes only work if the associated shape file (e. g.
ltypeshp.shx) and the DXF file are in the same directory or the shape file is
placed in one of the CAD application support folders.



--- End of file: tutorials/linetypes.rst ---



--- Start of file: tutorials/lwpolyline.rst ---

.. _tut_lwpolyline:

Tutorial for LWPolyline
=======================

The :class:`~ezdxf.entities.LWPolyline` (lightweight polyline) was introduced in
DXF R13/14 and it is defined as a single graphic entity, which differs from the
old-style :class:`~ezdxf.entities.Polyline` entity, which is defined as a group
of sub-entities. It is recommended to prefer the LWPOLYLINE over the 2D POLYLINE
entity because it requires less space in memory and in DXF files and displays
faster in AutoCAD.

.. important::

    The LWPOLYLINE is a planar element, therefore the (x, y) point coordinates are
    located in the :ref:`OCS` and the z-axis is stored in the
    :attr:`LWPolyline.dxf.elevation` attribute.
    The method :class:`~ezdxf.entities.LWPolyline.vertices_in_wcs` returns the
    polyline vertices as WCS coordinates.

Create a simple polyline:

.. code-block:: python

    import ezdxf

    doc = ezdxf.new("R2000")
    msp = doc.modelspace()

    points = [(0, 0), (3, 0), (6, 3), (6, 6)]
    msp.add_lwpolyline(points)

    doc.saveas("lwpolyline1.dxf")


Append multiple points to a polyline:

.. code-block:: python

    doc = ezdxf.readfile("lwpolyline1.dxf")
    msp = doc.modelspace()

    line = msp.query("LWPOLYLINE").first
    if line is not None:
        line.append_points([(8, 7), (10, 7)])

    doc.saveas("lwpolyline2.dxf")

The index operator ``[]`` always returns polyline points as 5-tuple
(x, y, start_width, end_width, bulge), the start_width, end_width and
bulge values are 0 if not present:

.. code-block:: python

    first_point = line[0]
    x, y, start_width, end_width, bulge = first_point

The context manager :meth:`~ezdxf.entities.LWPolyline.points` can be used to edit
polyline points, this method was introduced because accessing individual
points was very slow in early versions of `ezdxf`, in current versions of `ezdxf` the
direct access by the index operator ``[]`` is very fast and using the context
manager is not required anymore, but the context manager still exist and has the
advantage of supporting an user defined point format:

.. code-block:: python

    doc = ezdxf.readfile("lwpolyline2.dxf")
    msp = doc.modelspace()

    line = msp.query("LWPOLYLINE").first

    with line.points("xyseb") as points:
        # points is a standard Python list
        # existing points are 5-tuples, but new points can be
        # set as (x, y, [start_width, [end_width, [bulge]]]) tuple
        # set start_width, end_width to 0 to be ignored (x, y, 0, 0, bulge).

        # delete last 2 points
        del points[-2:]
        # adding two points
        points.extend([(4, 7), (0, 7)])

    doc.saveas("lwpolyline3.dxf")

Each line segment can have a different start- and end width, if omitted start-
and end width is 0:

.. code-block:: python

    doc = ezdxf.new("R2000")
    msp = doc.modelspace()

    # point format = (x, y, [start_width, [end_width, [bulge]]])
    # set start_width, end_width to 0 to be ignored (x, y, 0, 0, bulge).

    points = [(0, 0, .1, .15), (3, 0, .2, .25), (6, 3, .3, .35), (6, 6)]
    msp.add_lwpolyline(points)

    doc.saveas("lwpolyline4.dxf")

The first point carries the start- and end-width of the first segment, the
second point of the second segment and so on, the start- and end width value
of the last point is used for the closing segment if the polyline is closed
else these values are ignored.
Start- and end width only works if the DXF attribute :attr:`dxf.const_width` is
unset, delete it to be sure it's unset:

.. code-block:: python

    # no exception will be raised if const_width is already unset:
    del line.dxf.const_width

:class:`LWPolyline` can also have curved elements, they are defined by the
:ref:`bulge value`:

.. code-block:: python

    doc = ezdxf.new("R2000")
    msp = doc.modelspace()

    # point format = (x, y, [start_width, [end_width, [bulge]]])
    # set start_width, end_width to 0 to be ignored (x, y, 0, 0, bulge).

    points = [(0, 0, 0, .05), (3, 0, .1, .2, -.5), (6, 0, .1, .05), (9, 0)]
    msp.add_lwpolyline(points)

    doc.saveas("lwpolyline5.dxf")

.. image:: gfx/LWPolyline5.PNG

The curved segment is drawn from the point which defines the *bulge* value to
the following point, the curved segment is always an arc. The bulge value
defines the ratio of the arc sagitta (segment height `h`) to half line segment
length (point distance), a bulge value of 1 defines a semicircle.
The curve is on the right side of the line for a bulge value > 0, and on the
left side of the line for a bulge value < 0.

Helper functions to handle bulge values: :ref:`bulge_related_functions`

The user defined point format, default is ``xyseb``:

    - ``x`` = x coordinate
    - ``y`` = y coordinate
    - ``s`` = start width
    - ``e`` = end width
    - ``b`` = bulge value
    - ``v`` = (x, y) as tuple

.. code-block:: python

    msp.add_lwpolyline([(0, 0, 0), (10, 0, 1), (20, 0, 0)], format="xyb")
    msp.add_lwpolyline([(0, 10, 0), (10, 10, .5), (20, 10, 0)], format="xyb")


.. image:: gfx/bulge.png


--- End of file: tutorials/lwpolyline.rst ---



--- Start of file: tutorials/mesh.rst ---

.. _tut_mesh:

Tutorial for Mesh
=================

The :class:`~ezdxf.entities.Mesh` entity is a 3D object in :ref:`WCS` build up
from vertices and faces.

Create a cube mesh by directly accessing the base data structures:

.. code-block:: python

    import ezdxf


    # 8 corner vertices
    cube_vertices = [
        (0, 0, 0),
        (1, 0, 0),
        (1, 1, 0),
        (0, 1, 0),
        (0, 0, 1),
        (1, 0, 1),
        (1, 1, 1),
        (0, 1, 1),
    ]

    # 6 cube faces
    cube_faces = [
        [0, 1, 2, 3],
        [4, 5, 6, 7],
        [0, 1, 5, 4],
        [1, 2, 6, 5],
        [3, 2, 6, 7],
        [0, 3, 7, 4]
    ]

    # MESH requires DXF R2000 or later
    doc = ezdxf.new("R2000")
    msp = doc.modelspace()
    mesh = msp.add_mesh()
    # do not subdivide cube, 0 is the default value
    mesh.dxf.subdivision_levels = 0
    with mesh.edit_data() as mesh_data:
        mesh_data.vertices = cube_vertices
        mesh_data.faces = cube_faces

    doc.saveas("cube_mesh_1.dxf")

Create a cube mesh by assembling single faces using the
:meth:`~ezdxf.entities.Mesh.edit_data()` context manager of the
:class:`~ezdxf.entities.Mesh` class and the helper class
:class:`~ezdxf.entities.MeshData`:

.. code-block:: python

    import ezdxf


    # 8 corner vertices
    p = [
        (0, 0, 0),
        (1, 0, 0),
        (1, 1, 0),
        (0, 1, 0),
        (0, 0, 1),
        (1, 0, 1),
        (1, 1, 1),
        (0, 1, 1),
    ]

    # MESH requires DXF R2000 or later
    doc = ezdxf.new("R2000")
    msp = doc.modelspace()
    mesh = msp.add_mesh()

    with mesh.edit_data() as mesh_data:
        mesh_data.add_face([p[0], p[1], p[2], p[3]])
        mesh_data.add_face([p[4], p[5], p[6], p[7]])
        mesh_data.add_face([p[0], p[1], p[5], p[4]])
        mesh_data.add_face([p[1], p[2], p[6], p[5]])
        mesh_data.add_face([p[3], p[2], p[6], p[7]])
        mesh_data.add_face([p[0], p[3], p[7], p[4]])
        # optional call optimize(): minimizes the vertex count
        mesh_data.optimize()

    doc.saveas("cube_mesh_2.dxf")

Its recommended to use the :class:`~ezdxf.render.MeshBuilder` objects to
create 3D meshes and render them as MESH entities by the
:meth:`~ezdxf.render.MeshBuilder.render_mesh` method into a layout:

.. code-block:: Python

        import ezdxf
        from ezdxf import colors
        from ezdxf.gfxattribs import GfxAttribs
        from ezdxf.render import forms

        cube = forms.cube().scale_uniform(10).subdivide(2)
        red = GfxAttribs(color=colors.RED)
        green = GfxAttribs(color=colors.GREEN)
        blue = GfxAttribs(color=colors.BLUE)

        doc = ezdxf.new()
        msp = doc.modelspace()

        # render as MESH entity
        cube.render_mesh(msp, dxfattribs=red)
        cube.translate(20)

        # render as POLYFACE a.k.a. POLYLINE entity
        cube.render_polyface(msp, dxfattribs=green)
        cube.translate(20)

        # render as a bunch of 3DFACE entities
        cube.render_3dfaces(msp, dxfattribs=blue)

        doc.saveas("meshes.dxf")

.. image:: gfx/mesh_cubes.png

There exist some tools to manage meshes:

- :class:`ezdxf.render.MeshBuilder`: The :class:`~ezdxf.render.MeshBuilder`
  classes are helper tools to manage meshes buildup by vertices and faces.
- :class:`ezdxf.render.MeshTransformer`: Same functionality as :class:`~ezdxf.render.MeshBuilder`
  but supports inplace transformation.
- :class:`ezdxf.render.MeshDiagnose`: A diagnose tool which can be used to
  analyze and detect errors of :class:`~ezdxf.render.MeshBuilder` objects
  like topology errors for closed surfaces.
- :class:`ezdxf.render.FaceOrientationDetector`: A helper class for face
  orientation and face normal vector detection

The :mod:`ezdxf.render.forms` module provides function to create basic
geometries like cube, cone, sphere and so on and functions to create meshes
from profiles by extrusion, rotation or sweeping.

This example shows how to sweep a gear profile along a helix:

.. code-block:: Python

    import ezdxf
    from ezdxf.render import forms

    doc = ezdxf.new()
    doc.layers.add("MESH", color=ezdxf.colors.YELLOW)
    msp = doc.modelspace()
    # sweeping a gear-profile
    gear = forms.gear(
        8, top_width=0.01, bottom_width=0.02, height=0.02, outside_radius=0.1
    )
    helix = path.helix(radius=2, pitch=1, turns=6)
    # along a helix spine
    sweeping_path = helix.flattening(0.1)
    mesh = forms.sweep(gear, sweeping_path, close=True, caps=True)
    # and render as MESH entity
    mesh.render_mesh(msp, dxfattribs={"layer": "MESH"})
    doc.saveas("gear_along_helix.dxf")

.. image:: gfx/gear_along_helix.png


--- End of file: tutorials/mesh.rst ---



--- Start of file: tutorials/mleader.rst ---

.. _tut_mleader:

Tutorial for MultiLeader
========================

A multileader object typically consists of an arrowhead, a horizontal landing
(a.k.a. "dogleg"), a leader line or curve, and either a MTEXT object or a BLOCK.

Factory methods of the :class:`~ezdxf.layouts.BaseLayout` class to create new
:class:`~ezdxf.entities.MultiLeader` entities:

    - :meth:`~ezdxf.layouts.BaseLayout.add_multileader_mtext`
    - :meth:`~ezdxf.layouts.BaseLayout.add_multileader_block`

Because of the complexity of the MULTILEADER entity, the factory method
:meth:`~ezdxf.layouts.BaseLayout.add_multileader_mtext` returns a
:class:`~ezdxf.render.MultiLeaderMTextBuilder` instance to build a new entity
and the factory method :meth:`~ezdxf.layouts.BaseLayout.add_multileader_block`
returns a :class:`~ezdxf.render.MultiLeaderBlockBuilder` instance.

Due of the lack of good documentation it's not possible to support all
combinations of MULTILEADER properties with decent quality, so stick to recipes
and hints shown in this tutorial to get usable results otherwise, you will enter
uncharted territory.

The rendering result of the MULTILEADER entity is highly dependent on the CAD
application. The MULTILEADER entity does not have a pre-rendered anonymous
block of DXF primitives like all DIMENSION entities, so results may vary
from CAD application to CAD application. The general support for this entity is
only good in Autodesk products other CAD applications often struggle when
rendering MULTILEADERS, even my preferred testing application BricsCAD has
rendering issues.

.. important::

    MULTILEADER support has flaws in many CAD applications except Autodesk
    products!


.. seealso::

    - :class:`ezdxf.render.MultiLeaderBuilder` classes
    - :class:`ezdxf.entities.MultiLeader` class
    - :class:`ezdxf.entities.MLeaderStyle` class
    - :class:`ezdxf.tools.text.MTextEditor` class
    - :ref:`mleader internals`

MTEXT Quick Draw
----------------

Full Python script: `mtext_quick_leader.py`_

The :meth:`quick_leader()` method of a MTEXT - MULTILEADER entity constructs the
geometry parameters in reverse manner, starting from a given target point:

DXF document setup:

.. literalinclude:: src/mleader/mtext_quick_leader.py
    :lines: 20-25

Draw a red circle to mark the target point:

.. literalinclude:: src/mleader/mtext_quick_leader.py
    :lines: 26-29

Create four horizontal placed MULTILEADER entities pointing at the target point,
the first segment of the leader line is determined by an angle in this example
pointing away from the target point:

.. literalinclude:: src/mleader/mtext_quick_leader.py
    :lines: 31-37

.. image:: gfx/mleader_mtext_quick_leader_0.png


The content is automatically aligned to the end of the leader line. The first
segment is a relative vector to the target point and the optional second segment
vector is relative to the end of the first segment.
The default connection type is horizontal but can be changed to vertical:

A smaller text size is required:

.. literalinclude:: src/mleader/mtext_quick_leader.py
    :lines: 45-47

Adding vertical placed MULTILEADER entities:

.. literalinclude:: src/mleader/mtext_quick_leader.py
    :lines: 54-61

This example already shows the limitation caused by different text renderings in
various CAD applications. The `ezdxf` text measurement by `matplotlib` is
different to AutoCAD and BricsCAD and the result is a misalignment of the
overline and the leader line.

The DXF file shown in BricsCAD:

.. image:: gfx/mleader_mtext_quick_leader_1.png

The same DXF file shown with the :code:`ezdxf view` command (drawing add-on):

.. image:: gfx/mleader_mtext_quick_leader_2.png


My advice is to avoid vertical placed MULTILEADER entities at all and for
horizontal placed MULTILEADER entities avoid styles including an "underline" or
an "overline".

The :meth:`quick_leader` method is not very customizable for ease of use, but
follows the settings of the associated :class:`~ezdxf.entities.MLeaderStyle`.

The following sections show how to have more control when adding MULTILEADER
entities.

Create MTEXT Content
--------------------

Full Python script: `mtext_content.py`_

This section shows how to create a MULTILEADER entity with MTEXT content
the manual way with full control over all settings.

For good results the MTEXT alignment should match the leader connection side,
e.g. if you attach leaders to the left side also align the MTEXT to the left side,
for leaders attached at the right side, align the MTEXT to the right side
and if you attach leaders at both sides one side will fit better than the other
or maybe a center aligned MTEXT is a good solution, for further details see
section `MTEXT Alignment`_.

The first example uses the default connection type of the MLEADERSTYLE
"Standard" which is "middle of the top line" for left and right attached
leaders. The render UCS for this example is the WCS to keep things simple.

Create a new MULTILEADER entity.

.. literalinclude:: src/mleader/mtext_content.py
    :lines: 24

Set MTEXT content, text style and alignment.

.. literalinclude:: src/mleader/mtext_content.py
    :lines: 25-29

Add the first leader on the left side.
The leader points always to the first given vertex and all vertices are given
in render UCS coordinates (= WCS in this example).

.. literalinclude:: src/mleader/mtext_content.py
    :lines: 30


More than one vertex per leader can be used:

.. literalinclude:: src/mleader/mtext_content.py
    :lines: 31-34

The insert point of the :meth:`build` method is the alignment point for the
MTEXT content.

.. literalinclude:: src/mleader/mtext_content.py
    :lines: 35

The "dogleg" settings are defined by the MLEADERSTYLE "Standard".

.. image:: gfx/mleader_mtext_left.png

This example shows a leader attached to the right side and the MTEXT aligned
to the right side.

.. literalinclude:: src/mleader/mtext_content.py
    :lines: 44-51

.. image:: gfx/mleader_mtext_right.png

This example shows two leaders attached to both sides and the MTEXT aligned
to the left side, which shows that the right landing gap (space between text and
start of vertex) is bigger than the gap on the left size. This is due to the
different text size calculations from AutoCAD/BricsCAD and Matplotlib.
The longer the text, the greater the error.

.. literalinclude:: src/mleader/mtext_content.py
    :lines: 60-68

.. image:: gfx/mleader_mtext_left_right_1.png

A centered MTEXT alignment gives a more even result.

.. literalinclude:: src/mleader/mtext_content.py
    :lines: 77-85

.. image:: gfx/mleader_mtext_left_right_2.png

But even this has its disadvantages, the attachment calculation is always based
on the bounding box of the MTEXT content.

.. image:: gfx/mleader_mtext_left_right_3.png


MTEXT Connection Types
~~~~~~~~~~~~~~~~~~~~~~

There are four connection sides defined by the enum
:class:`ezdxf.render.ConnectionSide`:

    - left
    - right
    - top
    - bottom

The MultiLeader entity supports as the name says multiple leader lines, but all
have to have a horizontal (left/right) connection side or a vertical (top/bottom)
connection side, it's not possible to mix left/right and top/bottom connection
sides. This is determined by the DXF format.

There are different connection types available for the horizontal and the
vertical connection sides. All leaders connecting to the same side have the
same connection type. The horizontal connection sides support following
connection types, defined by the enum :class:`ezdxf.render.HorizontalConnection`:

    - by_style
    - top_of_top_line
    - middle_of_top_line
    - middle_of_text
    - middle_of_bottom_line
    - bottom_of_bottom_line
    - bottom_of_bottom_line_underline (not recommended)
    - bottom_of_top_line_underline (not recommended)
    - bottom_of_top_line
    - bottom_of_top_line_underline_all (not recommended)

The vertical connection sides support following connection types, defined by the
enum :class:`ezdxf.render.VerticalConnection`:

    - by_style
    - center
    - center_overline (not recommended)

The connection type for each side can be set by the method
:meth:`~ezdxf.render.MultiLeaderBuilder.set_connection_types`, the default for all
sides is `by_style`:

.. literalinclude:: src/mleader/mtext_content.py
    :lines: 102-105

.. image:: gfx/mleader_mtext_horiz_connection_types.png

.. hint::

    As shown in the quick draw section using connection types including underlines
    or overlines do not render well in AutoCAD/BricsCAD because of the different
    text measurement of `matplotlib`, therefore it's not recommended to use any
    of these connection types when creating MULTILEADERS by `ezdxf`.

MTEXT Alignment
~~~~~~~~~~~~~~~

In contrast to the standalone MTEXT entity supports the MTEXT
content entity only three text alignments defined by the enum
:class:`ezdxf.render.TextAlignment`.

    - left
    - center
    - right

The MTEXT alignment is set as argument `alignment` of the
:meth:`~ezdxf.render.MultiLeaderBuilder.set_content` method and the alignment
point is the insert point of the :meth:`~ezdxf.render.MultiLeaderBuilder.build`
method.

Create BLOCK Content
--------------------

Full Python script: `block_content.py`_

This section shows how to create a MULTILEADER entity with BLOCK content
the manual way with full control over all settings.

The BLOCK content consist of a BLOCK layout and optional ATTDEF entities which
defines the location and DXF attributes of dynamically created ATTRIB entities.

Create the BLOCK content, the full :func:`create_square_block` function
can be found in the `block_content.py`_ script.

.. literalinclude:: src/mleader/block_content.py
    :lines: 72-74

Create the MULTILEADER and set the content:

.. literalinclude:: src/mleader/block_content.py
    :lines: 75-78

Set the BLOCK attribute content as text:

.. literalinclude:: src/mleader/block_content.py
    :lines: 79-80

Add some leader lines to the left and right side of the BLOCK:

Construction plane of the entity is defined by a render UCS.
The leader lines vertices are expected in render UCS coordinates, which
means relative to the UCS origin and this example shows the simple case
where the UCS is the WCS which is also the default setting.

.. literalinclude:: src/mleader/block_content.py
    :lines: 82-85

Last step is to build the final MULTILEADER entity.
This example uses the alignment type `insertion_point` where the insert point of
the :meth:`build` method is the base point of the BLOCK:

.. literalinclude:: src/mleader/block_content.py
    :lines: 87

.. image:: gfx/mleader_block_horiz_1.png

The result is shown in BricsCAD as expected, although BricsCAD shows
"Center extents" as attachment type in the properties dialog instead of the
correct attachment type "Insertion point".

BLOCK Connection Types
~~~~~~~~~~~~~~~~~~~~~~

There are four connection sides defined by the enum
:class:`ezdxf.render.ConnectionSide`:

    - left
    - right
    - top
    - bottom

The connection point for leader lines is always the center of the side of the
block bounding box the leader is connected to and has the same limitation as
for the MTEXT content, it's not possible to mix the connection sides left/right
and top/bottom.

The connection side is set when adding the leader line by the
:meth:`~ezdxf.render.MultiLeaderBuilder.add_leader_line` method.

Unfortunately BricsCAD has an error in version 22.2.03 and renders all connection
types as left/right, this is top/bottom connection shown in Autodesk TrueView 2022:

.. image:: gfx/mleader_block_vertical_1.png


The top/bottom connection type does not support the "dogleg" feature.

BLOCK Alignment
~~~~~~~~~~~~~~~

There are two alignments types, defined by the enum :class:`ezdxf.render.BlockAlignment`

    - center_extents
    - insertion_point

The alignment is set by the :meth:`~ezdxf.render.MultiLeaderBlockBuilder.set_content` method.

The alignment type `center_extent` inserts the BLOCK with the center of the
bounding box at the insert point of the :meth:`~ezdxf.render.MultiLeaderBuilder.build`
method. The insert point is (5, 2) in this example:

.. image:: gfx/mleader_block_horiz_2.png

The same MULTILEADER with alignment type `insert_point`:

.. image:: gfx/mleader_block_horiz_1.png

BLOCK Scaling
~~~~~~~~~~~~~

The BLOCK content can be scaled independently from the overall scaling of the
MULTILEADER entity:

The block scaling factor is set by the :meth:`~ezdxf.render.MultiLeaderBlockBuilder.set_content` method::

    ml_builder.set_content(
        name=block.name, scale=2.0, alignment=mleader.BlockAlignment.center_extents
    )


This is the first example with a block scaling factor of 2. The BLOCK and the
attached ATTRIB entities are scaled but not the arrows.

.. image:: gfx/mleader_block_horiz_3.png

BLOCK Rotation
~~~~~~~~~~~~~~

The rotation around the render UCS z-axis in degrees is applied by the
:meth:`~ezdxf.render.MultiLeaderBuilder.build` method::

    ml_builder.build(insert=Vec2(5, 2), rotation=30)

This is the first example with a rotation of 30 degrees. The BLOCK, the
attached ATTRIB entities and the last connection lines ("dogleg") are rotated.

.. image:: gfx/mleader_block_rotated.png

BLOCK Attributes
~~~~~~~~~~~~~~~~

BLOCK attributes are defined as ATTDEF entities in the BLOCK layout. This
ATTDEF entities will be replaced by ATTRIB entities at the rendering process
of the CAD application.
Only the text content and the text width factor can be changed for each
MULTILEADER entity individually by the :meth:`~ezdxf.render.MultiLeaderBlockBuilder.set_attribute`
method. The ATTDEF is addressed by it's DXF `tag` attribute::

    ml_builder.set_attribute("ONE", "Data1")
    ml_builder.set_attribute("TWO", "Data2")


Leader Properties
-----------------

"Dogleg" Properties
~~~~~~~~~~~~~~~~~~~

The "dogleg" is the last line segment from the last leader vertex
to the MULTILEADER content for polyline leaders.

.. image:: gfx/mleader_landing_props.png

The length of the dogleg and the landing gap size is set by the
:meth:`~ezdxf.render.MultiLeaderBuilder.set_connection_properties`.

Polyline Leader
~~~~~~~~~~~~~~~

A polygon leader line has only straight line segments and is added by the
:meth:`~ezdxf.render.MultiLeaderBuilder.add_leader_line`::

    ml_builder.add_leader_line(
        mleader.ConnectionSide.left,
        [Vec2(-20, 15), Vec2(-10, 15), Vec2(-15, 11), Vec2(-10, 7)],
    )

.. image:: gfx/mleader_polyline_leader.png

All leader line vertices have render UCS coordinates and the start- and
end-vertex of the "dogleg" is calculated automatically.

Spline Leader
~~~~~~~~~~~~~

A spline leader line has a single curved line as leader line and is also
added by the :meth:`~ezdxf.render.MultiLeaderBuilder.add_leader_line`.
This is spline leader has the same vertices as the previous created polyline
leader::

    ml_builder.set_leader_properties(leader_type=mleader.LeaderType.splines)
    ml_builder.add_leader_line(
        mleader.ConnectionSide.left,
        [Vec2(-20, 15), Vec2(-10, 15), Vec2(-15, 11), Vec2(-10, 7)],
    )

.. image:: gfx/mleader_spline_leader.png

The spline leader has no "dogleg" and spline leaders and polyline leaders can
not be mixed in a single MULTILEADER entity.

The leader type is set by the :meth:`~ezdxf.render.MultiLeaderBuilder.set_leader_properties`
method.

The :class:`~ezdxf.render.LeaderType` enum:

    - none
    - straight_lines
    - splines

Line Styling
~~~~~~~~~~~~

The leader color, linetype and lineweight is set by the
:meth:`~ezdxf.render.MultiLeaderBuilder.set_leader_properties` method::

    ml_builder.set_leader_properties(
        color=colors.MAGENTA,
        linetype="DASHEDX2",
        lineweight=70,
    )

.. image:: gfx/mleader_line_properties.png

All leader lines have the same properties.

Arrowheads
~~~~~~~~~~

The arrow head is set by the :meth:`~ezdxf.render.MultiLeaderBuilder.set_arrow_properties`
method::

    from ezdxf.render import ARROWS
    ml_builder.set_arrow_properties(name=ARROWS.closed_blank, size=8.0)

.. image:: gfx/mleader_arrow.png

All leader lines have the same arrow head and size.
The available arrow heads are defined in the :attr:`~ezdxf.render.arrows.ARROWS`
object.

Overall Scaling
---------------

The overall scaling has to be applied by the
:meth:`~ezdxf.render.MultiLeaderBuilder.set_overall_scaling` method
and scales the MTEXT or BLOCK content **and** the arrows.


Setup MLEADERSTYLE
------------------

The :class:`~ezdxf.entities.MLeaderStyle` stores many of the MULTILEADER
settings but most of them are copied to the MULTILINE entity at initialization.
So changing the MLEADERSTYLE style afterwards has little to no effect for
existing MULTILEADER entities.

Create a new MLEADERSTYLE called "MY_STYLE" and set the MTEXT style to "OpenSans"::

    my_style = doc.mleader_styles.duplicate_entry("Standard", "MY_STYLE")
    my_style.set_mtext_style("OpenSans")

The style for a MULTILEADER is set at the :meth:`~ezdxf.layouts.BaseLayout.add_multileader_mtext`
and :meth:`~ezdxf.layouts.BaseLayout.add_multileader_block` factory methods.




.. _mtext_quick_leader.py: https://github.com/mozman/ezdxf/blob/master/docs/source/tutorials/src/mleader/mtext_quick_leader.py
.. _mtext_content.py: https://github.com/mozman/ezdxf/blob/master/docs/source/tutorials/src/mleader/mtext_content.py
.. _block_content.py: https://github.com/mozman/ezdxf/blob/master/docs/source/tutorials/src/mleader/block_content.py

--- End of file: tutorials/mleader.rst ---



--- Start of file: tutorials/mtext.rst ---

.. _tut_mtext:

Tutorial for MText and MTextEditor
==================================

The :class:`~ezdxf.entities.MText` entity is a multi line entity with extended
formatting possibilities and requires at least DXF version R2000, to use all
features (e.g. background fill) DXF R2007 is required.

.. important::

    The rendering result of the MTEXT entity depends on the DXF viewer or CAD
    application and can differ between different applications. These differences
    have the greatest impact on line wrapping, which can cause columns of text
    to have different heights in different applications!

    In order for the text to look similar in different programs, the formatting
    should be as simple as possible or omitted altogether.

Prolog code:

.. code-block:: python

    import ezdxf

    doc = ezdxf.new("R2007", setup=True)
    msp = doc.modelspace()

    lorem_ipsum = """
    Lorem ipsum dolor sit amet, consectetur adipiscing elit,
    sed do eiusmod tempor incididunt ut labore et dolore magna
    aliqua. Ut enim ad minim veniam, quis nostrud exercitation
    ullamco laboris nisi ut aliquip ex ea commodo consequat.
    Duis aute irure dolor in reprehenderit in voluptate velit
    esse cillum dolore eu fugiat nulla pariatur. Excepteur sint
    occaecat cupidatat non proident, sunt in culpa qui officia
    deserunt mollit anim id est laborum.
    """

Adding a MTEXT entity
---------------------

The MTEXT entity can be added to any layout (modelspace, paperspace or block)
by the :meth:`~ezdxf.layouts.BaseLayout.add_mtext` function.

.. code-block:: python

    # store MTEXT entity for additional manipulations
    mtext = msp.add_mtext(lorem_ipsum, dxfattribs={"style": "OpenSans"})

This adds a MTEXT entity with text style "OpenSans".
The MTEXT content can be accessed by the :attr:`text` attribute, this attribute
can be edited like any Python string:

.. code-block:: python

    mtext.text += "Append additional text to the MTEXT entity."
    # even shorter with __iadd__() support:
    mtext += "Append additional text to the MTEXT entity."


.. image:: gfx/mtext_without_width.png

The :class:`MText` entity has an alias :attr:`MText.dxf.text` for the
:attr:`MText.text` attribute for compatibility to the :class:`Text` entity.

.. important::

    Line endings "\\n" will be replaced by the MTEXT line endings "\\P" at
    DXF export, but **not** vice versa "\\P" by "\\n" at DXF file loading.

Text placement
--------------

The location of the MTEXT entity is defined by the :attr:`MText.dxf.insert` and
the :attr:`MText.dxf.attachment_point` attributes in :ref:`WCS` coordinates.
The :attr:`attachment_point` defines the text alignment relative to the
:attr:`insert` location, default value is 1.

Attachment point constants defined in :mod:`ezdxf.lldxf.const`:

============================== =======
MText.dxf.attachment_point     Value
============================== =======
MTEXT_TOP_LEFT                 1
MTEXT_TOP_CENTER               2
MTEXT_TOP_RIGHT                3
MTEXT_MIDDLE_LEFT              4
MTEXT_MIDDLE_CENTER            5
MTEXT_MIDDLE_RIGHT             6
MTEXT_BOTTOM_LEFT              7
MTEXT_BOTTOM_CENTER            8
MTEXT_BOTTOM_RIGHT             9
============================== =======

The MTEXT entity has a method for setting :attr:`insert`,
:attr:`attachment_point` and :attr:`rotation` attributes
by one call: :meth:`~ezdxf.entities.MText.set_location`

Character height
----------------

The character height is defined by the DXF attribute
:attr:`MText.dxf.char_height` in drawing units, which
has also consequences for the line spacing of the MTEXT entity:

.. code-block:: python

    mtext.dxf.char_height = 0.5

The character height can be changed inline, see also :ref:`mtext_formatting`
and :ref:`mtext_inline_codes`.

Text rotation (direction)
-------------------------

The :attr:`MText.dxf.rotation` attribute defines the text rotation as angle
between the x-axis and the horizontal direction of the text in degrees.
The :attr:`MText.dxf.text_direction` attribute defines the horizontal direction
of MTEXT as vector in WCS.
Both attributes can be present at the same entity, in this case the
:attr:`MText.dxf.text_direction` attribute has the higher priority.

The MTEXT entity has two methods to get/set rotation:
:meth:`~ezdxf.entities.MText.get_rotation` returns the rotation angle in degrees
independent from definition as angle or direction, and
:meth:`~ezdxf.entities.MText.set_rotation` set the :attr:`rotation` attribute
and removes the :attr:`text_direction` attribute if present.

Defining a wrapping border
--------------------------

The wrapping border limits the text width and forces a line break for text
beyond this border. Without attribute :attr:`dxf.width` (or setting 0) the
lines are wrapped only at the regular line endings " \\P" or "\\n", setting the
reference column width forces additional line wrappings at the given width.
The text height can not be limited, the text always occupies as much space as
needed.

.. code-block:: python

    mtext.dxf.width = 60

.. image:: gfx/mtext_width_60.png

.. _mtext_formatting:

MTEXT formatting
----------------

MTEXT supports inline formatting by special codes: :ref:`mtext_inline_codes`

.. code-block:: python

    mtext.text = "{\\C1;red text} - {\\C3;green text} - {\\C5;blue text}"

.. image:: gfx/mtext_rgb.png

See also the support class `MTextEditor`_.

Stacked text
------------

MTEXT supports stacked text:

.. code-block:: python

    # the space ' ' in front of 'Lower' and the ';' behind 'Lower' are necessary
    # combined with vertical center alignment
    mtext.text = "\\A1;\\SUpper^ Lower; - \\SUpper/ Lower;} - \\SUpper# Lower;"


.. image:: gfx/mtext_stacked.png

See also the support class `MTextEditor`_.

Background color (filling)
--------------------------

The MTEXT entity can have a background filling:

- :ref:`ACI`
- true color value as ``(r, g, b)`` tuple
- color name as string, use special name ``'canvas'`` to use the canvas
  background color


Because of the complex dependencies `ezdxf` provides a method to set all
required DXF attributes at once:

.. code-block:: python

    mtext.set_bg_color(2, scale=1.5)

The parameter `scale` determines how much border there is around the text, the
value is based on the text height, and should be in the range of 1 - 5,
where 1 fits exact the MTEXT entity.

.. image:: gfx/mtext_bg_color.png
    :align: center

.. _mtext_editor_tut:

MTextEditor
-----------

.. warning::

    The :class:`MTextEditor` assembles just the inline code, which has to be
    parsed and rendered by the target CAD application, `ezdxf` has no influence
    to that result.

    Keep inline formatting as simple as possible, don't test the limits of its
    capabilities, this will not work across different CAD applications and keep
    the formatting in a logic manner like, do not change paragraph properties
    in the middle of a paragraph.

    **There is no official documentation for the inline codes!**

The :class:`~ezdxf.tools.text.MTextEditor` class provides a floating interface
to build :class:`MText` content in an easy way.

This example only shows the connection between :class:`MText` and the
:class:`MTextEditor`, and shows no additional features to the first example of
this tutorial:

Init Editor
+++++++++++

.. code-block:: python

    import ezdxf
    from ezdxf.tools.text import MTextEditor

    doc = ezdxf.new("R2007", setup=True)
    msp = doc.modelspace()

    lorem_ipsum = """
    Lorem ipsum dolor sit amet, consectetur adipiscing elit, ... see prolog code
    """

    # create a new editor object with an initial text:
    editor = MTextEditor(lorem_ipsum)

    # get the MTEXT content string from the editor by the str() function:
    mtext = msp.add_mtext(str(editor), dxfattribs={"style": "OpenSans"})

Tutorial Prolog:

.. code-block:: python

    # use constants defined in MTextEditor:
    NP = MTextEditor.NEW_PARAGRAPH

    ATTRIBS = {
        "char_height": 0.7,
        "style": "OpenSans",
        "width": 10,
    }
    editor = MTextEditor("using colors:" + NP)

Set Text Color
++++++++++++++

There are three ways to change the color inline:

- by color name "red", "green", "blue", "yellow", "cyan", "magenta", "white"
- by :ref:`ACI`
- by RGB values

.. code-block:: python

    # RED: set color by name - red, green, blue, yellow, cyan, magenta, white
    editor.color("red").append("RED" + NP)
    # RED: the color stays the same until the next change
    editor.append("also RED" + NP)

    # GREEN: change color by ACI (AutoCAD Color Index)
    editor.aci(3).append("GREEN" + NP)

    # BLUE: change color by RGB tuples
    editor.rgb((0, 0, 255)).append("BLUE" + NP)

    # add the MTEXT entity to the model space:
    msp.add_mtext(str(editor), attribs)

.. image:: gfx/mtext_editor_colors.png
    :align: center

Changing Text Height
++++++++++++++++++++

The :meth:`MtextEditor.height` method set the text height as absolute value in
drawing units (text height = cap height):

.. code-block:: Python

    attribs = dict(ATTRIBS)
    attribs["width"] = 40.0
    editor = MTextEditor("changing text height absolute: default height is 0.7" + NP)
    # doubling the default height = 1.4
    editor.height(1.4)
    editor.append("text height: 1.4" + NP)
    editor.height(3.5).append("text height: 3.5" + NP)
    editor.height(0.7).append("back to default height: 0.7" + NP)
    msp.add_mtext(str(editor), attribs)


.. image:: gfx/mtext_editor_text_height.png
    :align: center

The :meth:`MtextEditor.scale_height` method set the text height by a relative
factor, the :class:`MtextEditor` object does not keep track of current text
height, you have to do this by yourself. The initial text height is
:attr:`MText.dxf.char_height`:

.. code-block:: Python

    attribs = dict(ATTRIBS)
    attribs["width"] = 40.0
    editor = MTextEditor("changing text height relative: default height is 0.7" + NP)
    # this is the default text height in the beginning:
    current_height = attribs["char_height"]
    # The text height can only be changed by a factor:
    editor.scale_height(2)  # scale by 2 = 1.4
    # keep track of the actual height:
    current_height *= 2
    editor.append("text height: 1.4" + NP)
    # to set an absolute height, calculate the required factor:
    desired_height = 3.5
    factor = desired_height / current_height
    editor.scale_height(factor).append("text height: 3.5" + NP)
    current_height = desired_height
    # and back to 0.7
    editor.scale_height(0.7 / current_height).append("back to default height: 0.7" + NP)
    msp.add_mtext(str(editor), attribs).set_location(insert=location)

Changing Font
+++++++++++++

The font name for changing :class:`MText` fonts inline is the font family name!
The font family name is the name shown in font selection widgets in
desktop applications: "Arial", "Times New Roman", "Comic Sans MS".
The font has to be installed at the target system, else then CAD default
font will be used, in AutoCAD/BricsCAD is this the font defined for the text
style "Standard".

.. important::

    The DXF/DWG format is not optimal for preserving text layouts across
    multiple systems, and it's getting really bad across different CAD
    applications.

.. code-block:: Python

    attribs = dict(ATTRIBS)
    attribs["width"] = 15.0
    editor = MTextEditor("changing fonts:" + NP)
    editor.append("Default: Hello World!" + NP)
    editor.append("SimSun: ")
    # change font in a group to revert back to the default font at the end:
    simsun_editor = MTextEditor().font("SimSun").append("" + NP)
    # reverts the font back at the end of the group:
    editor.group(str(simsun_editor))
    # back to default font OpenSans:
    editor.append("Times New Roman: ")
    # change font outside of a group until next font change:
    editor.font("Times New Roman").append(" !" + NP)
    # If the font does not exist, a replacement font will be used:
    editor.font("Does not exist").append("This is the replacement font!")
    msp.add_mtext(str(editor), attribs)

.. image:: gfx/mtext_editor_fonts.png
    :align: center

Set Paragraph Properties
++++++++++++++++++++++++

The paragraph properties are set by the :meth:`~ezdxf.tools.text.MTextEditor.paragraph`
method and a :class:`~ezdxf.tools.text.ParagraphProperties` object, which bundles
all paragraph properties in a named tuple.

Each paragraph can have its own properties for:

- indentation arguments:

    - ``indent`` is the left indentation of the first line
    - ``left``  is the left side indentation of the paragraph
    - ``right`` is the right side indentation of the paragraph

- text adjustment: ``align``, by enum :class:`MTextParagraphAlignment`

    - MTextParagraphAlignment.LEFT
    - MTextParagraphAlignment.RIGHT
    - MTextParagraphAlignment.CENTER
    - MTextParagraphAlignment.JUSTIFIED
    - MTextParagraphAlignment.DISTRIBUTED

- tabulator stops: ``tab_stops``, a tuple of tabulator stops


Indentation and tabulator stops are multiples of the default :class:`MText`
text height stored in :class:`MText.dxf.char_height`. Calculate the drawing
units for indentation and tabulator stops, by multiplying the indentation
value by the :attr:`char_height` value.

:class:`Mtext` paragraphs are separated by new paragraph "\\P" characters.

.. code-block:: Python

    # import support classes:
    from ezdxf.tools.text import ParagraphProperties, MTextParagraphAlignment

    attribs = dict(ATTRIBS)
    attribs["char_height"] = 0.25
    attribs["width"] = 7.5
    editor = MTextEditor("Indent the first line:" + NP)
    props = ParagraphProperties(
        indent=1,  # indent first line = 1x0.25 drawing units
        align=MTextParagraphAlignment.JUSTIFIED
    )
    editor.paragraph(props)
    editor.append(lorem_ipsum)
    msp.add_mtext(str(editor), attribs)

.. image:: gfx/mtext_editor_indent_first.png
    :align: center

The first line indentation "indent" is relative to the "left" indentation.

.. code-block:: Python

    # import support classes:
    from ezdxf.tools.text import ParagraphProperties, MTextParagraphAlignment

    attribs = dict(ATTRIBS)
    attribs["char_height"] = 0.25
    attribs["width"] = 7.5
    editor = MTextEditor("Indent left paragraph side:" + NP)
    indent = 0.7  # 0.7 * 0.25 = 0.175 drawing units
    props = ParagraphProperties(
        # first line indentation is relative to "left", this reverses the
        # left indentation:
        indent=-indent,  # first line
        # indent left paragraph side:
        left=indent,
        align=MTextParagraphAlignment.JUSTIFIED
    )
    editor.paragraph(props)
    editor.append(" ".join(lorem_ipsum(100)))
    msp.add_mtext(str(editor), attribs).set_location(insert=location)

.. image:: gfx/mtext_editor_indent_left.png
    :align: center

Bullet List
+++++++++++

There are no special commands to build bullet list, the list is build of
indentation and a tabulator stop. Each list item needs a marker as an
arbitrary string. For more information about paragraph indentation and
tabulator stops see also chapter `Set Paragraph Properties`_.

.. code-block:: Python

    attribs = dict(ATTRIBS)
    attribs["char_height"] = 0.25
    attribs["width"] = 7.5
    bullet = ""  # alt + numpad 7
    editor = MTextEditor("Bullet List:" + NP)
    editor.bullet_list(
        indent=1,
        bullets=[bullet] * 3,  # each list item needs a marker
        content=[
            "First item",
            "Second item",
            " ".join(lorem_ipsum(30)),
        ])
    msp.add_mtext(str(editor), attribs)


.. image:: gfx/mtext_editor_bullet_list.png
    :align: center

Numbered List
+++++++++++++

There are no special commands to build numbered list, the list is build of
indentation and a tabulator stop. There is no automatic numbering,
but therefore the absolute freedom for using any string as list marker.
For more information about paragraph indentation and
tabulator stops see also chapter `Set Paragraph Properties`_.

.. code-block:: Python

    attribs = dict(ATTRIBS)
    attribs["char_height"] = 0.25
    attribs["width"] = 7.5
    editor = MTextEditor("Numbered List:" + NP)
    editor.bullet_list(
        indent=1,
        bullets=["1.", "2.", "3."],
        content=[
            "First item",
            "Second item",
            " ".join(lorem_ipsum(30)),
        ])
    msp.add_mtext(str(editor), attribs)

.. image:: gfx/mtext_editor_numbered_list.png
    :align: center

Stacked Text
++++++++++++

:class:`MText` supports stacked text (fractions) as a single inline code, which
means it is not possible to change any property inside the fraction.
This example shows a fraction with scaled down text height, placed in a group
to revert the text height afterwards:

.. code-block:: Python

    editor = MTextEditor("Stacked text:" + NP)

    stack = MTextEditor().scale_height(0.6).stack("1", "2", "^")
    editor.append("over: ").group(str(stack)).append(NP)

    stack = MTextEditor().scale_height(0.6).stack("1", "2", "/")
    editor.append("fraction: ").group(str(stack)).append(NP)

    stack = MTextEditor().scale_height(0.6).stack("1", "2", "#")
    editor.append("slanted: ").group(str(stack)).append(NP)

    # Additional formatting in numerator and denominator is not supported
    # by AutoCAD or BricsCAD, switching the color inside the stacked text
    # to red does not work:
    numerator = MTextEditor().color("red").append("1")
    stack = MTextEditor().scale_height(0.6).stack(str(numerator), "2", "#")
    editor.append("color red: ").group(str(stack)).append(NP)

    msp.add_mtext(str(editor), attribs)

.. image:: gfx/mtext_editor_stacking.png
    :align: center

.. seealso::

    - :class:`~ezdxf.tools.text.MTextEditor` example code on `github`_.
    - Documentation of :class:`~ezdxf.tools.text.MTextEditor`

.. _github: https://github.com/mozman/ezdxf/blob/master/examples/entities/mtext_editor.py

--- End of file: tutorials/mtext.rst ---



--- Start of file: tutorials/ocs_usage.rst ---

.. module:: ezdxf.math
    :noindex:

.. _tut_coordinates:

.. _tut_ocs:

Tutorial for OCS/UCS Usage
==========================

For OCS/UCS usage is a basic understanding of vector math required, for a brush
up, watch the YouTube tutorials of `3Blue1Brown`_ about `Linear Algebra`_.

Second read the :ref:`Coordinate Systems` introduction please.

.. seealso::

    The free online book `3D Math Primer for Graphics and Game Development <https://gamemath.com/>`_
    is a very good resource for learning vector math and other graphic related topics,
    it is easy to read for beginners and especially targeted to programmers.


For :ref:`WCS` there is not much to say as, it is what it is: the main world
coordinate system, and a drawing unit can have any real world unit you want.
Autodesk added some mechanism to define a scale for dimension and text entities,
but because I am not an AutoCAD user, I am not familiar with it, and further
more I think this is more an AutoCAD topic than a DXF topic.

Object Coordinate System (OCS)
------------------------------

The :ref:`OCS` is used to place planar 2D entities in 3D space. **ALL** points
of a planar entity lay in the same plane, this is also true if the plane is
located in 3D space by an OCS. There are three basic DXF attributes that gives
a 2D entity its spatial form.

Extrusion
~~~~~~~~~

The extrusion vector defines the OCS, it is a normal vector to the base plane of
a planar entity. This `base plane` is always located in the origin of the
:ref:`WCS`.  But there are some entities like :class:`~ezdxf.entities.Ellipse`,
which have an extrusion vector, but do not establish an OCS.  For this entities
the extrusion vector defines only the extrusion direction and thickness defines
the extrusion distance, but all other points and directions in WCS.

Elevation
~~~~~~~~~

The elevation value defines the z-axis value for all points of a planar entity,
this is an OCS value, and defines the distance of the entity plane from the
`base plane`.

This value exists only in output from DXF versions prior to R11 as separated DXF
attribute (group code 38).  In DXF R12 and later, the elevation value is
supplied as z-axis value of each point. But as always in DXF, this simple rule
does not apply to all entities: :class:`~ezdxf.entities.LWPolyline` and
:class:`~ezdxf.entities.Hatch` have an DXF attribute :attr:`elevation` as a
3D point, where the z-values of this point is the elevation height and the
x-value and the y-value are 0.

Thickness
~~~~~~~~~

Defines the extrusion distance for an entity.

.. note::

    There is a new edition of this tutorial using UCS based transformation,
    which are available in `ezdxf` v0.11 and later: :ref:`tut_ucs_transform`

    This edition shows the **hard way** to accomplish the transformations by
    low level operations.

Placing 2D Circle in 3D Space
-----------------------------

The colors of the system axis follow the AutoCAD standard:

    - red is x-axis
    - green is y-axis
    - blue is z-axis

.. literalinclude:: src/ocs/circle.py
    :lines: 6-29

The following image shows the 2D circle in 3D space in AutoCAD `Left` and
`Front` view.  The blue line shows the OCS z-axis (extrusion direction),
elevation is the distance from the origin to the center of the circle in this
case 2.828, and you see that the x- and y-axis of the OCS and the WCS are not
aligned.

.. image:: gfx/ocs-circle-side-view.png
    :alt: circle in ocs as side view
.. image:: gfx/ocs-circle-front-view.png
    :alt: circle in ocs as front view

Placing LWPolyline in 3D Space
------------------------------

For simplicity of calculation I use the :class:`UCS` class in this example to
place a 2D pentagon in 3D space.


.. literalinclude:: src/ocs/lwpolyline.py
    :lines: 12-37

The following image shows the 2D pentagon in 3D space in AutoCAD `Left`, `Front`
and `Top` view.  The three lines from the center of the pentagon show the UCS,
the three colored lines in the origin show the OCS, the white lines in the
origin show the WCS.

The z-axis of the UCS and the OCS pointing in the same direction (extrusion
direction), and the x-axis of the UCS and the WCS pointing also in the same
direction.  The elevation is the distance from the origin to the center of the
pentagon and all points of the pentagon have the same elevation, and you see
that the y-axis of the UCS, the OCS and the WCS are not aligned.

.. image:: gfx/ocs-lwpolyline-left.png
    :alt: pentagon in ucs as side view
.. image:: gfx/ocs-lwpolyline-front.png
    :alt: pentagon in ucs as front view

Using UCS to Place 3D Polyline
------------------------------

It is much simpler to use a 3D :class:`~ezdxf.entities.Polyline` to create the
3D pentagon.  The :class:`UCS` class is handy for this example and all kind of
3D operations.

.. literalinclude:: src/ocs/polyline3d.py
    :lines: 13-43

.. image:: gfx/ucs-polyline3d.png
    :alt: 3d poyline with UCS


Placing 2D Text in 3D Space
---------------------------

The problem of placing text in 3D space is the text rotation, which is always
counter clockwise around the OCS z-axis, and ``0`` degree is the direction of
the positive OCS x-axis, and the OCS x-axis is calculated by the
:ref:`Arbitrary Axis Algorithm`.

Calculate the OCS rotation angle by converting the TEXT rotation angle (in UCS
or WCS) into a vector or begin with text direction as vector, transform this
direction vector into OCS and convert the OCS vector back into an angle in the
OCS xy-plane (see example), this procedure is available as
:meth:`UCS.to_ocs_angle_deg` or :meth:`UCS.to_ocs_angle_rad`.

AutoCAD supports thickness for the TEXT entity only for `.shx` fonts and not for
true type fonts.

.. literalinclude:: src/ocs/text.py
    :lines: 12-33

.. image:: gfx/ocs-text-top.png
    :alt: text in ucs as top view

.. image:: gfx/ocs-text-front.png
    :alt: text in ucs as front view

.. hint::

    For calculating OCS angles from an UCS, be aware that 2D entities, like TEXT
    or ARC, are placed parallel to the xy-plane of the UCS.

Placing 2D Arc in 3D Space
--------------------------

Here we have the same problem as for placing text, you need the start- and end
angle of the arc in degrees in the OCS, and this example also shows a shortcut
for calculating the OCS angles.

.. literalinclude:: src/ocs/arc.py
    :lines: 12-32

.. image:: gfx/ocs-arc-top.png
    :alt: arc in ucs as top view
.. image:: gfx/ocs-arc-front.png
    :alt: arc in ucs as front view

Placing Block References in 3D Space
------------------------------------

Despite the fact that block references (:class:`~ezdxf.entities.Insert`) can
contain true 3D entities like :class:`~ezdxf.entities.Line` or
:class:`~ezdxf.entities.Mesh`, the :class:`~ezdxf.entities.Insert` entity uses
the same placing principe as :class:`~ezdxf.entities.Text` or
:class:`~ezdxf.entities.Arc` shown in the previous chapters.

Placement by OCS coordinates and rotation about the OCS z-axis, can be achieved
the same way as for generic 2D entities.  The DXF attribute
:attr:`Insert.dxf.rotation` rotates a block reference around the block z-axis,
which is located in the :attr:`Block.dxf.base_point`. To rotate the block reference
around the WCS x-axis, a transformation of the block z-axis into the WCS x-axis
is required by rotating the block z-axis 90 degree counter-clockwise around
y-axis by using an UCS:

This is just an excerpt of the important parts, see the whole code of
`insert.py`_ at github.

.. literalinclude:: src/ocs/insert.py
    :lines: 47-69

.. image:: gfx/insert_1.png
.. image:: gfx/insert_2.png

To rotate a block reference around another axis than the block z-axis, you have
to find the rotated z-axis (extrusion vector) of the rotated block reference,
following example rotates the block reference around the block x-axis by
15 degrees:

.. literalinclude:: src/ocs/insert.py
    :lines: 74-88

.. image:: gfx/insert_3.png
.. image:: gfx/insert_4.png

The next example shows how to translate a block references with an
already established OCS:

.. literalinclude:: src/ocs/insert.py
    :lines: 90-99

Setting a new insert location is the same procedure without adding a translation
vector, just transform the new insert location into the OCS.

.. image:: gfx/insert_5.png
.. image:: gfx/insert_6.png

The next operation is to rotate a block reference with an established OCS,
rotation axis is the block y-axis, rotation angle is -90 degrees. First
transform block y-axis (rotation axis) and block z-axis (extrusion vector)
from OCS into WCS:

.. literalinclude:: src/ocs/insert.py
    :lines: 101-106

Build transformation matrix and transform extrusion vector and build new UCS:

.. literalinclude:: src/ocs/insert.py
    :lines: 107-114

Set new OCS attributes, we also have to set the rotation attribute even though
we do not rotate the block reference around the local z-axis, the new block
x-axis (0 deg) differs from OCS x-axis and has to be adjusted:

.. literalinclude:: src/ocs/insert.py
    :lines: 116-122

.. image:: gfx/insert_7.png
.. image:: gfx/insert_8.png

And here is the point, where my math knowledge ends, for more advanced CAD
operation you have to look elsewhere.

.. _Linear Algebra: https://www.youtube.com/watch?v=kjBOesZCoqc&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab
.. _3Blue1Brown: https://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw
.. _insert.py: https://github.com/mozman/ezdxf/blob/master/docs/source/tutorials/src/ocs/insert.py


--- End of file: tutorials/ocs_usage.rst ---



--- Start of file: tutorials/ordinate_dimension.rst ---

.. _tut_ordinate_dimension:


Tutorial for Ordinate Dimensions
================================

Please read the :ref:`tut_linear_dimension` before, if you haven't.

.. note::

    `Ezdxf` does not consider all DIMSTYLE variables, so the rendering results
    are different from CAD applications.

Local Coordinate System
-----------------------

Ordinate dimensioning is used when the x- and the y-coordinates from a
location (feature), are the only dimensions necessary. The dimensions to each
feature, originate from one datum location, called "origin" in this tutorial.

The local coordinate system (LCS) in which the measurement is done,
is defined by the `origin` and the `rotation` angle around the z-axis in the
rendering UCS, which is the :ref:`WCS` by default.

Factory Methods to Create Ordinate Dimensions
---------------------------------------------

All factory methods for creating ordinate dimensions expect global coordinates
to define the feature location.

Global Feature Location
~~~~~~~~~~~~~~~~~~~~~~~

The first example shows ordinate dimensions defined in the render UCS,
in this example the :ref:`WCS`, this is how the DIMENSION entity expects the
coordinates of the feature location:

.. code-block:: Python

    import ezdxf
    from ezdxf.math import Vec3
    from ezdxf.render import forms

    # Use argument setup=True to setup the default dimension styles.
    doc = ezdxf.new(setup=True)

    # Add new entities to the modelspace:
    msp = doc.modelspace()
    # Add a rectangle: width=4, height = 2.5, lower left corner is WCS(x=2, y=3)
    origin = Vec3(2, 3)
    msp.add_lwpolyline(
        forms.translate(forms.box(4, 2.5), origin),
        close=True
    )

    # Add an x-type ordinate DIMENSION with global feature locations:
    msp.add_ordinate_x_dim(
        # lower left corner
        feature_location=origin + (0, 0),  # feature location in the WCS
        offset=(0, -2),  # end of leader, relative to the feature location
        origin=origin,
    ).render()
    msp.add_ordinate_x_dim(
        # lower right corner
        feature_location=origin + (4, 0),  # feature location in the WCS
        offset=(0, -2),
        origin=origin,
    ).render()

    # Add an y-type ordinate DIMENSION with global feature locations:
    msp.add_ordinate_y_dim(
        # lower right corner
        feature_location=origin + (4, 0),  # feature location in the WCS
        offset=(2, 0),
        origin=origin,
    ).render()
    msp.add_ordinate_y_dim(
        # upper right corner
        feature_location=origin + (4, 2.5),  # feature location in the WCS
        offset=(2, 0),
        origin=origin,
    ).render()

    # Necessary second step to create the BLOCK entity with the dimension geometry.
    # Additional processing of the DIMENSION entity could happen between adding
    # the entity and the rendering call.
    doc.saveas("ord_global_features.dxf")

The return value `dim` is **not** a dimension entity, instead a
:class:`~ezdxf.entities.DimStyleOverride` object is
returned, the dimension entity is stored as :attr:`dim.dimension`.

.. image:: gfx/dim_ord_global.png

Local Feature Location
~~~~~~~~~~~~~~~~~~~~~~

The previous examples shows that the calculation of the global feature location
is cumbersome and it gets even more complicated for a rotated LCS.

This example shows how to use a render :class:`~ezdxf.math.UCS` for using
locale coordinates to define the feature locations:

.. code-block:: Python

    import ezdxf
    from ezdxf.math import Vec3, UCS
    from ezdxf.render import forms

    doc = ezdxf.new(setup=True)
    msp = doc.modelspace()

    # Create a special DIMSTYLE for "vertical" centered measurement text:
    dimstyle = doc.dimstyles.duplicate_entry("EZDXF", "ORD_CENTER")
    dimstyle.dxf.dimtad = 0  # "vertical" centered measurement text

    # Add a rectangle: width=4, height = 2.5, lower left corner is WCS(x=2, y=3),
    # rotated about 30 degrees:
    origin = Vec3(2, 3)
    msp.add_lwpolyline(
        forms.translate(forms.rotate(forms.box(4, 2.5), 30), origin),
        close=True
    )

    # Define the rotated local render UCS.
    # The origin is the lower-left corner of the rectangle and the axis are
    # aligned to the rectangle edges:
    # The y-axis "uy" is calculated automatically by the right-hand rule.
    ucs = UCS(origin, ux=Vec3.from_deg_angle(30), uz=(0, 0, 1))

    # Add a x-type ordinate DIMENSION with local feature locations:
    # the origin is now the origin of the UCS, which is (0, 0) the default value of
    # "origin" and the feature coordinates are located in the UCS:
    msp.add_ordinate_x_dim(
        # lower left corner
        feature_location=(0, 0),  # feature location in the UCS
        offset=(0.25, -2),  # # leader with a "knee"
        dimstyle="ORD_CENTER",
    ).render(ucs=ucs)  # Important when using a render UCS!
    msp.add_ordinate_x_dim(
        # lower right corner
        feature_location=(4, 0),  # feature location in the UCS
        offset=(0.25, -2),  # leader with a "knee"
        dimstyle="ORD_CENTER",
    ).render(ucs=ucs)  # Important when using a render UCS!

    # Add a y-type ordinate DIMENSION with local feature coordinates:
    msp.add_ordinate_y_dim(
        # lower right corner
        feature_location=(4, 0),  # feature location in the UCS
        offset=(2, 0.25),  # leader with a "knee"
        dimstyle="ORD_CENTER",
    ).render(ucs=ucs)  # Important when using a render UCS!
    msp.add_ordinate_y_dim(
        # upper right corner
        feature_location=(4, 2.5),  # feature location in the UCS
        offset=(2, 0.25),  # leader with a "knee"
        dimstyle="ORD_CENTER",
    ).render(ucs=ucs)  # Important when using a render UCS!
    doc.saveas("ord_local_features.dxf")


.. image:: gfx/dim_ord_local.png

Placing Measurement Text
------------------------

The `ezdxf` ordinate DIMENSION renderer places the measurement text always at
the default location, because the location of the leader end point is given by
the argument `offset` in the factory methods, which provides a flexible way
to place the measurement text, overriding the text location by an explicit
user location is not supported, also the user text rotation is not supported,
the text is always aligned to the local coordinate system x- and y-axis.

.. seealso::

    - Graphical reference of many DIMVARS and some advanced information:
      :ref:`dimstyle_table_internals`
    - Source code file `standards.py`_ shows how to create your own DIMSTYLES.
    - The Script `dimension_ordinate.py`_ shows examples for angular dimensions.

Overriding Measurement Text
---------------------------

See Linear Dimension Tutorial: :ref:`tut_angular_dim_overriding_text_rotation`

Measurement Text Formatting and Styling
---------------------------------------

See Linear Dimension Tutorial: :ref:`tut_measurement_text_formatting_and_styling`

Tolerances and Limits
---------------------

See Linear Dimension Tutorial: :ref:`tut_tolerances_and_limits`


.. _dimension_ordinate.py:  https://github.com/mozman/ezdxf/blob/master/examples/render/dimension_ordinate.py
.. _standards.py: https://github.com/mozman/ezdxf/blob/master/src/ezdxf/tools/standards.py

--- End of file: tutorials/ordinate_dimension.rst ---



--- Start of file: tutorials/polyface.rst ---

.. _tut_polyface:

Tutorial for Polyface
=====================

The :class:`~ezdxf.entities.Polyface` entity represents a 3D mesh build of
vertices and faces and is just an extended POLYLINE entity with a complex
VERTEX structure. The :class:`Polyface` entity was used in DXF R12 and older
DXF versions and is still supported by newer DXF versions. The new
:class:`~ezdxf.entities.Mesh` entity stores the same data much more efficient
but requires DXF R2000 or newer. The :class:`Polyface` entity supports only
triangles and quadrilaterals as faces, the :class:`Mesh` entity supports also
n-gons.

Its recommended to use the :class:`~ezdxf.render.MeshBuilder` objects to
create 3D meshes and render them as POLYFACE entities by the
:meth:`~ezdxf.render.MeshBuilder.render_polymesh` method into a layout:

.. code-block:: Python

        import ezdxf
        from ezdxf import colors
        from ezdxf.gfxattribs import GfxAttribs
        from ezdxf.render import forms

        cube = forms.cube().scale_uniform(10).subdivide(2)
        red = GfxAttribs(color=colors.RED)
        green = GfxAttribs(color=colors.GREEN)
        blue = GfxAttribs(color=colors.BLUE)

        doc = ezdxf.new()
        msp = doc.modelspace()

        # render as MESH entity
        cube.render_mesh(msp, dxfattribs=red)
        cube.translate(20)

        # render as POLYFACE a.k.a. POLYLINE entity
        cube.render_polyface(msp, dxfattribs=green)
        cube.translate(20)

        # render as a bunch of 3DFACE entities
        cube.render_3dfaces(msp, dxfattribs=blue)

        doc.saveas("meshes.dxf")

.. image:: gfx/mesh_cubes.png

.. warning::

    If the mesh contains n-gons the render methods for POLYFACE and
    3DFACES subdivides the n-gons into triangles, which does **not** work for
    concave faces.

The usage of the :class:`~ezdxf.render.MeshBuilder` object is also recommended
for inspecting :class:`Polyface` entities:

- :attr:`MeshBuilder.vertices` is a sequence of 3D points as
  :class:`ezdxf.math.Vec3` objects
- a face in :attr:`MeshBuilder.faces` is a sequence of indices into the
  :attr:`MeshBuilder.vertices` sequence

.. code-block:: Python

    import ezdxf
    from ezdxf.render import MeshBuilder

    def process(mesh):
        # vertices is a sequence of 3D points
        vertices = mses.vertices
        # a face is a sequence of indices into the vertices sequence
        faces = mesh.faces
        ...

    doc = ezdxf.readfile("meshes.dxf")
    msp = doc.modelspace()
    for polyline in msp.query("POLYLINE"):
        if polyline.is_poly_face_mesh:
            mesh = MeshBuilder.from_polyface(polyline)
            process(mesh)

.. seealso::

    :ref:`tut_mesh`

--- End of file: tutorials/polyface.rst ---



--- Start of file: tutorials/psp_viewports.rst ---

.. _tut_psp_viewports:

Tutorial for Viewports in Paperspace
====================================

This tutorial is based on the example script `viewports_in_paperspace.py`.
The script creates DXF files for the version R12 and for R2000+, but the
export for DXF R12 has a wrong papersize in BricsCAD and wrong margins in
Autodesk DWG Trueview. I don't know why this happens and I don't waste my time
to fix this.

.. important::

    If you need paperspace layouts use DXF version R2000 or newer because
    the export of the page dimensions does not work for DXF R12!

The scripts creates three flat geometries in the xy-plane of the :ref:`WCS` and a
3D mesh as content of the modelspace:

.. image:: gfx/vp-tut-msp-content.png
    :align: center

Page Setup
----------

The paperspace layout feature lacks documentation in the DXF reference,
there is no information in practice on **how** it is used, so most of
the information here is assumptions gathered through trail and error.

The :meth:`~ezdxf.layouts.Paperspace.page_setup` method defines the properties
of the paper sheet itself.  The units of the modelspace and the paperspace are
not related and can even have different unit systems (imperial, meters), but to
keep things simple it's recommended to use the same unit system for both spaces.

.. code-block:: Python

    layout.page_setup(size=(24, 18), margins=(1, 1, 1, 1), units="inch")

The `size` argument defines the overall paper size in rotation mode 0, it seems
to be the best practice to define the paper extents in landscape mode and rotate
the paper by the `rotate` argument afterwards.

Choices for the `rotation` argument:

    === ============
    0   no rotation
    1   90 degrees counter-clockwise
    2   upside-down
    3   90 degrees clockwise
    === ============

The `scale` argument reflects the relationship between paper unit and drawing
unit in paperspace. It's recommended to let this scale at the default value of
1:1 and draw lines and text in paperspace with the same units as you defined
the paper size.

.. seealso::

    - AutoCAD: `About Plotting`_ and `About Setting the Plot Scale`_
    - BricsCAD: `General Procedure for Printing`_

Drawing in Paperspace
---------------------

You can add DXF entities to the paperspace like to any other layout space.
The coordinate origin (0, 0) is in the left bottom corner of the canvas which
is the paper size minus the margins. You can draw beyond this limits but CAD
applications may not print that content.

.. hint::

    By writing this tutorial I noticed that changing the printer/plotter and the
    paper size does shift the layout content, because all paper sizes are defined
    without margins. Maybe it's preferable to set all margins to zero.

    I added the helper method :meth:`~ezdxf.document.Drawing.page_setup` to the
    :class:`~ezdxf.document.Drawing` class and an example `simple_page_setup.py`_
    how to use it.

Adding Viewports
----------------

The :class:`~ezdxf.entities.Viewport` entity is a window to the modelspace to
display the content of the modelspace in paperspace with an arbitrary scaling
and rotation.
The VIEWPORT entity will be added by the factory method :meth:`~ezdxf.layouts.Paperspace.add_viewport`,
the `center` argument defines the center and the `size` argument defines the
width and height of the of the VIEWPORT in paperspace. The source of the
modelspace to display is defined by the arguments `view_center_point` and
`view_height`.

.. image:: gfx/vp-tut-psp-content.png
    :align: center

Scaling Factor
--------------

The scaling factor of the VIEWPORT is not an explicit value, the factor
is defined by the relation of the VIEWPORT height of the `size` argument and
the `view_height` argument.

If both values are equal the scaling is 1:1

.. code-block:: Python

    paperspace.add_viewport(
        center=(14.5, 2.5),
        size=(5, 5),
        view_center_point=(12.5, 7.5),
        view_height=5,
    )


If the `view_height` is 5x larger than the VIEWPORT height the scaling is 1:5

.. code-block:: Python

    paperspace.add_viewport(
        center=(8.5, 2.5),
        size=(5, 5),
        view_center_point=(10, 5),
        view_height=25,
    )

View Direction
--------------

The default view direction is the top down view, but can be changed to any view
by the attributes `view_target_point` and  `view_direction_vector` of the
:attr:`dxf` namespace.

.. code-block:: Python

    vp = paperspace.add_viewport(
        center=(16, 10), size=(4, 4), view_center_point=(0, 0), view_height=30
    )
    vp.dxf.view_target_point = (40, 40, 0)
    vp.dxf.view_direction_vector = (-1, -1, 1)

Viewport Frame
--------------

The VIEWPORT frame (borderlines) are shown in paperspace by default.
The VIEWPORT entity does not have an attribute to change this.
The visibility of the VIEWPORT frame is controlled by the layer assigned to the
VIEWPORT entity which is the layer "VIEWPORTS" by default in `ezdxf`.
Turning off this layer hides the frames of the VIEWPORT entities on this layer,
to do that the layer "VIEWPORTS" have to be created by the library user:

.. code-block:: Python

    vp_layer = doc.layers.add("VIEWPORTS")
    vp_layer.off()

Freeze Layers
-------------

Each VIEWPORT can have individual frozen layers, which means the layers are not
visible in this VIEWPORT. To freeze layers in a VIEWPORT assign the names of the
frozen layers as a list-like object to the :attr:`frozen_layers` attribute of the
VIEWPORT entity:

.. code-block:: Python

    vp.frozen_layers = ["Layer0", "Layer1"]

.. important::

    AutoCAD and BricsCAD **do not crash** if the layer names do not have layer table
    entries and the layer names are case insensitive as all table names.

.. seealso::

    - Basic concept of :ref:`layer_concept`
    - :class:`~ezdxf.entities.Layer`

Override Layer Properties
-------------------------

Each VIEWPORT can override layer properties individually. These overrides are
stored in the :class:`~ezdxf.entities.Layer` entity and referenced by the handle
of the VIEWPORT. This procedure is a bit more complex and shown in the example
file `viewports_override_layer_attributes.py`_.

1. get the :class:`~ezdxf.entities.Layer` object
2. get the :class:`~ezdxf.entities.LayerOverrides` object from the layer
3. override the properties of the VIEWPORT
4. commit changes

.. code-block:: Python

    layer = doc.layers.get("Layer0")
    override = layer.get_vp_overrides()
    override.set_linetype(vp.dxf.handle, "DASHED")
    override.commit()

Supported property overrides:

    - ACI color
    - true color
    - transparency
    - linetype
    - lineweight

.. seealso::

    - Basic concept of :ref:`layer_concept`
    - Basic concept of :ref:`aci`
    - Basic concept of :ref:`true color`
    - Basic concept of :ref:`transparency`
    - Basic concept of :ref:`linetypes`
    - Basic concept of :ref:`lineweights`
    - :class:`~ezdxf.entities.Layer`
    - :class:`~ezdxf.entities.LayerOverrides`

.. _viewports_in_paperspace.py: https://github.com/mozman/ezdxf/blob/master/examples/viewports_in_paperspace.py
.. _About Plotting: https://help.autodesk.com/view/ACD/2018/ENU/?guid=GUID-2DB9EB8C-767C-4C91-B0A3-FFFEC4C5863A
.. _About Setting the Plot Scale: https://help.autodesk.com/view/ACD/2018/ENU/?guid=GUID-89604826-0B55-4994-8214-1CA93FA66985
.. _General Procedure for Printing: https://help.bricsys.com/document/_guides--BCAD_printing_and_plotting--GD_generalprocedureforprinting/V23/EN_US?id=165079156041
.. _viewports_override_layer_attributes.py: https://github.com/mozman/ezdxf/blob/master/examples/viewports_override_layer_attributes.py
.. _simple_page_setup.py: https://github.com/mozman/ezdxf/blob/master/examples/simple_page_setup.py

--- End of file: tutorials/psp_viewports.rst ---



--- Start of file: tutorials/radius_dimension.rst ---

.. _tut_radius_dimension:

Tutorial for Radius Dimensions
==============================

Please read the :ref:`tut_linear_dimension` before, if you haven't.

.. note::

    `Ezdxf` does not consider all DIMSTYLE variables, so the
    rendering results are different from CAD applications.

.. code-block:: Python

    import ezdxf

    # DXF R2010 drawing, official DXF version name: 'AC1024',
    # setup=True setups the default dimension styles
    doc = ezdxf.new("R2010", setup=True)

    msp = doc.modelspace()  # add new dimension entities to the modelspace
    msp.add_circle((0, 0), radius=3)  # add a CIRCLE entity, not required
    # add default radius dimension, measurement text is located outside
    dim = msp.add_radius_dim(
        center=(0, 0), radius=3, angle=45, dimstyle="EZ_RADIUS"
    )
    # necessary second step, to create the BLOCK entity with the dimension geometry.
    dim.render()
    doc.saveas("radius_dimension.dxf")

The example above creates a 45 degrees slanted radius :class:`~ezdxf.entities.Dimension`
entity, the default dimension style "EZ_RADIUS" is defined as 1 drawing unit
= 1m, drawing scale = 1:100 and the length factor = 100, which creates a
measurement text in cm, the default location for the measurement text is outside
of the circle.

The `center` point defines the center of the circle but there doesn't have
to exist a circle entity, `radius` defines the circle radius, which is also the
measurement, and angle defines the slope of the dimension line, it is also
possible to define the circle by a measurement point `mpoint` on the circle.

The return value `dim` is **not** a dimension entity, instead a
:class:`~ezdxf.entities.DimStyleOverride` object is
returned, the dimension entity is stored as :attr:`dim.dimension`.

Placing Measurement Text
------------------------

There are different predefined DIMSTYLES to achieve various text placing
locations.

The basic DIMSTYLE "EZ_RADIUS" settings are:

- 1 drawing unit = 1m
- scale 1:100
- the length factor :attr:`dimlfac` = 100, which creates a measurement text in cm.
- uses a closed filled arrow, arrow size :attr:`dimasz` = 0.25

.. note::

    Not all possibles features of DIMSTYLE are supported by the `ezdxf` rendering
    procedure and especially for the radial dimension there are less features
    implemented than for the linear dimension because of the lack of good
    documentation.

.. seealso::

    - Graphical reference of many DIMVARS and some advanced information:
      :ref:`dimstyle_table_internals`
    - Source code file `standards.py`_ shows how to create your own DIMSTYLES.
    - The Script `dimension_radius.py`_ shows examples for radius dimensions.

Default Text Locations Outside
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Advanced "EZ_RADIUS" settings for placing the text outside of the circle:

=========== ====================================================================
tmove       1 = add a leader when dimension text is moved, this is the best
            setting for text outside to preserve the appearance of the DIMENSION
            entity, if editing afterwards in a CAD application.
dimtad      1 = place the text vertical above the dimension line
=========== ====================================================================

.. code-block:: python

    dim = msp.add_radius_dim(
        center=(0, 0),
        radius=2.5,
        angle=45,
        dimstyle="EZ_RADIUS"
    )
    dim.render()  # always required, but not shown in the following examples

.. image:: gfx/dim_radial_outside.png

To force text outside horizontal set :attr:`~ezdxf.entities.DimStyle.dxf.dimtoh`
to 1:

.. code-block:: python

    dim = msp.add_radius_dim(
        center=(0, 0),
        radius=2.5,
        angle=45,
        dimstyle="EZ_RADIUS",
        override={"dimtoh": 1}
    )

.. image:: gfx/dim_radial_outside_horiz.png

Default Text Locations Inside
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

DIMSTYLE "EZ_RADIUS_INSIDE" can be used to place the dimension text inside the
circle at a default location.

The basic DIMSTYLE "EZ_RADIUS_INSIDE" settings are:

- 1 drawing unit = 1m
- scale 1:100, length_factor is 100 which creates
- the length factor :attr:`dimlfac` = 100, which creates a measurement text in cm.
- uses a closed filled arrow, arrow size :attr:`dimasz` = 0.25

Advanced "EZ_RADIUS_INSIDE" settings to place (force) the text inside of the
circle:

=========== ====================================================================
tmove       0 = moves the dimension line with dimension text, this is the best
            setting for text inside to preserve the appearance of the DIMENSION
            entity, if editing afterwards in a CAD application.
dimtix      1 = force text inside
dimatfit    0 = force text inside, required by BricsCAD and AutoCAD
dimtad      0 = center text vertical, BricsCAD and AutoCAD always create a
            vertical centered text, `ezdxf` let you choose the vertical
            placement (above, below, center), but editing the DIMENSION in
            BricsCAD or AutoCAD will reset text to center placement.
=========== ====================================================================

.. code-block:: python

    dim = msp.add_radius_dim(
        center=(0, 0),
        radius=2.5,
        angle=45,
        dimstyle="EZ_RADIUS_INSIDE"
    )

.. image:: gfx/dim_radial_inside_0.png

.. image:: gfx/dim_radial_inside_1.png

To force text inside horizontal set :attr:`~ezdxf.entities.DimStyle.dxf.dimtih`
to 1:

.. code-block:: python

    dim = msp.add_radius_dim(
        center=(0, 0),
        radius=2.5,
        angle=45,
        dimstyle="EZ_RADIUS_INSIDE",
        override={"dimtih": 1}
    )

.. image:: gfx/dim_radial_inside_horiz.png


User Defined Text Locations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Beside the default location it is always possible to override the text location
by a user defined location. This location also determines the angle of the
dimension line and overrides the argument `angle`. For user defined locations
it is not necessary to force text inside (``dimtix=1``), because the location
of the text is explicit given, therefore the DIMSTYLE "EZ_RADIUS" can be used
for all this examples.

User defined location outside of the circle:

.. code-block:: python

    dim = msp.add_radius_dim(
        center=(0, 0),
        radius=2.5,
        location=(4, 4),
        dimstyle="EZ_RADIUS"
    )

.. image:: gfx/dim_radial_user_outside.png

User defined location outside of the circle and forced horizontal text:

.. code-block:: python

    dim = msp.add_radius_dim(
        center=(0, 0),
        radius=2.5,
        location=(4, 4),
        dimstyle="EZ_RADIUS",
        override={"dimtoh": 1}
    )

.. image:: gfx/dim_radial_user_outside_horiz.png

User defined location inside of the circle:

.. code-block:: python

    dim = msp.add_radius_dim(
        center=(0, 0),
        radius=2.5,
        location=(1, 1),
        dimstyle="EZ_RADIUS"
    )

.. image:: gfx/dim_radial_user_inside_0.png

.. image:: gfx/dim_radial_user_inside_2.png

User defined location inside of the circle and forced horizontal text:

.. code-block:: python

    dim = msp.add_radius_dim(
        center=(0, 0),
        radius=2.5,
        location=(1, 1),
        dimstyle="EZ_RADIUS",
        override={"dimtih": 1},
    )

.. image:: gfx/dim_radial_user_inside_horiz.png

.. _tut_center_mark:

Center Mark/Lines
-----------------

Center mark/lines are controlled by :attr:`~ezdxf.entities.DimStyle.dxf.dimcen`,
default value is 0 for predefined dimstyles "EZ_RADIUS" and "EZ_RADIUS_INSIDE":

=== =====
0   Center mark is off
>0  Create center mark of given size
<0  Create center lines
=== =====

.. code-block:: Python

    dim = msp.add_radius_dim(
        center=(0, 0),
        radius=2.5,
        angle=45,
        dimstyle="EZ_RADIUS",
        override={"dimcen": 0.25},
    )

.. image:: gfx/dim_center_mark.png

Overriding Measurement Text
---------------------------

See Linear Dimension Tutorial: :ref:`tut_overriding_measurement_text`

Measurement Text Formatting and Styling
---------------------------------------

See Linear Dimension Tutorial: :ref:`tut_measurement_text_formatting_and_styling`


.. _dimension_radius.py:  https://github.com/mozman/ezdxf/blob/master/examples/render/dimension_radius.py
.. _standards.py: https://github.com/mozman/ezdxf/blob/master/src/ezdxf/tools/standards.py

--- End of file: tutorials/radius_dimension.rst ---



--- Start of file: tutorials/simple_drawings.rst ---

.. _tut_simple_drawings:

Tutorial for Creating DXF Drawings
==================================

Create a new DXF document by the :func:`ezdxf.new` function:

.. code-block:: Python

    import ezdxf

    # create a new DXF R2010 document
    doc = ezdxf.new("R2010")

    # add new entities to the modelspace
    msp = doc.modelspace()
    # add a LINE entity
    msp.add_line((0, 0), (10, 0))
    # save the DXF document
    doc.saveas("line.dxf")

New entities are always added to layouts, a layout can be the modelspace, a
paperspace layout or a block layout.

.. seealso::

    :ref:`thematic_factory_method_index`

Predefined Resources
--------------------

`Ezdxf` creates new DXF documents with as little content as possible, this means
only the resources that are absolutely necessary are created.
The :func:`ezdxf.new` function can create some standard resources, such as
linetypes and text styles, by setting the argument `setup` to ``True``.

.. code-block:: Python

    import ezdxf

    doc = ezdxf.new("R2010", setup=True)
    msp = doc.modelspace()
    msp.add_line((0, 0), (10, 0), dxfattribs={"linetype": "DASHED"})

The defined standard linetypes are shown in the basic concept section for
:ref:`linetypes` and the available text styles are shown in the :ref:`tut_text`.

.. important::

    To see the defined text styles in a DXF viewer or CAD application, the
    applications have to know where the referenced TTF fonts can be found.
    This configuration is not possible by `ezdxf` and has to be done for each
    application as described in their documentation.

    See also: :ref:`font resources`

Simple DXF R12 drawings
-----------------------

The :ref:`r12writer` add-on creates simple DXF R12 drawings with a restricted
set of DXF types: LINE, CIRCLE, ARC, TEXT, POINT, SOLID, 3DFACE and POLYLINE.

The advantage of the :ref:`r12writer` is the speed and the small memory
footprint, all entities are written directly to a file or stream without
creating a document structure in memory.

.. seealso::

    :ref:`r12writer`


--- End of file: tutorials/simple_drawings.rst ---



--- Start of file: tutorials/spline.rst ---

.. include:: ../spline-links.inc

.. _tut_spline:

Tutorial for Spline
===================

Background information about `B-spline`_ at Wikipedia.

Splines from fit points
-----------------------

Splines can be defined by fit points only, this means the curve passes all given
fit points.  AutoCAD and BricsCAD generates required control points and knot
values by itself, if only fit points are present.

Create a simple spline:

.. code-block:: python

    doc = ezdxf.new("R2000")

    fit_points = [(0, 0, 0), (750, 500, 0), (1750, 500, 0), (2250, 1250, 0)]
    msp = doc.modelspace()
    spline = msp.add_spline(fit_points)

.. image:: gfx/spline1.png

Append a fit point to a spline:

.. code-block:: python

    # fit_points, control_points, knots and weights are list-like containers:
    spline.fit_points.append((2250, 2500, 0))

.. image:: gfx/spline2.png

You can set additional `control points`, but if they do not fit the
auto-generated AutoCAD values, they will be ignored and don't mess around
with `knot`_ values.

.. code-block:: python

    doc = ezdxf.readfile("AutoCAD_generated.dxf")

    msp = doc.modelspace()
    spline = msp.query("SPLINE").first

    # fit_points, control_points, knots and weights are list-like objects:
    spline.fit_points.append((2250, 2500, 0))

As far as I have tested, this approach works without complaints from AutoCAD,
but for the case of problems remove invalid data from the SPLINE entity:

.. code-block:: python

    # current control points do not match spline defined by fit points
    spline.control_points = []

    # count of knots is not correct:
    # count of knots = count of control points + degree + 1
    spline.knots = []

    # same for weights, count of weights == count of control points
    spline.weights = []


Splines by control points
-------------------------

Creating splines from fit points is the easiest way, but this method is also the
least accurate, because a spline is defined by control points and knot values,
which are generated for the case of a definition by fit points, and the worst
fact is that for every given set of fit points exist an infinite number of
possible splines as solution.

To ensure the same spline geometry for all CAD applications, the spline has to
be defined by control points.
The method :meth:`~ezdxf.layouts.BaseLayout.add_spline_control_frame` adds a
spline passing the given fit points by calculating the control points by the
`Global Curve Interpolation`_ algorithm. There is also a low level function
:func:`ezdxf.math.global_bspline_interpolation` which calculates the control
points from fit points.

.. code-block:: python

    msp.add_spline_control_frame(fit_points, method='uniform', dxfattribs={'color': 1})
    msp.add_spline_control_frame(fit_points, method='chord', dxfattribs={'color': 3})
    msp.add_spline_control_frame(fit_points, method='centripetal', dxfattribs={'color': 5})

- black curve: AutoCAD/BricsCAD spline generated from fit points
- red curve: spline curve interpolation, "uniform" method
- green curve: spline curve interpolation, "chord" method
- blue curve: spline curve interpolation, "centripetal" method

.. image:: gfx/spline3.png

Since `ezdxf` v1.1 the method :meth:`~ezdxf.layouts.BaseLayout.add_cad_spline_control_frame` 
calculates the same control points from fit points as AutoCAD and BricsCAD.

Open Spline
~~~~~~~~~~~

Add and open (clamped) spline defined by control points with the method
:meth:`~ezdxf.layouts.BaseLayout.add_open_spline`. If no `knot`_ values are
given, an open uniform knot vector will be generated. A clamped B-spline starts
at the first control point and ends at the last control point.

.. code-block:: python

    control_points = [(0, 0, 0), (1250, 1560, 0), (3130, 610, 0), (2250, 1250, 0)]
    msp.add_open_spline(control_points)

.. image:: gfx/spline4.png

Rational Spline
~~~~~~~~~~~~~~~

`Rational B-splines`_ have a weight for every control point, which can raise or
lower the influence of the control point, default weight = ``1``, to lower the
influence set a weight < ``1`` to raise the influence set a weight > ``1``.
The count of weights has to be always equal to the count of control points.

Example to raise the influence of the first control point:

.. code-block:: python

    msp.add_rational_spline(control_points, weights=[3, 1, 1, 1])

.. image:: gfx/spline6.png

Spline Tangents
---------------

The tangents of a spline are the directions of the first derivative of the curve:

.. code-block:: python

    # additional required imports:
    from ezdxf.math import Vec3, estimate_tangents
    import numpy as np

    # snip -x-x-x-

    fit_points = Vec3.list(
        [
            (0, 0, 0),
            (1000, 600, 0),
            (1500, 1200, 0),
            (500, 1250, 0),
            (0, 0, 0),
        ]
    )
    spline = msp.add_spline(fit_points)

    # draw the curve tangents as red lines:
    ct = spline.construction_tool()
    for t in np.linspace(0, ct.max_t, 30):
        point, derivative = ct.derivative(t, 1)
        msp.add_line(point, point + derivative.normalize(200), dxfattribs={"color": 1})

.. image:: gfx/spline7.png

To get a smooth closed curve the start- and end tangents have to be set manually 
when the control points are calculated and they have to point in the same direction:

.. code-block:: python

    t0= Vec3(1, -1, 0)  # the length (magnitude) of the tangent is not relevant!
    spline = msp.add_cad_spline_control_frame(fit_points, tangents=[t0, t0])

.. image:: gfx/spline8.png

To avoid guess work the function :func:`ezdxf.math.estimate_tangents` can be used to 
estimate the start- and end tangents of the curve:

.. code-block:: python

    tangents = estimate_tangents(fit_points)
    # linear interpolation of the first and the last tangent:
    t0 = tangents[0].lerp(tangents[-1], 0.5)
    msp.add_cad_spline_control_frame(fit_points, tangents=[t0, t0])

.. image:: gfx/spline9.png

It is also possible to add the SPLINE by fit-points and setting the tangents as 
DXF attributes:

.. code-block:: python

    spline = msp.add_spline(fit_points)
    spline.dxf.flags = spline.PERIODIC | spline.CLOSED
    spline.dxf.start_tangent = t0
    spline.dxf.end_tangent = t0


Spline properties
-----------------

Check if spline is a `closed curve`_ or close/open spline, for a closed spline
the last point is connected to the first point:

.. code-block:: python

    if spline.closed:
        # this spline is closed
        pass

    # close spline
    spline.closed = True

    # open spline
    spline.closed = False

Set start- and end tangent for splines defined by fit points:

.. code-block:: python

    spline.dxf.start_tangent = (0, 1, 0)
    spline.dxf.end_tangent = (0, 1, 0)

Get data count as stored in DXF attributes:

.. code-block:: python

    count = spline.dxf.n_fit_points
    count = spline.dxf.n_control_points
    count = spline.dxf.n_knots

Get data count from existing data:

.. code-block:: python

    count = spline.fit_point_count
    count = spline.control_point_count
    count = spline.knot_count


--- End of file: tutorials/spline.rst ---



--- Start of file: tutorials/text.rst ---

.. _tut_text:

.. module:: ezdxf.entities
    :noindex:

Tutorial for Text
=================

Add a simple one line text entity by factory function :meth:`~ezdxf.layouts.BaseLayout.add_text`.

.. code-block:: python

    import ezdxf
    from ezdxf.enums import TextEntityAlignment

    # The TEXT entity is a DXF primitive and is supported in all DXF versions.
    # The argument setup=True creates standard linetypes and text styles in the
    # new DXF document.
    doc = ezdxf.new("R12", setup=True)
    msp = doc.modelspace()

    # Use method set_placement() to define the TEXT alignment, because the
    # relations between the DXF attributes 'halign', 'valign', 'insert' and
    # 'align_point' are tricky.
    msp.add_text("A Simple Text").set_placement(
        (2, 3),
        align=TextEntityAlignment.MIDDLE_RIGHT
    )

    # Using a predefined text style:
    msp.add_text(
        "Text Style Example: Liberation Serif",
        height=0.35,
        dxfattribs={"style": "LiberationSerif"}
    ).set_placement((2, 6), align=TextEntityAlignment.LEFT)

    doc.saveas("simple_text.dxf")

Alignments defined by the enum :class:`~ezdxf.enums.TextEntityAlignment`:

============   =============== ================= =====
Vert/Horiz     Left            Center            Right
============   =============== ================= =====
Top            ``TOP_LEFT``    ``TOP_CENTER``    ``TOP_RIGHT``
Middle         ``MIDDLE_LEFT`` ``MIDDLE_CENTER`` ``MIDDLE_RIGHT``
Bottom         ``BOTTOM_LEFT`` ``BOTTOM_CENTER`` ``BOTTOM_RIGHT``
Baseline       ``LEFT``        ``CENTER``        ``RIGHT``
============   =============== ================= =====

Special alignments are ``ALIGNED`` and ``FIT``, they require a second alignment
point, the text is justified with the vertical alignment `Baseline` on the
virtual line between these two points.

=========== ===========
Alignment   Description
=========== ===========
``ALIGNED`` Text is stretched or compressed to fit exactly between `p1` and `p2`
            and the text height is also adjusted to preserve height/width ratio.
``FIT``     Text is stretched or compressed to fit exactly between `p1` and `p2`
            but only the text width is adjusted, the text height is fixed by the
            `height` attribute.
``MIDDLE``  also a `special` adjustment, but the result is the same as for
            ``MIDDLE_CENTER``.
=========== ===========


Standard Text Styles
--------------------

Setup some standard text styles and linetypes by argument :code:`setup=True`::

    doc = ezdxf.new('R12', setup=True)

Replaced all proprietary font declarations in :code:`setup_styles()` (ARIAL,
ARIAL_NARROW, ISOCPEUR and TIMES) by open source fonts, this is also the style
name (e.g. :code:`{'style': 'OpenSans-Italic'}`):

.. image:: gfx/fonts.png

.. important::

    To see the defined text styles in a DXF viewer or CAD application, the
    applications have to know where the referenced TTF fonts can be found.
    This configuration is not possible by `ezdxf` and has to be done for each
    application as described in their documentation.

    See also: :ref:`font resources`

New Text Style
--------------

Creating a new text style is simple:

.. code-block:: Python

    doc.styles.new("myStandard", dxfattribs={"font" : "OpenSans-Regular.ttf"})

Getting the correct font name is often not that simple, especially on Windows.
This shows the required steps to get the font name for `Open Sans`:

    - open font folder `c:\\windows\\fonts`
    - select and open the font-family `Open Sans`
    - right-click on `Open Sans Standard` and select `Properties`
    - on top of the first tab you see the font name: ``'OpenSans-Regular.ttf'``

The style name has to be unique in the DXF document, otherwise `ezdxf` will
raise an :class:`DXFTableEntryError` exception. To replace an existing entry,
delete the existing entry by :code:`doc.styles.remove(name)`, and add the
replacement entry.

3D Text
-------

It is possible to place the 2D :class:`Text` entity into 3D space by using the
:ref:`OCS`, for further information see: :ref:`tut_ocs` and
:ref:`tut_ucs_transform`.

--- End of file: tutorials/text.rst ---



--- Start of file: tutorials/ucs_transform.rst ---

.. module:: ezdxf.math
    :noindex:

.. _tut_ucs_transform:

Tutorial for UCS Based Transformations
======================================

The `ezdxf` version v0.13 introduced a transformation interface for DXF
primitives, which makes working with OCS/UCS much easier.  This is a new
edition of the :ref:`tut_ocs`.  Please read the old tutorial for the basics
about the OCS.

For this tutorial we don't have to worry about the OCS and the extrusion vector,
this is done automatically by the :meth:`transform` method of each DXF entity.

Placing 2D Circle in 3D Space
-----------------------------

To recreate the situation of the old tutorial instantiate a new UCS and rotate
it around the local x-axis.  Use UCS coordinates to place the 2D CIRCLE in
3D space and transform the UCS coordinates to the WCS.

.. literalinclude:: src/ucs/circle.py
    :lines: 6-26

.. image:: gfx/ucs-circle-side-view.png
    :alt: circle in ucs as side view
.. image:: gfx/ucs-circle-front-view.png
    :alt: circle in ucs as front view

Placing LWPolyline in 3D Space
------------------------------

Simplified LWPOLYLINE example:

.. literalinclude:: src/ucs/lwpolyline.py
    :lines: 14-26

The 2D pentagon in 3D space in BricsCAD `Left` and `Front` view.

.. image:: gfx/ucs-lwpolyline-side-view.png
    :alt: pentagon in ucs as side view
.. image:: gfx/ucs-lwpolyline-front-view.png
    :alt: pentagon in ucs as front view

Using UCS to Place 3D Polyline
------------------------------

Simplified POLYLINE example: Using a first UCS to transform the POLYLINE and a
second UCS to place the POLYLINE in 3D space.

.. literalinclude:: src/ucs/polyline3d.py
    :lines: 13-37

.. image:: gfx/ucs-polyline3d-bricscad.png
    :alt: 3d poyline with UCS


Placing 2D Text in 3D Space
---------------------------

The problem with the text rotation in the old tutorial disappears with the new
UCS based transformation method:

AutoCAD supports thickness for the TEXT entity only for `.shx` fonts and not for
true type fonts.

.. literalinclude:: src/ucs/text.py
    :lines: 13-29

.. image:: gfx/ucs-text-top-bricscad.png
    :alt: text in ucs as top view

.. image:: gfx/ucs-text-front-bricscad.png
    :alt: text in ucs as front view

Placing 2D Arc in 3D Space
--------------------------

Same as for the text example, OCS angle transformation can be ignored:

.. literalinclude:: src/ucs/arc.py
    :lines: 13-37

.. image:: gfx/ucs-arc-top.png
    :alt: arc in ucs as top view
.. image:: gfx/ucs-arc-front.png
    :alt: arc in ucs as front view

Placing Block References in 3D Space
------------------------------------

Despite the fact that block references (INSERT) can contain true 3D entities like
LINE or MESH, the INSERT entity uses the same placing principe as TEXT or ARC
shown in the previous sections.

To rotate the block reference 15 degrees around the WCS x-axis, we place the
block reference in the origin of the UCS, and rotate the UCS 90 degrees around
its local y-axis, to align the UCS z-axis with the WCS x-axis:

This is just an excerpt of the important parts, see the whole code of
`insert.py`_ at github.

.. literalinclude:: src/ucs/insert.py
    :lines: 47-58

.. image:: gfx/ucs-insert-01-iso.png
.. image:: gfx/ucs-insert-01-side.png

A more simple approach is to ignore the :attr:`rotate` attribute at all and just
rotate the UCS.  To rotate a block reference around any axis rather than the
block z-axis, rotate the UCS into the desired position.  The following example
rotates the block reference around the block x-axis by 15 degrees:

.. literalinclude:: src/ucs/insert.py
    :lines: 66-68

.. image:: gfx/ucs-insert-02-iso.png
.. image:: gfx/ucs-insert-02-side.png

The next example shows how to translate a block references with an already
established OCS:

.. literalinclude:: src/ucs/insert.py
    :lines: 72-76

.. image:: gfx/ucs-insert-03-iso.png
.. image:: gfx/ucs-insert-03-side.png

The next operation is to rotate a block reference with an established OCS,
rotation axis is the block y-axis, rotation angle is -90 degrees. The idea is
to create an UCS in the origin of the already placed block reference, UCS axis
aligned to the block axis and resetting the block reference parameters for a
new WCS transformation.

.. literalinclude:: src/ucs/insert.py
    :lines: 82-86

Reset block reference parameters, this places the block reference in the UCS
origin and aligns the block axis to the UCS axis, now we do a new transformation
from UCS to WCS:

.. literalinclude:: src/ucs/insert.py
    :lines: 88-93

.. image:: gfx/ucs-insert-04-iso.png
.. image:: gfx/ucs-insert-04-side.png

.. _insert.py: https://github.com/mozman/ezdxf/blob/master/docs/source/tutorials/src/ucs/insert.py


--- End of file: tutorials/ucs_transform.rst ---



--- Start of file: tutorials/underlay.rst ---

.. _tut_underlay:

Tutorial for Underlay and UnderlayDefinition
============================================

This example shows hot to insert a a PDF, DWF, DWFx or DGN file as drawing
underlay. Each UNDERLAY entity requires an associated UNDERLAYDEF entity in the
objects section, which stores the filename of the linked document and the
parameters of the underlay. Multiple UNDERLAY entities can share the same
UNDERLAYDEF entity.

.. important::

    The underlay file is NOT embedded into the DXF file:

.. code-block:: Python

    import ezdxf


    doc = ezdxf.new('AC1015')  # underlay requires the DXF R2000 format or later
    my_underlay_def = doc.add_underlay_def(filename='my_underlay.pdf', name='1')
    # The (PDF)DEFINITION entity is like a block definition, it just defines the underlay
    # 'name' is misleading, because it defines the page/sheet to be displayed
    # PDF: name is the page number to display
    # DGN: name='default' ???
    # DWF: ????

    msp = doc.modelspace()
    # add first underlay
    msp.add_underlay(my_underlay_def, insert=(2, 1, 0), scale=0.05)
    # The (PDF)UNDERLAY entity is like the INSERT entity, it creates an underlay reference,
    # and there can be multiple references to the same underlay in a drawing.

    msp.add_underlay(my_underlay_def, insert=(4, 5, 0), scale=.5, rotation=30)

    # get existing underlay definitions, Important: UNDERLAYDEFs resides in the objects section
    pdf_defs = doc.objects.query('PDFDEFINITION')  # get all pdf underlay defs in drawing

    doc.saveas("dxf_with_underlay.dxf")



--- End of file: tutorials/underlay.rst ---



--- Start of file: tutorials/xref_module.rst ---

.. _tut_xref_module:

Tutorial for External References
================================

.. contents::
    :local:

Introduction
------------

This tutorial uses the :mod:`ezdxf.xref` module to work with external references (XREF).

Attached XREFs are links to the modelspace of a specified drawing file. Changes made
to the referenced drawing are automatically reflected in the current drawing when it's
opened or if the XREF is reloaded.

.. important::

    **AutoCAD can only display DWG files as attached XREFs.**
    Any DXF file attached as an XREF to a DXF document must be converted to DWG in order
    to be viewed in AutoCAD.
    Fortunately, other CAD applications are more cooperative, BricsCAD has no problem
    displaying DXF files as XREFs.

    The :mod:`~ezdxf.addons.drawing` add-on included in `ezdxf` **does not display external
    references at all!**

There are some example files included in the `examples/xref <https://github.com/mozman/ezdxf/tree/master/examples/xref>`_
folder of the repository:

    - attach_dxf_dwg_xref.py
    - detach_block_as_xref.py
    - embed_dxf_dwg_xref.py
    - load_table_resources.py


Supported Entities
------------------

All operations which move entities between layouts and XREFs copy these entities,
therefore only entities which are copyable can be transferred.
The following entities are not copyable:

- All entities which are not documented by the DXF reference.
- ACAD_TABLE
- ACAD_PROXY_ENTITY
- OLE2FRAME
- ACIS based entities: BODY, 3DSOLID, REGION, ...
- Custom entities from applications on top of AutoCAD like Map 3D, Civil 3D or
  Architecture. The vertical integration stack is not documented by the DXF reference.

Unsupported entities are ignored and do not raise exceptions.

Environment Setup
-----------------

Required imports to follow this tutorial:

.. literalinclude:: src/xref/attach_dxf_dwg_xref.py
    :lines: 3-9

Function to create a simple DXF file as XREF, the insertion point of the XREF is set to
(5, 5):

.. literalinclude:: src/xref/attach_dxf_dwg_xref.py
    :lines: 14-26

Create the DXF file::

    make_dxf_xref_document("xref.dxf")

The XREF looks like this:

.. image:: gfx/xref_doc.png
    :align: center

Attach a DXF File
-----------------

Create a host document to which the XREF will be attached::

    host_doc = ezdxf.new(DXFVERSION, units=units.M)

Attach the XREF by the :func:`ezdxf.xref.attach` function and save the host DXF file::

    xref.attach(host_doc, block_name="dxf_xref", insert=(0, 0), filename="attached_xref.dxf")
    host_doc.set_modelspace_vport(height=10, center=(0, 0))
    host_doc.saveas("attach_host_dxf.dxf")


The :func:`attach` function is meant to simply attach an XREF once without any
overhead, therefore the :func:`attach` function creates the required block definition
automatically and raises an :class:`XrefDefinitionError` exception if the block definition
already exist. To attach additional XREF references use the method
:meth:`~ezdxf.layouts.BaseLayout.add_blockref`::

    msp.add_blockref("dxf_xref", insert=another_location)


The attached DXF file in BricsCAD:

.. image:: gfx/xref_attached_dxf.png
    :align: center

.. important::

    AutoCAD can not display DXF files as attached XREFs.

Attach a DWG File
-----------------

Export the DXF file as DWG by the :mod:`~ezdxf.addons.odafc` add-on::

    # It's not required to save the DXF file!
    doc = make_dxf_xref_document("attached_xref.dxf")
    try:
        odafc.export_dwg(doc, "attached_xref.dwg", replace=True)
    except odafc.ODAFCError as e:
        print(str(e))

Attach the DWG file by the :func:`ezdxf.xref.attach` function and save the host DXF file::

    host_doc = ezdxf.new(DXFVERSION, units=units.M)
    xref.attach(host_doc, block_name="dwg_xref", filename="attached_xref.dwg", insert=(0, 0))
    host_doc.set_modelspace_vport(height=10, center=(0, 0))
    host_doc.saveas("attached_dwg.dxf")


Attached DWG file in Autodesk DWG TrueView 2023:

.. image:: gfx/xref_attached_dwg.png
    :align: center

Detach an XREF
--------------

The :func:`~ezdxf.xref.detach` function writes the content of a block definition into
the modelspace of a new DXF document and convert the block to an external reference (XREF).
The new DXF document has to be written/exported by the caller.
The function does not create any block references. These references should already exist
and do not need to be changed since references to blocks and XREFs are the same.

.. literalinclude:: src/xref/detach_dxf_dwg_xref.py
    :lines: 23-29

.. important::

    Save the host document after detaching the block!
    Detaching a block definition modifies the host document.

The :func:`detach` function returns a :class:`Drawing` instance, so it's possible
to convert the DXF document to DWG by the :mod:`~ezdxf.addons.odafc` add-on if necessary
(e.g. for Autodesk products). It's important that the argument :attr:`xref_filename`
match the filename of the exported DWG file:

.. literalinclude:: src/xref/detach_dxf_dwg_xref.py
    :lines: 33-42

It's recommended to clean up the entity database of the host document afterwards::

    host_doc.entitydb.purge()

For understanding, this is the :func:`make_block` function:

.. literalinclude:: src/xref/detach_dxf_dwg_xref.py
    :lines: 10-19

Embed an XREF
-------------

The :func:`embed` function loads the content of the XREF into the block definition,
this is the reverse operation of detaching an XREF.

For loading the content of DWG files is a loading function required, which loads the
DWG file as :class:`Drawing` document. The :mod:`~ezdxf.addons.odafc` add-on module
provides such a function: :func:`~ezdxf.addons.odafc.readfile`.

This example embeds the XREF "attached_xref.dwg" of the first example as content of the
block definition "GEAR", the "attach_host_dwg.dxf" file is the host DXF document:

.. code-block:: Python

    import ezdxf
    from ezdxf.addons import odafc

    doc = ezdxf.readfile("attach_host_dwg.dxf")
    gear_xref = doc.blocks.get("GEAR")

    try:
        xref.embed(gear_xref, load_fn=odafc.readfile)
    except FileNotFoundError as e:
        print(str(e))

The default loading function for DXF files is the :func:`ezdxf.readfile` function and
doesn't have to be specified. For the loading function from the :mod:`~ezdxf.recover`
module use a lambda function:

.. code-block:: Python

    import ezdxf
    from ezdxf import recover

    doc = ezdxf.readfile("attach_host_dxf.dxf")
    gear_xref = doc.blocks.get("GEAR")

    try:
        xref.embed(gear_xref, load_fn=lambda f: recover.readfile(f)[0])
    except FileNotFoundError as e:
        print(str(e))


Load Modelspace
---------------

The :func:`ezdxf.xref.load_modelspace` function loads the content of the modelspace
of the source document into a layout of the target document, the modelspace of the
target document is the default target layout.

.. hint::

    Use this function to combine multiple existing DXF files.
    If the goal is just to add new entities to an existing document, rather load the
    source document as a template by :func:`ezdxf.readfile`, add your content and save
    the document as a new DXF file with the :meth:`saveas` method.

Merge multiple DXF files:

.. literalinclude:: src/xref/merge_dxf_files.py
    :lines: 3-26

.. image:: gfx/xref_merged.png
    :align: center

Load Paperspace
---------------

The function :func:`ezdxf.xref.load_paperspace` loads a paperspace layout as a new
paperspace layout into the target document. To be clear this function loads **only**
the content of the paperspace layout, the content of the modelspace isn't loaded,
therefore the loaded VIEWPORT entities show the content of the target modelspace.


Write Block
-----------

The function :func:`ezdxf.xref.write_block` writes the given entities into the
modelspace of a new DXF document, this document can be, but doesn't have to be used as
an external referenced block.

Conflict Policies
-----------------

Resources are definitions of layers, linetypes, text-, dimension-, mline- and mleader
styles, materials and blocks.

A resource conflict occurs when the source and target documents contain elements such as
layers, linetypes, text styles and so on that share the same name.

Many of the functions shown above support an argument to define the
:class:`ezdxf.xref.ConflictPolicy`, that gives you the choice how to handle resource
name conflicts.

ConflictPolicy.KEEP
~~~~~~~~~~~~~~~~~~~

Keeps the existing resource name of the target document and ignore the resource from the
source document. The loaded entities from the source document use the resources defined
in the target document and may alter their visual appearance, when the resources are
different.

ConflictPolicy.XREF_PREFIX
~~~~~~~~~~~~~~~~~~~~~~~~~~

This policy handles the resource import like CAD applications by **always** renaming the
loaded resources to `<xref>$0$<name>`, where `xref` is the name of source document,
the `$0$` part is a number to create a unique resource name and `<name>` is the name of
the resource itself.

.. important::

    This policy ALWAYS renames the resource, even if the loaded resource doesn't have a
    conflict in the target document.

ConflictPolicy.NUM_PREFIX
~~~~~~~~~~~~~~~~~~~~~~~~~~

This policy renames the loaded resources to `$0$<name>` only if the resource `<name>`
already exists. The `$0$` prefix is a number to create a unique resource name and
`<name>` is the name of the resource itself.

.. important::

    This policy renames the resource ONLY when the loaded resource has a conflict in
    the target document.

Load Table Resources
--------------------

Resources are definitions of layers, linetypes, text-, dimension-, mline- and mleader
styles, materials and blocks.

The :class:`Loader` class is the low level tool to build a loading operation from simple
loading commands. Study the `source code`_ of the :mod:`xref` module, most of loading
commands used above are build upon the :class:`Loader` class.
This example shows how to import layer, linetype, text- and dimension style definitions:

.. code-block:: Python

    import ezdxf
    from ezdxf import xref

    sdoc = ezdxf.new(setup=True)
    tdoc = ezdxf.new()

    # The default conflict policy is ConflictPolicy.KEEP
    loader = xref.Loader(sdoc, tdoc)

    # Load all layers:
    loader.load_layers([layer.dxf.name for layer in sdoc.layers])

    # Load specific linetypes:
    loader.load_linetypes(["CENTER", "DASHED", "DASHDOT"])

    # Load specific text style:
    loader.load_text_styles(["OpenSans", "LiberationMono"])

    # Load all DIMENSION styles, this command loads also the dependent text styles:
    loader.load_dim_styles([dimstyle.dxf.name for dimstyle in sdoc.dimstyles])

    # execute all loading commands:
    loader.execute()
    tdoc.saveas("target.dxf")

.. note::

    Loading a layer does not load the entities which do reference this layer, a layer
    is not an entity container, it's just an DXF attribute, see also Basic Concepts:
    :ref:`layer_concept`.

.. _source code: https://github.com/mozman/ezdxf/blob/master/src/ezdxf/xref.py

--- End of file: tutorials/xref_module.rst ---



--- Start of file: upright.rst ---

Upright
=======

.. module:: ezdxf.upright

The functions in this module can help to convert an inverted :ref:`OCS` defined
by an extrusion vector (0, 0, -1) into a :ref:`WCS` aligned OCS defined by
an extrusion vector (0, 0, 1).

This simplifies 2D entity processing for `ezdxf` users and creates DXF
output for 3rd party DXF libraries which ignore the existence of the :ref:`OCS`.

Supported DXF entities:

- CIRCLE
- ARC
- ELLIPSE (WCS entity, flips only the extrusion vector)
- SOLID
- TRACE
- LWPOLYLINE
- POLYLINE (only 2D entities)
- HATCH
- MPOLYGON
- INSERT (block references)

.. warning::

    The WCS representation of OCS entities with flipped extrusion vector
    is not 100% identical to the source entity, curve orientation and vertex order
    may change, see `additional explanation`_ below.
    A mirrored text represented by an extrusion vector (0, 0, -1)
    cannot represented by an extrusion vector (0, 0, 1), therefore this CANNOT
    work for text entities or entities including text:
    TEXT, ATTRIB, ATTDEF, MTEXT, DIMENSION, LEADER, MLEADER

Usage
-----

The functions can be applied to any DXF entity without expecting errors or
exceptions if the DXF entity is not supported or the extrusion vector differs
from (0, 0, -1). This also means you can apply the functions multiple times to
the same entities without any problems. A common case would be to upright all
entities of the model space:

.. code-block:: Python

    import ezdxf
    from ezdxf.upright import upright_all

    doc = ezdxf.readfile("your.dxf")
    msp = doc.modelspace()
    upright_all(msp)
    # doing it again is no problem but also has no further effects
    upright_all(msp)

Another use case is exploding block references (INSERT) which may include
reflections (= scaling by negative factors) that can lead to inverted
extrusion vectors.

.. code-block:: Python

    for block_ref in msp.query("INSERT"):
        entities = block_ref.explode()  # -> EntityQuery object
        upright_all(entities)

Functions
---------

.. autofunction:: upright

.. autofunction:: upright_all


Additional Explanation
----------------------

This example shows why the entities with an inverted OCS, extrusion vector is
(0, 0, -1), are not exact the same as with an WCS aligned OCS, extrusion vector
is (0, 0, 1).

.. note::

    The ARC entity represents the curve **always** in counter-clockwise
    orientation around the extrusion vector.

.. code-block:: Python

    import ezdxf
    from ezdxf.upright import upright
    from ezdxf.math import Matrix44

    doc = ezdxf.new()
    msp = doc.modelspace()

    arc = msp.add_arc(
        (5, 0),
        radius=5,
        start_angle=-90,
        end_angle=90,
        dxfattribs={"color": ezdxf.const.RED},
    )
    # draw lines to the start- and end point of the ARC
    msp.add_line((0, 0), arc.start_point, dxfattribs={"color": ezdxf.const.GREEN})
    msp.add_line((0, 0), arc.end_point, dxfattribs={"color": ezdxf.const.BLUE})

    # copy arc
    mirrored_arc = arc.copy()
    msp.add_entity(mirrored_arc)

    # mirror copy
    mirrored_arc.transform(Matrix44.scale(-1, 1, 1))

    # This creates an inverted extrusion vector:
    assert mirrored_arc.dxf.extrusion.isclose((0, 0, -1))

    # draw lines to the start- and end point of the mirrored ARC
    msp.add_line((0, 0), mirrored_arc.start_point, dxfattribs={"color": ezdxf.const.GREEN})
    msp.add_line((0, 0), mirrored_arc.end_point, dxfattribs={"color": ezdxf.const.BLUE})

Result without applying the :func:`upright` function - true mirroring:

.. image:: gfx/upright_arc_0.png
    :align: center
    :width: 600px

.. code-block:: Python

    ...

    # This creates an inverted extrusion vector:
    assert mirrored_arc.dxf.extrusion.isclose((0, 0, -1))

    start_point_inv = mirrored_arc.start_point
    end_point_inv = mirrored_arc.end_point

    upright(mirrored_arc)
    # OCS is aligned with WCS:
    assert mirrored_arc.dxf.extrusion.isclose((0, 0, 1))

    # start- and end points are swapped after applying upright()
    assert mirrored_arc.start_point.isclose(end_point_inv)
    assert mirrored_arc.end_point.isclose(start_point_inv)

    # draw lines to the start- and end point of the mirrored ARC
    msp.add_line((0, 0), mirrored_arc.start_point, dxfattribs={"color": ezdxf.const.GREEN})
    msp.add_line((0, 0), mirrored_arc.end_point, dxfattribs={"color": ezdxf.const.BLUE})

Result after applying the :func:`upright` function - false mirroring:

.. image:: gfx/upright_arc_1.png
    :align: center
    :width: 600px

To avoid this issue the ARC entity would have to represent the curve in clockwise
orientation around the extrusion vector (0, 0, 1), which is not possible!

.. note::

    The shape of the mirrored arcs is the same for both extrusion vectors, but
    the start- and the end points are swapped (reversed vertex order)!


--- End of file: upright.rst ---



--- Start of file: usage_for_beginners.rst ---

.. _arch-usr:

Usage for Beginners
===================

This section shows the intended usage of the `ezdxf` package.
This is just a brief overview for new `ezdxf` users, follow the provided links
for more detailed information.


First import the package::

    import ezdxf

Loading DXF Files
-----------------

`ezdxf` supports loading ASCII and binary DXF documents from a file::

    doc = ezdxf.readfile(filename)

or from a zip-file::

    doc = ezdxf.readzip(zipfilename[, filename])

Which loads the DXF document `filename` from the zip-file `zipfilename` or the
first DXF file in the zip-file if `filename` is absent.

It is also possible to read a DXF document from a stream by the :func:`ezdxf.read`
function, but this is a more advanced feature, because this requires detection
of the file encoding in advance.

This works well with DXF documents from trusted sources like AutoCAD or BricsCAD.
For loading DXF documents with minor or major flaws use the :mod:`ezdxf.recover`
module.

.. seealso::

    Documentation for :func:`ezdxf.readfile`, :func:`ezdxf.readzip` and
    :func:`ezdxf.read`, for more information about file
    management go to the :ref:`dwgmanagement` section. For loading DXF documents
    with structural errors look at the :mod:`ezdxf.recover` module.

Layouts and Blocks
------------------

Layouts are containers for DXF entities like LINE or CIRCLE. The most important
layout is the modelspace labeled as "Model" in CAD applications which represents
the "world" work space. Paperspace layouts represents plottable sheets which
contains often the framing and the tile block of a drawing and VIEWPORT entities
as scaled and clipped "windows" into the modelspace.

The modelspace is always present and can not be deleted. The active paperspace
is also always present in a new DXF document but can be deleted, in that case
another paperspace layout gets the new active paperspace, but you can not delete
the last paperspace layout.

Getting the modelspace of a DXF document::

    msp = doc.modelspace()

Getting a paperspace layout by the name as shown in the tab of a
CAD application::

    psp = doc.paperspace("Layout1")

A block is just another kind of entity space, which can be inserted
multiple times into other layouts and blocks by the INSERT entity also called
block references, this is a very powerful and an important concept of the DXF
format.

Getting a block layout by the block name::

    blk = doc.blocks.get("NAME")


All these layouts have factory functions to create graphical DXF entities for
their entity space, for more information about creating entities see section:
`Create new DXF Entities`_

Query DXF Entities
------------------

As said in the `Layouts and Blocks`_ section, all graphical DXF entities are
stored in layouts, all these layouts can be iterated and do support the index
operator e.g. :code:`layout[-1]` returns the last entity.

The main difference between iteration and index access is, that iteration filters
destroyed entities, but the index operator returns also destroyed entities
until these entities are purged by :code:`layout.purge()`, more about this topic
in section: `Delete Entities`_.

There are two advanced query methods: :meth:`~ezdxf.layouts.BaseLayout.query`
and :meth:`~ezdxf.layouts.BaseLayout.groupby`.

Get all lines of layer ``"MyLayer"``::

    lines = msp.query('LINE[layer=="MyLayer"]')

This returns an :class:`~ezdxf.query.EntityQuery` container, which also provides
the same :meth:`query` and :meth:`groupby` methods.

Get all lines categorized by a DXF attribute like color::

    all_lines_by_color = msp.query("LINE").groupby("color")
    lines_with_color_1 = all_lines_by_color.get(1, [])

The :meth:`groupby` method returns a regular Python :class:`dict` with colors as
key and a regular Python :class:`list` of entities as values
(not an :class:`~ezdxf.query.EntityQuery` container).

.. seealso::

    For more information go to the :ref:`tut_getting_data`

Examine DXF Entities
--------------------

Each DXF entity has a :attr:`dxf` namespace attribute, which stores the named
DXF attributes, some entity attributes and assets are only available from
Python properties or methods outside the :attr:`dxf` namespace like the
vertices of the LWPOLYLINE entity. More information about the DXF attributes of
each entity can found in the documentation of the :mod:`ezdxf.entities` module.

Get some basic DXF attributes::

    layer = entity.dxf.layer  # default is "0"
    color = entity.dxf.color  # default is 256 = BYLAYER

Most DXF attributes have a default value, which will be returned if the DXF
attribute is not present, for DXF attributes without a default value you can
check if the attribute really exist::

    entity.dxf.hasattr("true_color")

or use the :meth:`get` method and provide a default value::

    entity.dxf.get("true_color", 0)

.. seealso::

    - :ref:`Common graphical DXF attributes`
    - Helper class :class:`ezdxf.gfxattribs.GfxAttribs` for building DXF attribute
      dictionaries.

Create a New DXF File
---------------------

Create new document for the latest supported DXF version::

    doc = ezdxf.new()

Create a new DXF document for a specific DXF version, e.g. for DXF R12::

    doc = ezdxf.new("R12")


The :func:`ezdxf.new` function can create some standard resources, such as
linetypes and text styles, by setting the argument `setup` to ``True``::

    doc = ezdxf.new(setup=True)

.. seealso::

    - :ref:`tut_simple_drawings`
    - Documentation for :func:`ezdxf.new`, for more information about file
      management go to the :ref:`dwgmanagement` section.

Create New DXF Entities
-----------------------

The factory methods for creating new graphical DXF entities are located in the
:class:`~ezdxf.layouts.BaseLayout` class and these factory methods are
available for all entity containers:

    - :class:`~ezdxf.layouts.Modelspace`
    - :class:`~ezdxf.layouts.Paperspace`
    - :class:`~ezdxf.layouts.BlockLayout`

The usage is simple::

    msp = doc.modelspace()
    msp.add_line((0, 0), (1, 0), dxfattribs={"layer": "MyLayer"})


A few important/required DXF attributes are explicit method arguments,
most additional DXF attributes are gives as a regular Python
:class:`dict` object by the keyword only argument :attr:`dxfattribs`.
The supported DXF attributes can be found in the documentation of the
:mod:`ezdxf.entities` module.

.. warning::

    Do not instantiate DXF entities by yourself and add them to layouts, always
    use the provided factory methods to create new graphical entities, this is
    the intended way to use `ezdxf`.

.. seealso::

    - :ref:`thematic_factory_method_index`
    - :ref:`tut_simple_drawings`
    - :ref:`tut_dxf_primitives`
    - :ref:`tut_lwpolyline`
    - :ref:`tut_text`
    - :ref:`tut_mtext`
    - :ref:`tut_hatch`

Saving DXF Files
----------------

Save the DXF document with a new name::

    doc.saveas("new_name.dxf")

or with the same name as loaded::

    doc.save()

.. seealso::

    Documentation for :func:`ezdxf.document.Drawing.save` and
    :func:`ezdxf.document.Drawing.saveas`, for more information about file
    management go to the :ref:`dwgmanagement` section.

Create New Blocks
-----------------

The block definitions of a DXF document are managed by the
:class:`~ezdxf.sections.blocks.BlocksSection` object::

    my_block = doc.blocks.new("MyBlock")

.. seealso::

    :ref:`tut_blocks`


Create Block References
-----------------------

A block reference is just another DXF entity called INSERT.
The :class:`~ezdxf.entities.Insert` entity is created by the factory method:
:meth:`~ezdxf.layouts.BaseLayout.add_blockref`::

    msp.add_blockref("MyBlock", (0, 0))


.. seealso::

    See :ref:`tut_blocks` for more advanced features like using
    :class:`~ezdxf.entities.Attrib` entities.


Create New Layers
-----------------

A layer is not an entity container, a layer is just another DXF attribute
stored in the entity and the entity can inherit some properties from this
:class:`~ezdxf.entities.Layer` object.
Layer objects are stored in the layer table which is available as
attribute :code:`doc.layers`.

You can create your own layers::

    my_layer = doc.layers.add("MyLayer")

The layer object also controls the visibility of entities which references this
layer, the on/off state of the layer is unfortunately stored as positive or
negative color value which make the raw DXF attribute of layers useless, to
change the color of a layer use the property :attr:`Layer.color` ::

    my_layer.color = 1

To change the state of a layer use the provided methods of the
:class:`~ezdxf.entities.Layer` object, like
:meth:`~ezdxf.entities.Layer.on`, :meth:`~ezdxf.entities.Layer.off`,
:meth:`~ezdxf.entities.Layer.freeze` or :meth:`~ezdxf.entities.Layer.thaw`::

    my_layer.off()

.. seealso::

    :ref:`layer_concept`

Delete Entities
---------------

The safest way to delete entities is to delete the entity from the layout
containing that entity::

    line = msp.add_line((0, 0), (1, 0))
    msp.delete_entity(line)

This removes the entity immediately from the layout and destroys the entity.
The property :attr:`~ezdxf.entities.DXFEntity.is_alive` returns ``False`` for a
destroyed entity and all Python attributes are deleted, so
:code:`line.dxf.color` will raise an :class:`AttributeError` exception,
because ``line`` does not have a :attr:`~ezdxf.entities.DXFEntity.dxf`
attribute anymore.

`Ezdxf` also supports manually destruction of entities by calling the method
:meth:`~ezdxf.entities.DXFEntity.destroy`::

    line.destroy()

Manually destroyed entities are not removed immediately from entities containers
like :class:`Modelspace` or :class:`EntityQuery`, but iterating such a container
will filter destroyed entities automatically, so a :code:`for e in msp: ...` loop
will never yield destroyed entities. The index operator and the :func:`len`
function do **not** filter deleted entities, to avoid getting deleted entities
call the :func:`purge` method of the container manually to remove deleted
entities.

Further Information
-------------------

- :ref:`basic concepts`: what is the meaning or purpose of ...
- :ref:`tasks`: how to accomplish certain tasks
- :ref:`reference`



--- End of file: usage_for_beginners.rst ---



--- Start of file: user_record.rst ---


.. module:: ezdxf.urecord

Custom XRecord
==============

The :class:`UserRecord` and :class:`BinaryRecord` classes help to store
custom data in DXF files in :class:`~ezdxf.entities.XRecord` objects a simple
and safe way. This way requires DXF version R2000 or later, for DXF version
R12 the only way to store custom data is :ref:`extended_data`.

The :class:`UserRecord` stores Python types and nested container types:
``int``, ``float``, ``str``, :class:`~ezdxf.math.Vec2`, :class:`~ezdxf.math.Vec3`,
``list`` and ``dict``.

Requirements for Python structures:

- The top level structure has to be a ``list``.
- Strings has to have max. 2049 characters and can not contain line breaks
  ``"\\n"`` or ``"\\r"``.
- Dict keys have to be simple Python types: ``int``, ``float``, ``str``.

DXF Tag layout for Python types and structures stored in the
:class:`~ezdxf.entities.XRecord` object:

Only for the :class:`UserRecord` the first tag is (2, user record name).

=========== ===========================================================
Type        DXF Tag(s)
=========== ===========================================================
str         (1, value) string with less than 2050 chars and including no line breaks
int         (90, value) int 32-bit, restricted by the DXF standard not by Python!
float       (40, value) "C" double
Vec2        (10, x), (20, y)
Vec3        (10, x) (20, y) (30, z)
list        starts with (2, "[")  and ends with (2, "]")
dict        starts with (2, "{")  and ends with (2, "}")
=========== ===========================================================

The :class:`BinaryRecord` stores arbitrary binary data as `BLOB`_.

Storage size limits of XRECORD according the DXF reference:

    "This object is similar in concept to XDATA but is not limited by size or order."

For usage look at this `example`_ at github or go to the tutorial:
:ref:`tut_custom_data`.

.. seealso::

    - Tutorial: :ref:`tut_custom_data`
    - `Example`_ at github
    - :class:`ezdxf.entities.XRecord`

UserRecord
----------

.. class:: UserRecord

    .. attribute:: xrecord

        The underlying :class:`~ezdxf.entities.XRecord` instance

    .. attribute:: name

        The name of the :class:`UserRecord`, an arbitrary string with less than
        2050 chars and including no line breaks.

    .. attribute:: data

        The Python data. The top level structure has to be a list
        (:class:`MutableSequence`). Inside this container the following Python
        types are supported: str, int, float, Vec2, Vec3, list, dict

        Nested data structures are supported list or/and dict in list or dict.
        Dict keys have to be simple Python types: int, float, str.

    .. autoproperty:: handle

    .. automethod:: __init__

    .. automethod:: __str__

    .. automethod:: commit

BinaryRecord
------------

.. class:: BinaryRecord

    .. attribute:: xrecord

        The underlying :class:`~ezdxf.entities.XRecord` instance

    .. attribute:: data

        The binary data as bytes, bytearray or memoryview.

    .. autoproperty:: handle

    .. automethod:: __init__

    .. automethod:: __str__

    .. automethod:: commit


.. _BLOB: https://en.wikipedia.org/wiki/Binary_large_object

.. _example: https://github.com/mozman/ezdxf/blob/master/examples/user_data_stored_in_XRECORD.py

--- End of file: user_record.rst ---



--- Start of file: user_xdata.rst ---


.. module:: ezdxf.entities.xdata
    :noindex:

Custom XDATA
============

The classes :class:`XDataUserList` and :class:`XDataUserDict` manage
custom user data stored in the XDATA section of a DXF entity. For more
information about XDATA see reference section: :ref:`extended_data`

These classes store only a limited set of data types with fixed group codes and
the types are checked by :func:`isinstance` so a :class:`Vec3` object can not
be replaced by a (x, y, z)-tuple:

=========== ============
Group Code  Data Type
=========== ============
1000        str, limited to 255 characters, line breaks ``"\n"`` and ``"\r"``
            are not allowed
1010        Vec3
1040        float
1071        32-bit int, restricted by the DXF standard not by Python!
=========== ============

Strings are limited to 255 characters, line breaks ``"\n"`` and ``"\r"`` are
not allowed.

This classes assume a certain XDATA structure and therefore can not manage
arbitrary XDATA!

This classes do not create the required AppID table entry, only the
default AppID "EZDXF" exist by default. Setup a new AppID in the AppID
table: :code:`doc.appids.add("MYAPP")`.

For usage look at this `example`_ at github or go to the tutorial:
:ref:`tut_custom_data`.

.. seealso::

    - Tutorial: :ref:`tut_custom_data`
    - `Example`_ at github
    - XDATA reference: :ref:`extended_data`
    - XDATA management class: :class:`XData`


XDataUserList
-------------

.. class:: XDataUserList

    Manage user data as a named list-like object in XDATA. Multiple user lists
    with different names can be stored in a single :class:`XData` instance
    for a single AppID.

    Recommended usage by context manager :meth:`entity`::

        with XDataUserList.entity(entity, name="MyList", appid="MYAPP") as ul:
            ul.append("The value of PI")  # str "\n" and "\r" are not allowed
            ul.append(3.141592)  # float
            ul.append(1) # int
            ul.append(Vec3(1, 2, 3)) # Vec3

            # invalid data type raises DXFTypeError
            ul.append((1, 2, 3))  # tuple instead of Vec3

            # retrieve a single value
            s = ul[0]

            # store whole content into a Python list
            data = list(ul)


    Implements the :class:`MutableSequence` interface.

    .. attribute:: xdata

        The underlying :class:`XData` instance.

    .. automethod:: __init__

    .. automethod:: __str__

    .. automethod:: __len__

    .. automethod:: __getitem__

    .. automethod:: __setitem__

    .. automethod:: __delitem__

    .. automethod:: entity

    .. automethod:: commit

XDataUserDict
-------------

.. class:: XDataUserDict

    Manage user data as a named dict-like object in XDATA. Multiple user dicts
    with different names can be stored in a single :class:`XData` instance
    for a single AppID. The keys have to be strings.

    Recommended usage by context manager :meth:`entity`::

        with XDataUserDict.entity(entity, name="MyDict", appid="MYAPP") as ud:
            ud["comment"] = "The value of PI"  # str "\n" and "\r" are not allowed
            ud["pi"] = 3.141592  # float
            ud["number"] = 1 # int
            ud["vertex"] = Vec3(1, 2, 3) # Vec3

            # invalid data type raises DXFTypeError
            ud["vertex"] = (1, 2, 3)  # tuple instead of Vec3

            # retrieve single values
            s = ud["comment"]
            pi = ud.get("pi", 3.141592)

            # store whole content into a Python dict
            data = dict(ud)

    Implements the :class:`MutableMapping` interface.

    The data is stored in XDATA like a :class:`XDataUserList` by (key, value)
    pairs, therefore a :class:`XDataUserDict` can also be loaded as
    :class:`XDataUserList`. It is not possible to distinguish a
    :class:`XDataUserDict` from a :class:`XDataUserList` except by the name of
    the data structure.

    .. attribute:: xdata

        The underlying :class:`XData` instance.

    .. automethod:: __init__

    .. automethod:: __str__

    .. automethod:: __len__

    .. automethod:: __getitem__

    .. automethod:: __setitem__

    .. automethod:: __delitem__

    .. automethod:: discard

    .. automethod:: __iter__

    .. automethod:: entity

    .. automethod:: commit


.. _example: https://github.com/mozman/ezdxf/blob/master/examples/user_data_stored_in_XDATA.py

--- End of file: user_xdata.rst ---



--- Start of file: xdata.rst ---

.. _extended_data:

Extended Data (XDATA)
=====================

Extended data (XDATA) is a DXF tags structure to store arbitrary data in DXF
entities. The XDATA is associated to an :class:`~ezdxf.entities.AppID` and only
one tag list is supported for each AppID per entity.

.. warning::

    Low level usage of XDATA is an advanced feature, it is the responsibility
    of the programmer to create valid XDATA structures. Any errors can
    invalidate the DXF file!

This section shows how to store DXF tags directly in DXF entity but there is
also a more user friendly and safer way to store custom XDATA in DXF entities:

- :class:`~ezdxf.entities.xdata.XDataUserList`
- :class:`~ezdxf.entities.xdata.XDataUserDict`

Use the high level methods of :class:`~ezdxf.entities.DXFEntity` to manage XDATA
tags.

- :meth:`~ezdxf.entities.DXFEntity.has_xdata`
- :meth:`~ezdxf.entities.DXFEntity.get_xdata`
- :meth:`~ezdxf.entities.DXFEntity.set_xdata`

Get XDATA tags as a :class:`ezdxf.lldxf.tags.Tags` data structure, **without**
the mandatory first tag (1001, AppID)::

    if entity.has_xdata("EZDXF"):
        tags = entity.get_xdata("EZDXF")

    # or use alternatively:
    try:
        tags = entity.get_xdata("EZDXF")
    except DXFValueError:
        # XDATA for "EZDXF" does not exist
        ...

Set DXF tags as list of (group code, value) tuples or as
:class:`ezdxf.lldxf.tags.Tags` data structure, valid DXF tags for XDATA are
documented in the section about the :ref:`xdata_internals` internals.
The mandatory first tag (1001, AppID) is inserted automatically if not present.

Set only new XDATA tags::

    if not entity.has_xdata("EZDXF"):
        entity.set_xdata("EZDXF", [(1000, "MyString")])

Replace or set new XDATA tags::

    entity.set_xdata("EZDXF", [(1000, "MyString")])


.. seealso::

    - Tutorial: :ref:`tut_custom_data`
    - Internals about :ref:`xdata_internals` tags
    - Internal XDATA management class: :class:`~ezdxf.entities.xdata.XData`
    - `DXF R2018 Reference <https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A2A628B0-3699-4740-A215-C560E7242F63>`_

--- End of file: xdata.rst ---



--- Start of file: xdict.rst ---

.. _extension_dictionary:

Extension Dictionary
====================

.. module:: ezdxf.entities.xdict

Every entity can have an extension dictionary, which can reference arbitrary
DXF objects from the OBJECTS section but not graphical entities. Using this
mechanism, several applications can attach data to the same entity.
The usage of extension dictionaries is more complex than :ref:`extended_data`
but also more flexible with higher capacity for adding data.

Use the high level methods of :class:`~ezdxf.entities.DXFEntity` to manage
extension dictionaries.

- :meth:`~ezdxf.entities.DXFEntity.has_extension_dict`
- :meth:`~ezdxf.entities.DXFEntity.get_extension_dict`
- :meth:`~ezdxf.entities.DXFEntity.new_extension_dict`
- :meth:`~ezdxf.entities.DXFEntity.discard_extension_dict`

The main data storage objects referenced by extension dictionaries are:

- :class:`~ezdxf.entities.Dictionary`, structural container
- :class:`~ezdxf.entities.DictionaryVar`, stores a single string
- :class:`~ezdxf.entities.XRecord`, stores arbitrary data

.. seealso::

    - Tutorial: :ref:`tut_custom_data`

.. class:: ExtensionDict

    Internal management class for extension dictionaries.

    .. seealso::

        - Underlying DXF :class:`~ezdxf.entities.Dictionary` class
        - DXF Internals: :ref:`extension_dict_internals`
        - `DXF R2018 Reference`_

    .. autoproperty:: is_alive

    .. automethod:: __contains__

    .. automethod:: __getitem__

    .. automethod:: __setitem__

    .. automethod:: __delitem__

    .. automethod:: __len__

    .. automethod:: get

    .. automethod:: keys

    .. automethod:: items

    .. automethod:: discard

    .. automethod:: add_dictionary

    .. automethod:: add_dictionary_var

    .. automethod:: add_xrecord

    .. automethod:: link_dxf_object

    .. automethod:: destroy

.. _DXF R2018 Reference: https://help.autodesk.com/view/OARX/2018/ENU/?guid=GUID-A55D4A3D-67CF-417E-B63F-3124CD8027FD

--- End of file: xdict.rst ---



--- Start of file: xref.rst ---

.. _external_references:

.. module:: ezdxf.xref

External References (XREF)
==========================

.. versionadded:: 1.1

Attached XREFs are links to the modelspace of a specified drawing file. Changes made
to the referenced drawing are automatically reflected in the current drawing when it's
opened or if the XREF is reloaded.

XREFs can be nested within other XREFs: that is, you can attach an XREF that contains
another XREF. You can attach as many copies of an XREF as you want, and each copy can
have a different position, scale, and rotation.

You can also overlay an XREF on your drawing. Unlike an attached XREF, an overlaid XREF
is not included when the drawing is itself attached or overlaid as an XREF to another
drawing.

DXF Files as Attached XREFs
---------------------------

.. important::

    AutoCAD can only display DWG files as attached XREFs but `ezdxf` can only create
    DXF files.  Consequently, any DXF file attached as an XREF to a DXF document must
    be converted to DWG in order to be viewed in AutoCAD.
    Fortunately, other CAD applications are more cooperative, BricsCAD has no problem
    displaying DXF files as XREFs, although it is not possible to attach a DXF file as an
    XREF in the BricsCAD application itself.

The :mod:`ezdxf.xref` module provides an interface for working with XREFs.

    - :func:`attach` - attach a DXF/DWG file as XREF
    - :func:`detach` - detach a BLOCK definition as XREF
    - :func:`embed` - embed an XREF as a BLOCK definition
    - :func:`dxf_info` - scans a DXF file for basic settings and properties

For loading the content of DWG files is a loading function required, which loads the
DWG file as :class:`Drawing` document. The :mod:`~ezdxf.addons.odafc` add-on module
provides such a function: :func:`~ezdxf.addons.odafc.readfile`

.. seealso::

    - :ref:`tut_xref_module`

XREF Structures
---------------

An XREF is a normal block definition located in the BLOCKS section with special flags
set and a filename to the referenced DXF/DWG file and without any content, the block
content is the modelspace of the referenced file.  An XREF can be referenced (inserted)
by one or multiple INSERT entities.

Find block definitions in the BLOCKS section:

.. code-block:: Python

    for block_layout in doc.blocks:
        block = block_layout.block  # the BLOCK entity
        if block.is_xref:
            handle_xref(block_layout)
        elif block.is_xref_overlay:
            handle_xref_overlay(block_layout)

Find XREF references in modelspace:

.. code-block:: Python

    for insert in msp.query("INSERT"):
        if insert.is_xref:
            handle_xref_reference(insert)
            # ... or get the XREF definition
            block_layout = insert.block()
            if block_layout is not None:
                handle_xref_definition(block_layout)

Use the helper function :func:`define` to create your own XREF definition, the
:func:`attach` creates this definition automatically and raises an exception if the
block already exists.

Supported Entities
------------------

The current implementation supports only copyable and transformable DXF entities,
these are all basic entity types as LINE, CIRCLE, ... and block references and their
associated required table entries and objects from the OBJECTS section.

Unsupported is the ACAD_TABLE entity and preserved unknown entities wrapped in a 
:class:`DXFTagStorage` class like proxy entities and objects.
Support for these entities may be added in a later version of `ezdxf`.
Unsupported entities are ignored and do not raise exceptions.

Most document features stored in the HEADER and OBJECTS sections are not supported by
this module like GROUPS, LAYER_FILTER, GEODATA, SUN.

.. versionadded:: 1.3.0

    Support for ACIS based entities was added.

.. _xref_importing_data:

Importing Data and Resources
----------------------------

The :mod:`ezdxf.xref` module replaces the :class:`~ezdxf.addons.importer.Importer` add-on.

The basic functionality of the :mod:`ezdxf.xref` module is loading data from external
files including their required resources, which is an often requested feature by users
for importing data from other DXF files into the current document.

The :class:`Importer` add-on was very limited and removed many resources,
where the :mod:`ezdxf.xref` module tries to preserve as much information as possible.

    - :func:`load_modelspace` - loads the modelspace content from another DXF document
    - :func:`load_paperspace` - loads a paperspace layout from another DXF document
    - :func:`write_block` - writes entities into the modelspace of a new DXF document
    - :class:`Loader` - low level loading interface

High Level Functions
--------------------

.. autofunction:: attach

.. autofunction:: define

.. autofunction:: detach

.. autofunction:: dxf_info

.. autofunction:: embed

.. autofunction:: load_modelspace

.. autofunction:: load_paperspace

.. autofunction:: write_block

Conflict Policy
---------------

.. autoclass:: ConflictPolicy

Low Level Loading Interface
---------------------------

The :class:`Loader` class is the basic building block for loading entities and
resources. The class manages a list of loading commands which is executed at once by
calling the :meth:`Loader.execute` method. It is important to execute the commands at
once to get a consistent renaming of resources when using resource name prefixes
otherwise the loaded resources would get a new unique name at each loading process even
when the resources are loaded from the same document.

.. autoclass:: Loader

    .. automethod:: load_modelspace

    .. automethod:: load_paperspace_layout

    .. automethod:: load_paperspace_layout_into

    .. automethod:: load_block_layout

    .. automethod:: load_block_layout_into

    .. automethod:: load_layers

    .. automethod:: load_linetypes

    .. automethod:: load_text_styles

    .. automethod:: load_dim_styles

    .. automethod:: load_mline_styles

    .. automethod:: load_mleader_styles

    .. automethod:: load_materials

    .. automethod:: execute



--- End of file: xref.rst ---

